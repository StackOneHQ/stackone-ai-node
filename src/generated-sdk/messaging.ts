// Auto-generated TypeScript SDK from OpenAPI specification
// DO NOT EDIT THIS FILE DIRECTLY

import type { StackOneClientConfig } from './types';

// ============================================================
// Type Definitions
// ============================================================

// Auto-generated TypeScript interfaces from OpenAPI schemas
// DO NOT EDIT THIS FILE DIRECTLY

export interface BadGatewayResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface BadRequestResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
  /** Error details */
  data?: UnifiedError | null;
  /** List of provider-specific errors */
  provider_errors?: ProviderError[] | null;
}

export interface ConflictResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface CreateResult {
  statusCode: number;
  message: string;
  timestamp: string;
  data: CreateResultDataApiModel;
}

export interface CreateResultDataApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
}

export interface DownloadApiModel {
  /** Headers related to the download */
  headers: DownloadHeadersApiModel;
  /** The file data in binary format */
  data: string;
}

export interface DownloadHeadersApiModel {
  /** Value of the Content-Disposition header */
  'content-disposition'?: string | null;
  /** MIME type of the file */
  'content-type'?: string | null;
  /** Size of the content in bytes */
  'content-length'?: number | null;
  /** Range of the content being sent */
  'content-range'?: string | null;
  /** Encoding of the content */
  'content-encoding'?: string | null;
  /** Transfer encoding type */
  'transfer-encoding'?: string | null;
}

export interface ForbiddenResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface InternalServerErrorResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface LmsUser {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The external ID associated with this user */
  external_reference?: string | null;
  /** The user name */
  name?: string | null;
  /** The user email */
  email?: string | null;
  /** The user phone number */
  phone_number?: string | null;
  /** The user active status */
  active?: (boolean | 'true' | 'false') | null;
  /** The created_at date */
  created_at?: string | null;
  /** The updated_at date */
  updated_at?: string | null;
}

export interface MessagingAttachment {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Name of the attached file */
  file_name?: string | null;
  /** Size of the attached file */
  file_size?: number | null;
  /** MIME type of the attached file */
  file_type?: string | null;
}

export interface MessagingAttachmentResult {
  data?: MessagingAttachment | null;
  raw?: RawResponse[] | null;
}

export interface MessagingAttachmentsPaginated {
  next?: string | null;
  data?: MessagingAttachment[] | null;
  raw?: RawResponse[] | null;
}

export interface MessagingConversation {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** List of participant user IDs in the conversation */
  participants?: string[] | null;
  /** Name or title of the conversation */
  name?: string | null;
  /** Whether the conversation is private */
  private?: (boolean | 'true' | 'false') | null;
  /** Timestamp when the conversation was created */
  created_at?: string | null;
  /** Timestamp of the last message in the conversation */
  last_message_at?: string | null;
}

export interface MessagingConversationResult {
  data?: MessagingConversation | null;
  raw?: RawResponse[] | null;
}

export interface MessagingConversationsPaginated {
  next?: string | null;
  data?: MessagingConversation[] | null;
  raw?: RawResponse[] | null;
}

export interface MessagingCreateConversationRequestDto {
  /** List of participant user IDs in the conversation */
  participants?: string[] | null;
  /** Name or title of the conversation */
  name?: string | null;
  /** Whether the conversation is private */
  private?: (boolean | 'true' | 'false') | null;
}

export interface MessagingMessage {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Content of the message */
  content?: MessagingMessageContent | null;
  /** ID of the parent message if this is a reply */
  parent_message_id?: string | null;
  /** List of attachments in the message */
  attachments?: MessagingAttachment[] | null;
  /** Author of the message */
  author?: LmsUser | null;
  /** Timestamp when the message was created */
  created_at?: string | null;
  /** Timestamp when the message was last updated */
  updated_at?: string | null;
}

export interface MessagingMessageContent {
  /** HTML content of the message */
  html?: string | null;
  /** Plain text content of the message */
  plain?: string | null;
}

export interface MessagingMessageResult {
  data?: MessagingMessage | null;
  raw?: RawResponse[] | null;
}

export interface MessagingMessageSendRequestDto {
  /** Content body of the message */
  content?: string | null;
  /** Can be a conversation ID, user ID, email or phone number. */
  recipient?: string | null;
  /** The account_id or phone number of the message sender */
  sender?: string | null;
}

export interface MessagingMessagesPaginated {
  next?: string | null;
  data?: MessagingMessage[] | null;
  raw?: RawResponse[] | null;
}

export interface MessagingUser {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Email address of the user */
  email?: string | null;
  /** Username of the user */
  username?: string | null;
  /** Full name of the user */
  name?: string | null;
  /** First name of the user */
  first_name?: string | null;
  /** Last name of the user */
  last_name?: string | null;
  /** Whether the user is a bot */
  bot?: (boolean | 'true' | 'false') | null;
  /** Whether the user is active */
  active?: (boolean | 'true' | 'false') | null;
}

export interface MessagingUserResult {
  data?: MessagingUser | null;
  raw?: RawResponse[] | null;
}

export interface MessagingUsersPaginated {
  next?: string | null;
  data?: MessagingUser[] | null;
  raw?: RawResponse[] | null;
}

export interface NotFoundResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface NotImplementedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface PreconditionFailedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface ProviderError {
  /** HTTP status code of the provider error */
  status?: number | null;
  /** URL that caused the error */
  url?: string | null;
  /** Raw error response from the provider */
  raw?: Record<string, unknown> | null;
  /** Response headers */
  headers?: Record<string, unknown> | null;
}

export interface RawResponse {
  method: string;
  url: string;
  body?: (string | Record<string, unknown> | number[]) | null;
  response?: (Record<string, unknown> | unknown[] | string) | null;
}

export interface RequestTimedOutResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface TooManyRequestsResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UnauthorizedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UnifiedError {
  /** HTTP status code */
  statusCode?: number | null;
  /** Error message */
  message?: string | null;
  /** Response headers */
  headers?: Record<string, unknown> | null;
}

export interface UnprocessableEntityResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

// ============================================================
// Client Class
// ============================================================

export interface MessagingListConversationsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface MessagingCreateConversationParams {
  body: MessagingCreateConversationRequestDto;
}

export interface MessagingGetConversationParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface MessagingDownloadMessagingAttachmentParams {
  id: string;
  subresourceid: string;
  /** The format to download the file in */
  format?: string | null;
  /** The export format of the file */
  exportFormat?: string | null;
}

export interface MessagingListAttachmentsParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface MessagingGetAttachmentParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface MessagingListUsersParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface MessagingGetUserParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface MessagingListConversationMessagesParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface MessagingGetMessageParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  filter?: Record<string, unknown>;
}

export interface MessagingSendMessageParams {
  body: MessagingMessageSendRequestDto;
}

/**
 * Messaging API Client
 * Auto-generated from OpenAPI specification
 */
export class MessagingClient {
  private baseUrl: string;
  private headers: Record<string, string>;

  constructor(config: StackOneClientConfig) {
    this.baseUrl = config.baseUrl || 'https://api.stackone.com';
    const authToken = Buffer.from(`${config.apiKey}:`).toString('base64');
    this.headers = {
      Authorization: `Basic ${authToken}`,
      'x-account-id': config.accountId,
      ...config.headers,
    };
  }

  /**
   * List Conversations
   */
  async listConversations(
    params?: MessagingListConversationsParams
  ): Promise<MessagingConversationsPaginated> {
    let url = `${this.baseUrl}/unified/messaging/conversations`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<MessagingConversationsPaginated>;
  }

  /**
   * Create Conversation
   */
  async createConversation(params: MessagingCreateConversationParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/messaging/conversations`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get Conversation
   */
  async getConversation(
    params: MessagingGetConversationParams
  ): Promise<MessagingConversationResult> {
    let url = `${this.baseUrl}/unified/messaging/conversations/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<MessagingConversationResult>;
  }

  /**
   * Download Attachment
   */
  async downloadMessagingAttachment(
    params: MessagingDownloadMessagingAttachmentParams
  ): Promise<void> {
    let url = `${this.baseUrl}/unified/messaging/messages/${params.id}/attachments/${params.subresourceid}/download`;
    const queryParts: string[] = [];
    if (params.format !== undefined) {
      queryParts.push(`format=${encodeURIComponent(String(params.format))}`);
    }
    if (params.exportFormat !== undefined) {
      queryParts.push(`export_format=${encodeURIComponent(String(params.exportFormat))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return;
  }

  /**
   * List Attachments
   */
  async listAttachments(
    params: MessagingListAttachmentsParams
  ): Promise<MessagingAttachmentsPaginated> {
    let url = `${this.baseUrl}/unified/messaging/messages/${params.id}/attachments`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<MessagingAttachmentsPaginated>;
  }

  /**
   * Get Attachment
   */
  async getAttachment(params: MessagingGetAttachmentParams): Promise<MessagingAttachmentResult> {
    let url = `${this.baseUrl}/unified/messaging/messages/${params.id}/attachments/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<MessagingAttachmentResult>;
  }

  /**
   * List Users
   */
  async listUsers(params?: MessagingListUsersParams): Promise<MessagingUsersPaginated> {
    let url = `${this.baseUrl}/unified/messaging/users`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<MessagingUsersPaginated>;
  }

  /**
   * Get User
   */
  async getUser(params: MessagingGetUserParams): Promise<MessagingUserResult> {
    let url = `${this.baseUrl}/unified/messaging/users/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<MessagingUserResult>;
  }

  /**
   * List Conversation Messages
   */
  async listConversationMessages(
    params: MessagingListConversationMessagesParams
  ): Promise<MessagingMessagesPaginated> {
    let url = `${this.baseUrl}/unified/messaging/conversations/${params.id}/messages`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<MessagingMessagesPaginated>;
  }

  /**
   * Get Message
   */
  async getMessage(params: MessagingGetMessageParams): Promise<MessagingMessageResult> {
    let url = `${this.baseUrl}/unified/messaging/messages/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      for (const [key, value] of Object.entries(params.filter as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`filter[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<MessagingMessageResult>;
  }

  /**
   * Send Message
   */
  async sendMessage(params: MessagingSendMessageParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/messaging/messages`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }
}
