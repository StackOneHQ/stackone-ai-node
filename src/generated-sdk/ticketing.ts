// Auto-generated TypeScript SDK from OpenAPI specification
// DO NOT EDIT THIS FILE DIRECTLY

import type { StackOneClientConfig } from './types';

// ============================================================
// Type Definitions
// ============================================================

// Auto-generated TypeScript interfaces from OpenAPI schemas
// DO NOT EDIT THIS FILE DIRECTLY

export interface BadGatewayResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface BadRequestResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
  /** Error details */
  data?: UnifiedError | null;
  /** List of provider-specific errors */
  provider_errors?: ProviderError[] | null;
}

export interface ConflictResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface CreateResult {
  statusCode: number;
  message: string;
  timestamp: string;
  data: CreateResultDataApiModel;
}

export interface CreateResultDataApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
}

export interface DownloadApiModel {
  /** Headers related to the download */
  headers: DownloadHeadersApiModel;
  /** The file data in binary format */
  data: string;
}

export interface DownloadHeadersApiModel {
  /** Value of the Content-Disposition header */
  'content-disposition'?: string | null;
  /** MIME type of the file */
  'content-type'?: string | null;
  /** Size of the content in bytes */
  'content-length'?: number | null;
  /** Range of the content being sent */
  'content-range'?: string | null;
  /** Encoding of the content */
  'content-encoding'?: string | null;
  /** Transfer encoding type */
  'transfer-encoding'?: string | null;
}

export interface FileFormatEnum {
  /** The file format of the file, expressed as a file extension */
  value?:
    | 'unmapped_value'
    | 'ez'
    | 'aw'
    | 'atom'
    | 'atomcat'
    | 'atomdeleted'
    | 'atomsvc'
    | 'dwd'
    | 'held'
    | 'rsat'
    | 'bdoc'
    | 'xcs'
    | 'ccxml'
    | 'cdfx'
    | 'cdmia'
    | 'cdmic'
    | 'cdmid'
    | 'cdmio'
    | 'cdmiq'
    | 'cu'
    | 'mpd'
    | 'davmount'
    | 'dbk'
    | 'dssc'
    | 'xdssc'
    | 'es'
    | 'ecma'
    | 'emma'
    | 'emotionml'
    | 'epub'
    | 'exi'
    | 'exp'
    | 'fdt'
    | 'pfr'
    | 'geojson'
    | 'gml'
    | 'gpx'
    | 'gxf'
    | 'gz'
    | 'hjson'
    | 'stk'
    | 'ink'
    | 'inkml'
    | 'ipfix'
    | 'its'
    | 'jar'
    | 'war'
    | 'ear'
    | 'ser'
    | 'class'
    | 'js'
    | 'mjs'
    | 'json'
    | 'map'
    | 'json5'
    | 'jsonml'
    | 'jsonld'
    | 'lgr'
    | 'lostxml'
    | 'hqx'
    | 'cpt'
    | 'mads'
    | 'webmanifest'
    | 'mrc'
    | 'mrcx'
    | 'ma'
    | 'nb'
    | 'mb'
    | 'mathml'
    | 'mbox'
    | 'mscml'
    | 'metalink'
    | 'meta4'
    | 'mets'
    | 'maei'
    | 'musd'
    | 'mods'
    | 'm21'
    | 'mp21'
    | 'mp4s'
    | 'm4p'
    | 'doc'
    | 'dot'
    | 'mxf'
    | 'nq'
    | 'nt'
    | 'cjs'
    | 'bin'
    | 'dms'
    | 'lrf'
    | 'mar'
    | 'so'
    | 'dist'
    | 'distz'
    | 'pkg'
    | 'bpk'
    | 'dump'
    | 'elc'
    | 'deploy'
    | 'exe'
    | 'dll'
    | 'deb'
    | 'dmg'
    | 'iso'
    | 'img'
    | 'msi'
    | 'msp'
    | 'msm'
    | 'buffer'
    | 'oda'
    | 'opf'
    | 'ogx'
    | 'omdoc'
    | 'onetoc'
    | 'onetoc2'
    | 'onetmp'
    | 'onepkg'
    | 'oxps'
    | 'relo'
    | 'xer'
    | 'pdf'
    | 'pgp'
    | 'asc'
    | 'sig'
    | 'prf'
    | 'p10'
    | 'p7m'
    | 'p7c'
    | 'p7s'
    | 'p8'
    | 'ac'
    | 'cer'
    | 'crl'
    | 'pkipath'
    | 'pki'
    | 'pls'
    | 'ai'
    | 'eps'
    | 'ps'
    | 'provx'
    | 'pskcxml'
    | 'raml'
    | 'rdf'
    | 'owl'
    | 'rif'
    | 'rnc'
    | 'rl'
    | 'rld'
    | 'rs'
    | 'rapd'
    | 'sls'
    | 'rusd'
    | 'gbr'
    | 'mft'
    | 'roa'
    | 'rsd'
    | 'rss'
    | 'rtf'
    | 'sbml'
    | 'scq'
    | 'scs'
    | 'spq'
    | 'spp'
    | 'sdp'
    | 'senmlx'
    | 'sensmlx'
    | 'setpay'
    | 'setreg'
    | 'shf'
    | 'siv'
    | 'sieve'
    | 'smi'
    | 'smil'
    | 'rq'
    | 'srx'
    | 'gram'
    | 'grxml'
    | 'sru'
    | 'ssdl'
    | 'ssml'
    | 'swidtag'
    | 'tei'
    | 'teicorpus'
    | 'tfi'
    | 'tsd'
    | 'toml'
    | 'trig'
    | 'ttml'
    | 'ubj'
    | 'rsheet'
    | 'td'
    | 'vxml'
    | 'wasm'
    | 'wgt'
    | 'hlp'
    | 'wsdl'
    | 'wspolicy'
    | 'xaml'
    | 'xav'
    | 'xca'
    | 'xdf'
    | 'xel'
    | 'xns'
    | 'xenc'
    | 'xhtml'
    | 'xht'
    | 'xlf'
    | 'xml'
    | 'xsl'
    | 'xsd'
    | 'rng'
    | 'dtd'
    | 'xop'
    | 'xpl'
    | '*xsl'
    | 'xslt'
    | 'xspf'
    | 'mxml'
    | 'xhvml'
    | 'xvml'
    | 'xvm'
    | 'yang'
    | 'yin'
    | 'zip'
    | '*3gpp'
    | 'adp'
    | 'amr'
    | 'au'
    | 'snd'
    | 'mid'
    | 'midi'
    | 'kar'
    | 'rmi'
    | 'mxmf'
    | '*mp3'
    | 'm4a'
    | 'mp4a'
    | 'mpga'
    | 'mp2'
    | 'mp2a'
    | 'mp3'
    | 'm2a'
    | 'm3a'
    | 'oga'
    | 'ogg'
    | 'spx'
    | 'opus'
    | 's3m'
    | 'sil'
    | 'wav'
    | '*wav'
    | 'weba'
    | 'xm'
    | 'ttc'
    | 'otf'
    | 'ttf'
    | 'woff'
    | 'woff2'
    | 'exr'
    | 'apng'
    | 'avif'
    | 'bmp'
    | 'cgm'
    | 'drle'
    | 'emf'
    | 'fits'
    | 'g3'
    | 'gif'
    | 'heic'
    | 'heics'
    | 'heif'
    | 'heifs'
    | 'hej2'
    | 'hsj2'
    | 'ief'
    | 'jls'
    | 'jp2'
    | 'jpg2'
    | 'jpeg'
    | 'jpg'
    | 'jpe'
    | 'jph'
    | 'jhc'
    | 'jpm'
    | 'jpx'
    | 'jpf'
    | 'jxr'
    | 'jxra'
    | 'jxrs'
    | 'jxs'
    | 'jxsc'
    | 'jxsi'
    | 'jxss'
    | 'ktx'
    | 'ktx2'
    | 'png'
    | 'sgi'
    | 'svg'
    | 'svgz'
    | 't38'
    | 'tif'
    | 'tiff'
    | 'tfx'
    | 'webp'
    | 'wmf'
    | 'disposition-notification'
    | 'u8msg'
    | 'u8dsn'
    | 'u8mdn'
    | 'u8hdr'
    | 'eml'
    | 'mime'
    | '3mf'
    | 'gltf'
    | 'glb'
    | 'igs'
    | 'iges'
    | 'msh'
    | 'mesh'
    | 'silo'
    | 'mtl'
    | 'obj'
    | 'stpx'
    | 'stpz'
    | 'stpxz'
    | 'stl'
    | 'wrl'
    | 'vrml'
    | '*x3db'
    | 'x3dbz'
    | 'x3db'
    | '*x3dv'
    | 'x3dvz'
    | 'x3d'
    | 'x3dz'
    | 'x3dv'
    | 'appcache'
    | 'manifest'
    | 'ics'
    | 'ifb'
    | 'coffee'
    | 'litcoffee'
    | 'css'
    | 'csv'
    | 'html'
    | 'htm'
    | 'shtml'
    | 'jade'
    | 'jsx'
    | 'less'
    | 'markdown'
    | 'md'
    | 'mml'
    | 'mdx'
    | 'n3'
    | 'txt'
    | 'text'
    | 'conf'
    | 'def'
    | 'list'
    | 'log'
    | 'in'
    | 'ini'
    | 'rtx'
    | '*rtf'
    | 'sgml'
    | 'sgm'
    | 'shex'
    | 'slim'
    | 'slm'
    | 'spdx'
    | 'stylus'
    | 'styl'
    | 'tsv'
    | 't'
    | 'tr'
    | 'roff'
    | 'man'
    | 'me'
    | 'ms'
    | 'ttl'
    | 'uri'
    | 'uris'
    | 'urls'
    | 'vcard'
    | 'vtt'
    | '*xml'
    | 'yaml'
    | 'yml'
    | '3gp'
    | '3gpp'
    | '3g2'
    | 'h261'
    | 'h263'
    | 'h264'
    | 'm4s'
    | 'jpgv'
    | '*jpm'
    | 'jpgm'
    | 'mj2'
    | 'mjp2'
    | 'ts'
    | 'mp4'
    | 'mp4v'
    | 'mpg4'
    | 'mpeg'
    | 'mpg'
    | 'mpe'
    | 'm1v'
    | 'm2v'
    | 'ogv'
    | 'qt'
    | 'mov'
    | 'webm'
    | 'cww'
    | '1km'
    | 'plb'
    | 'psb'
    | 'pvb'
    | 'tcap'
    | 'pwn'
    | 'aso'
    | 'imp'
    | 'acu'
    | 'atc'
    | 'acutc'
    | 'air'
    | 'fcdt'
    | 'fxp'
    | 'fxpl'
    | 'xdp'
    | 'xfdf'
    | 'ahead'
    | 'azf'
    | 'azs'
    | 'azw'
    | 'acc'
    | 'ami'
    | 'apk'
    | 'cii'
    | 'fti'
    | 'atx'
    | 'mpkg'
    | 'key'
    | 'm3u8'
    | 'numbers'
    | 'pages'
    | 'pkpass'
    | 'swi'
    | 'iota'
    | 'aep'
    | 'bmml'
    | 'mpm'
    | 'bmi'
    | 'rep'
    | 'cdxml'
    | 'mmd'
    | 'cdy'
    | 'csl'
    | 'cla'
    | 'rp9'
    | 'c4g'
    | 'c4d'
    | 'c4f'
    | 'c4p'
    | 'c4u'
    | 'c11amc'
    | 'c11amz'
    | 'csp'
    | 'cdbcmsg'
    | 'cmc'
    | 'clkx'
    | 'clkk'
    | 'clkp'
    | 'clkt'
    | 'clkw'
    | 'wbs'
    | 'pml'
    | 'ppd'
    | 'car'
    | 'pcurl'
    | 'dart'
    | 'rdz'
    | 'dbf'
    | 'uvf'
    | 'uvvf'
    | 'uvd'
    | 'uvvd'
    | 'uvt'
    | 'uvvt'
    | 'uvx'
    | 'uvvx'
    | 'uvz'
    | 'uvvz'
    | 'fe_launch'
    | 'dna'
    | 'mlp'
    | 'mle'
    | 'dpg'
    | 'dfac'
    | 'kpxx'
    | 'ait'
    | 'svc'
    | 'geo'
    | 'mag'
    | 'nml'
    | 'esf'
    | 'msf'
    | 'qam'
    | 'slt'
    | 'ssf'
    | 'es3'
    | 'et3'
    | 'ez2'
    | 'ez3'
    | 'fdf'
    | 'mseed'
    | 'seed'
    | 'dataless'
    | 'gph'
    | 'ftc'
    | 'fm'
    | 'frame'
    | 'maker'
    | 'book'
    | 'fnc'
    | 'ltf'
    | 'fsc'
    | 'oas'
    | 'oa2'
    | 'oa3'
    | 'fg5'
    | 'bh2'
    | 'ddd'
    | 'xdw'
    | 'xbd'
    | 'fzs'
    | 'txd'
    | 'ggb'
    | 'ggt'
    | 'gex'
    | 'gre'
    | 'gxt'
    | 'g2w'
    | 'g3w'
    | 'gmx'
    | 'gdoc'
    | 'gslides'
    | 'gsheet'
    | 'kml'
    | 'kmz'
    | 'gqf'
    | 'gqs'
    | 'gac'
    | 'ghf'
    | 'gim'
    | 'grv'
    | 'gtm'
    | 'tpl'
    | 'vcg'
    | 'hal'
    | 'zmm'
    | 'hbci'
    | 'les'
    | 'hpgl'
    | 'hpid'
    | 'hps'
    | 'jlt'
    | 'pcl'
    | 'pclxl'
    | 'sfd-hdstx'
    | 'mpy'
    | 'afp'
    | 'listafp'
    | 'list3820'
    | 'irm'
    | 'sc'
    | 'icc'
    | 'icm'
    | 'igl'
    | 'ivp'
    | 'ivu'
    | 'igm'
    | 'xpw'
    | 'xpx'
    | 'i2g'
    | 'qbo'
    | 'qfx'
    | 'rcprofile'
    | 'irp'
    | 'xpr'
    | 'fcs'
    | 'jam'
    | 'rms'
    | 'jisp'
    | 'joda'
    | 'ktz'
    | 'ktr'
    | 'karbon'
    | 'chrt'
    | 'kfo'
    | 'flw'
    | 'kon'
    | 'kpr'
    | 'kpt'
    | 'ksp'
    | 'kwd'
    | 'kwt'
    | 'htke'
    | 'kia'
    | 'kne'
    | 'knp'
    | 'skp'
    | 'skd'
    | 'skt'
    | 'skm'
    | 'sse'
    | 'lasxml'
    | 'lbd'
    | 'lbe'
    | 'apr'
    | 'pre'
    | 'nsf'
    | 'org'
    | 'scm'
    | 'lwp'
    | 'portpkg'
    | 'mvt'
    | 'mcd'
    | 'mc1'
    | 'cdkey'
    | 'mwf'
    | 'mfm'
    | 'flo'
    | 'igx'
    | 'mif'
    | 'daf'
    | 'dis'
    | 'mbk'
    | 'mqy'
    | 'msl'
    | 'plc'
    | 'txf'
    | 'mpn'
    | 'mpc'
    | 'xul'
    | 'cil'
    | 'cab'
    | 'xls'
    | 'xlm'
    | 'xla'
    | 'xlc'
    | 'xlt'
    | 'xlw'
    | 'xlam'
    | 'xlsb'
    | 'xlsm'
    | 'xltm'
    | 'eot'
    | 'chm'
    | 'ims'
    | 'lrm'
    | 'thmx'
    | 'msg'
    | 'cat'
    | '*stl'
    | 'ppt'
    | 'pps'
    | 'pot'
    | 'ppam'
    | 'pptm'
    | 'sldm'
    | 'ppsm'
    | 'potm'
    | 'mpp'
    | 'mpt'
    | 'docm'
    | 'dotm'
    | 'wps'
    | 'wks'
    | 'wcm'
    | 'wdb'
    | 'wpl'
    | 'xps'
    | 'mseq'
    | 'mus'
    | 'msty'
    | 'taglet'
    | 'nlu'
    | 'ntf'
    | 'nitf'
    | 'nnd'
    | 'nns'
    | 'nnw'
    | '*ac'
    | 'ngdat'
    | 'n-gage'
    | 'rpst'
    | 'rpss'
    | 'edm'
    | 'edx'
    | 'ext'
    | 'odc'
    | 'otc'
    | 'odb'
    | 'odf'
    | 'odft'
    | 'odg'
    | 'otg'
    | 'odi'
    | 'oti'
    | 'odp'
    | 'otp'
    | 'ods'
    | 'ots'
    | 'odt'
    | 'odm'
    | 'ott'
    | 'oth'
    | 'xo'
    | 'dd2'
    | 'obgx'
    | 'oxt'
    | 'osm'
    | 'pptx'
    | 'sldx'
    | 'ppsx'
    | 'potx'
    | 'xlsx'
    | 'xltx'
    | 'docx'
    | 'dotx'
    | 'mgp'
    | 'dp'
    | 'esa'
    | 'pdb'
    | 'pqa'
    | 'oprc'
    | 'paw'
    | 'str'
    | 'ei6'
    | 'efif'
    | 'wg'
    | 'plf'
    | 'pbd'
    | 'box'
    | 'mgz'
    | 'qps'
    | 'ptid'
    | 'qxd'
    | 'qxt'
    | 'qwd'
    | 'qwt'
    | 'qxl'
    | 'qxb'
    | 'rar'
    | 'bed'
    | 'mxl'
    | 'musicxml'
    | 'cryptonote'
    | 'cod'
    | 'rm'
    | 'rmvb'
    | 'link66'
    | 'st'
    | 'see'
    | 'sema'
    | 'semd'
    | 'semf'
    | 'ifm'
    | 'itp'
    | 'iif'
    | 'ipk'
    | 'twd'
    | 'twds'
    | 'mmf'
    | 'teacher'
    | 'fo'
    | 'sdkm'
    | 'sdkd'
    | 'dxp'
    | 'sfs'
    | 'sdc'
    | 'sda'
    | 'sdd'
    | 'smf'
    | 'sdw'
    | 'vor'
    | 'sgl'
    | 'smzip'
    | 'sm'
    | 'wadl'
    | 'sxc'
    | 'stc'
    | 'sxd'
    | 'std'
    | 'sxi'
    | 'sti'
    | 'sxm'
    | 'sxw'
    | 'sxg'
    | 'stw'
    | 'sus'
    | 'susp'
    | 'svd'
    | 'sis'
    | 'sisx'
    | 'xsm'
    | 'bdm'
    | 'xdm'
    | 'ddf'
    | 'tao'
    | 'pcap'
    | 'cap'
    | 'dmp'
    | 'tmo'
    | 'tpt'
    | 'mxs'
    | 'tra'
    | 'ufd'
    | 'ufdl'
    | 'utz'
    | 'umj'
    | 'unityweb'
    | 'uoml'
    | 'vcx'
    | 'vsd'
    | 'vst'
    | 'vss'
    | 'vsw'
    | 'vis'
    | 'vsf'
    | 'wbxml'
    | 'wmlc'
    | 'wmlsc'
    | 'wtb'
    | 'nbp'
    | 'wpd'
    | 'wqd'
    | 'stf'
    | 'xar'
    | 'xfdl'
    | 'hvd'
    | 'hvs'
    | 'hvp'
    | 'osf'
    | 'osfpvg'
    | 'saf'
    | 'spf'
    | 'cmp'
    | 'zir'
    | 'zirz'
    | 'zaz'
    | '7z'
    | 'abw'
    | 'ace'
    | '*dmg'
    | 'arj'
    | 'aab'
    | 'x32'
    | 'u32'
    | 'vox'
    | 'aam'
    | 'aas'
    | 'bcpio'
    | '*bdoc'
    | 'torrent'
    | 'blb'
    | 'blorb'
    | 'bz'
    | 'bz2'
    | 'boz'
    | 'cbr'
    | 'cba'
    | 'cbt'
    | 'cbz'
    | 'cb7'
    | 'vcd'
    | 'cfs'
    | 'chat'
    | 'pgn'
    | 'crx'
    | 'cco'
    | 'nsc'
    | 'cpio'
    | 'csh'
    | '*deb'
    | 'udeb'
    | 'dgc'
    | 'dir'
    | 'dcr'
    | 'dxr'
    | 'cst'
    | 'cct'
    | 'cxt'
    | 'w3d'
    | 'fgd'
    | 'swa'
    | 'wad'
    | 'ncx'
    | 'dtb'
    | 'res'
    | 'dvi'
    | 'evy'
    | 'eva'
    | 'bdf'
    | 'gsf'
    | 'psf'
    | 'pcf'
    | 'snf'
    | 'pfa'
    | 'pfb'
    | 'pfm'
    | 'afm'
    | 'arc'
    | 'spl'
    | 'gca'
    | 'ulx'
    | 'gnumeric'
    | 'gramps'
    | 'gtar'
    | 'hdf'
    | 'php'
    | 'install'
    | '*iso'
    | '*key'
    | '*numbers'
    | '*pages'
    | 'jardiff'
    | 'jnlp'
    | 'kdbx'
    | 'latex'
    | 'luac'
    | 'lzh'
    | 'lha'
    | 'run'
    | 'mie'
    | 'prc'
    | 'mobi'
    | 'application'
    | 'lnk'
    | 'wmd'
    | 'wmz'
    | 'xbap'
    | 'mdb'
    | 'obd'
    | 'crd'
    | 'clp'
    | '*exe'
    | '*dll'
    | 'com'
    | 'bat'
    | '*msi'
    | 'mvb'
    | 'm13'
    | 'm14'
    | '*wmf'
    | '*wmz'
    | '*emf'
    | 'emz'
    | 'mny'
    | 'pub'
    | 'scd'
    | 'trm'
    | 'wri'
    | 'nc'
    | 'cdf'
    | 'pac'
    | 'nzb'
    | 'pl'
    | 'pm'
    | '*prc'
    | '*pdb'
    | 'p12'
    | 'pfx'
    | 'p7b'
    | 'spc'
    | 'p7r'
    | '*rar'
    | 'rpm'
    | 'ris'
    | 'sea'
    | 'sh'
    | 'shar'
    | 'swf'
    | 'xap'
    | 'sql'
    | 'sit'
    | 'sitx'
    | 'srt'
    | 'sv4cpio'
    | 'sv4crc'
    | 't3'
    | 'gam'
    | 'tar'
    | 'tcl'
    | 'tk'
    | 'tex'
    | 'tfm'
    | 'texinfo'
    | 'texi'
    | '*obj'
    | 'ustar'
    | 'hdd'
    | 'ova'
    | 'ovf'
    | 'vbox'
    | 'vbox-extpack'
    | 'vdi'
    | 'vhd'
    | 'vmdk'
    | 'src'
    | 'webapp'
    | 'der'
    | 'crt'
    | 'pem'
    | 'fig'
    | '*xlf'
    | 'xpi'
    | 'xz'
    | 'z1'
    | 'z2'
    | 'z3'
    | 'z4'
    | 'z5'
    | 'z6'
    | 'z7'
    | 'z8'
    | 'uva'
    | 'uvva'
    | 'eol'
    | 'dra'
    | 'dts'
    | 'dtshd'
    | 'lvp'
    | 'pya'
    | 'ecelp4800'
    | 'ecelp7470'
    | 'ecelp9600'
    | 'rip'
    | 'aac'
    | 'aif'
    | 'aiff'
    | 'aifc'
    | 'caf'
    | 'flac'
    | '*m4a'
    | 'mka'
    | 'm3u'
    | 'wax'
    | 'wma'
    | 'ram'
    | 'ra'
    | 'rmp'
    | '*ra'
    | 'cdx'
    | 'cif'
    | 'cmdf'
    | 'cml'
    | 'csml'
    | 'xyz'
    | 'btif'
    | 'pti'
    | 'psd'
    | 'azv'
    | 'uvi'
    | 'uvvi'
    | 'uvg'
    | 'uvvg'
    | 'djvu'
    | 'djv'
    | '*sub'
    | 'dwg'
    | 'dxf'
    | 'fbs'
    | 'fpx'
    | 'fst'
    | 'mmr'
    | 'rlc'
    | 'ico'
    | 'dds'
    | 'mdi'
    | 'wdp'
    | 'npx'
    | 'b16'
    | 'tap'
    | 'vtf'
    | 'wbmp'
    | 'xif'
    | 'pcx'
    | '3ds'
    | 'ras'
    | 'cmx'
    | 'fh'
    | 'fhc'
    | 'fh4'
    | 'fh5'
    | 'fh7'
    | '*ico'
    | 'jng'
    | 'sid'
    | '*bmp'
    | '*pcx'
    | 'pic'
    | 'pct'
    | 'pnm'
    | 'pbm'
    | 'pgm'
    | 'ppm'
    | 'rgb'
    | 'tga'
    | 'xbm'
    | 'xpm'
    | 'xwd'
    | 'wsc'
    | 'dae'
    | 'dwf'
    | 'gdl'
    | 'gtw'
    | 'mts'
    | 'ogex'
    | 'x_b'
    | 'x_t'
    | 'vds'
    | 'usdz'
    | 'bsp'
    | 'vtu'
    | 'dsc'
    | 'curl'
    | 'dcurl'
    | 'mcurl'
    | 'scurl'
    | 'sub'
    | 'fly'
    | 'flx'
    | 'gv'
    | '3dml'
    | 'spot'
    | 'jad'
    | 'wml'
    | 'wmls'
    | 's'
    | 'asm'
    | 'c'
    | 'cc'
    | 'cxx'
    | 'cpp'
    | 'h'
    | 'hh'
    | 'dic'
    | 'htc'
    | 'f'
    | 'for'
    | 'f77'
    | 'f90'
    | 'hbs'
    | 'java'
    | 'lua'
    | 'mkd'
    | 'nfo'
    | 'opml'
    | '*org'
    | 'p'
    | 'pas'
    | 'pde'
    | 'sass'
    | 'scss'
    | 'etx'
    | 'sfv'
    | 'ymp'
    | 'uu'
    | 'vcs'
    | 'vcf'
    | 'uvh'
    | 'uvvh'
    | 'uvm'
    | 'uvvm'
    | 'uvp'
    | 'uvvp'
    | 'uvs'
    | 'uvvs'
    | 'uvv'
    | 'uvvv'
    | 'dvb'
    | 'fvt'
    | 'mxu'
    | 'm4u'
    | 'pyv'
    | 'uvu'
    | 'uvvu'
    | 'viv'
    | 'f4v'
    | 'fli'
    | 'flv'
    | 'm4v'
    | 'mkv'
    | 'mk3d'
    | 'mks'
    | 'mng'
    | 'asf'
    | 'asx'
    | 'vob'
    | 'wm'
    | 'wmv'
    | 'wmx'
    | 'wvx'
    | 'avi'
    | 'movie'
    | 'smv'
    | 'ice'
    | 'mht'
    | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface ForbiddenResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface InternalServerErrorResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface NotFoundResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface NotImplementedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface PreconditionFailedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface ProviderError {
  /** HTTP status code of the provider error */
  status?: number | null;
  /** URL that caused the error */
  url?: string | null;
  /** Raw error response from the provider */
  raw?: Record<string, unknown> | null;
  /** Response headers */
  headers?: Record<string, unknown> | null;
}

export interface RawResponse {
  method: string;
  url: string;
  body?: (string | Record<string, unknown> | number[]) | null;
  response?: (Record<string, unknown> | unknown[] | string) | null;
}

export interface RequestTimedOutResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface TicketingAttachment {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The reference ticket ID the attachment belongs to */
  ticket_id?: string | null;
  /** The user who uploaded the file */
  user_id?: string | null;
  /** The name of the file */
  file_name?: string | null;
  /** The type of the file */
  file_format?: FileFormatEnum | null;
  /** The resource URL of the file */
  file_url?: string | null;
  /** The size of the file */
  size?: number | null;
  /** The timestamp when the record was created */
  created_at?: string | null;
  /** The timestamp when the record was last updated */
  updated_at?: string | null;
}

export interface TicketingAttachmentResult {
  data?: TicketingAttachment | null;
  raw?: RawResponse[] | null;
}

export interface TicketingAttachmentsPaginated {
  next?: string | null;
  data?: TicketingAttachment[] | null;
  raw?: RawResponse[] | null;
}

export interface TicketingComment {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The ticket ID associated with the comment */
  ticket_id: string;
  /** The user who created the comment */
  user_id?: string | null;
  /** Whether the comment is internal */
  internal?: (boolean | 'true' | 'false') | null;
  /** Array of content associated with the comment */
  content?: TicketingContent[] | null;
  /** The timestamp when the record was created */
  created_at?: string | null;
  /** The timestamp when the record was last updated */
  updated_at?: string | null;
}

export interface TicketingCommentResult {
  data?: TicketingComment | null;
  raw?: RawResponse[] | null;
}

export interface TicketingCommentsPaginated {
  next?: string | null;
  data?: TicketingComment[] | null;
  raw?: RawResponse[] | null;
}

export interface TicketingComponent {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The organization id related to the component */
  organization_id?: string | null;
  /** The project id related to the component */
  project_id?: string | null;
  /** The name of the component */
  name?: string | null;
  /** The description of the component */
  description?: string | null;
  /** The timestamp when the record was created */
  created_at?: string | null;
  /** The timestamp when the record was last updated */
  updated_at?: string | null;
}

export interface TicketingComponentResult {
  data?: TicketingComponent | null;
  raw?: RawResponse[] | null;
}

export interface TicketingComponentsPaginated {
  next?: string | null;
  data?: TicketingComponent[] | null;
  raw?: RawResponse[] | null;
}

export interface TicketingContent {
  /** The content of the ticket */
  plain?: string | null;
  /** The HTML content of the ticket */
  html?: string | null;
}

export interface TicketingOrganization {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The domain of the organization */
  domain?: string | null;
  /** The name of the organization */
  name?: string | null;
}

export interface TicketingProject {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The name of the project */
  name?: string | null;
  /** The description of the project */
  description?: string | null;
  /** The organization id related to the project */
  organization_id?: string | null;
  /** The timestamp when the record was created */
  created_at?: string | null;
  /** The timestamp when the record was last updated */
  updated_at?: string | null;
}

export interface TicketingProjectResult {
  data?: TicketingProject | null;
  raw?: RawResponse[] | null;
}

export interface TicketingProjectsPaginated {
  next?: string | null;
  data?: TicketingProject[] | null;
  raw?: RawResponse[] | null;
}

export interface TicketingReadTicket {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The title or subject of the ticket */
  title?: string | null;
  /** The creator of the ticket */
  creator_id?: string | null;
  /** Users who reported the ticket */
  reporters?: string[] | null;
  /** Agents assigned to the ticket */
  assignees?: string[] | null;
  /** Array of content associated with the ticket */
  content?: TicketingContent[] | null;
  /** ID of the parent ticket if this is a sub-ticket */
  parent_id?: string | null;
  /** Priority of the ticket */
  priority?: TicketingTicketPriorityTypeEnum | null;
  /** The tags of the ticket */
  tags?: string[] | null;
  /** Projects the ticket belongs to */
  projects?: TicketingProject[] | null;
  /** The unique ticket number or reference ID */
  ticket_number?: string | null;
  /** The type of the ticket */
  type?: TicketingTicketType | null;
  /** The date the ticket was closed */
  closed_at?: string | null;
  /** URL to view the ticket in the source system */
  ticket_url?: string | null;
  /** Current status of the ticket */
  status?: TicketingTicketStatus | null;
  /** Organization associated with the ticket */
  organization?: TicketingOrganization | null;
  /** Components associated with the ticket */
  components?: TicketingComponent[] | null;
  /** The timestamp when the record was created */
  created_at?: string | null;
  /** The timestamp when the record was last updated */
  updated_at?: string | null;
}

export interface TicketingTicketCreateRequestDto {
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The title or subject of the ticket */
  title?: string | null;
  /** The creator of the ticket */
  creator_id?: string | null;
  /** Users who reported the ticket */
  reporters?: string[] | null;
  /** Agents assigned to the ticket */
  assignees?: string[] | null;
  /** Array of content associated with the ticket */
  content?: TicketingContent[] | null;
  /** ID of the parent ticket if this is a sub-ticket */
  parent_id?: string | null;
  /** Priority of the ticket */
  priority?: TicketingTicketPriorityTypeEnum | null;
  /** The tags of the ticket */
  tags?: string[] | null;
  /** Organization associated with the ticket */
  organization_id?: string | null;
  /** Project the ticket belongs to */
  project_id?: string | null;
  /** Components to associate with the ticket */
  component_ids?: string | null;
  /** The type of the ticket */
  type?: string | null;
}

export interface TicketingTicketPriorityTypeEnum {
  /** The id of the ticket priority. */
  id?: string | null;
  /** The priority of the ticket. */
  value?: 'lowest' | 'low' | 'medium' | 'high' | 'highest' | 'unmapped_value' | null;
  /** The source value of the ticket priority. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface TicketingTicketResult {
  data?: TicketingReadTicket | null;
  raw?: RawResponse[] | null;
}

export interface TicketingTicketsPaginated {
  next?: string | null;
  data?: TicketingReadTicket[] | null;
  raw?: RawResponse[] | null;
}

export interface TicketingTicketStatus {
  /** The id of the ticket status. */
  id?: string | null;
  /** The type of this status */
  type?: TicketingTicketStatusTypeEnum | null;
  /** The name of the ticket status. */
  name?: string | null;
}

export interface TicketingTicketStatusesPaginated {
  next?: string | null;
  data?: TicketingTicketStatus[] | null;
  raw?: RawResponse[] | null;
}

export interface TicketingTicketStatusTypeEnum {
  /** The type of this status */
  value?: 'to-do' | 'in-progress' | 'closed' | 'unmapped_value' | null;
  /** The source value of this status type */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface TicketingTicketType {
  /** The id of the ticket type. */
  id?: string | null;
  /** The name of the ticket type. */
  name?: string | null;
  /** The project the ticket type belongs to. */
  project_id?: string | null;
}

export interface TicketingTicketTypePaginated {
  next?: string | null;
  data?: TicketingTicketType[] | null;
  raw?: RawResponse[] | null;
}

export interface TicketingTicketTypeResult {
  data?: TicketingTicketType | null;
  raw?: RawResponse[] | null;
}

export interface TicketingTicketUpdateRequestDto {
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The title or subject of the ticket */
  title?: string | null;
  /** Users who reported the ticket */
  reporters?: string[] | null;
  /** Agents assigned to the ticket */
  assignees?: string[] | null;
  /** Array of content associated with the ticket */
  content?: TicketingContent[] | null;
  /** ID of the parent ticket if this is a sub-ticket */
  parent_id?: string | null;
  /** Priority of the ticket */
  priority?: TicketingTicketPriorityTypeEnum | null;
  /** The tags of the ticket */
  tags?: string[] | null;
  /** Project the ticket belongs to */
  project_id?: string | null;
  /** Components to associate with the ticket */
  component_ids?: string | null;
  /** Current status of the ticket */
  status?: TicketingTicketStatus | null;
}

export interface TicketingUser {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  type?: TicketingUserTypeEnum | null;
  /** John Doe */
  name?: string | null;
  /** The user's primary email address */
  primary_email?: string | null;
  /** The user's primary phone number */
  primary_phone?: string | null;
  /** The username of the user in the provider system */
  username?: string | null;
  /** If the user is active */
  active?: (boolean | 'true' | 'false') | null;
  /** The first name of the user */
  first_name?: string | null;
  /** The last name of the user */
  last_name?: string | null;
  /** The unique account reference assigned as an external user (e.g. the customer account identifier registered on the customer-facing site or portal) */
  customer_account_reference?: string | null;
  /** The timestamp when the record was created */
  created_at?: string | null;
  /** The timestamp when the record was last updated */
  updated_at?: string | null;
}

export interface TicketingUserResult {
  data?: TicketingUser | null;
  raw?: RawResponse[] | null;
}

export interface TicketingUsersPaginated {
  next?: string | null;
  data?: TicketingUser[] | null;
  raw?: RawResponse[] | null;
}

export interface TicketingUserTypeEnum {
  /** The type of the user. */
  value?: 'agent' | 'contact' | 'bot' | 'unmapped_value' | null;
  /** The source value of the user type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface TooManyRequestsResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UnauthorizedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UnifiedError {
  /** HTTP status code */
  statusCode?: number | null;
  /** Error message */
  message?: string | null;
  /** Response headers */
  headers?: Record<string, unknown> | null;
}

export interface UnprocessableEntityResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UpdateResult {
  statusCode: number;
  message: string;
  timestamp: string;
}

// ============================================================
// Client Class
// ============================================================

export interface TicketingListTicketsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface TicketingCreateTicketParams {
  body: TicketingTicketCreateRequestDto;
}

export interface TicketingGetTicketParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface TicketingUpdateTicketParams {
  id: string;
  body: TicketingTicketUpdateRequestDto;
}

export interface TicketingListUsersParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface TicketingGetUserParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface TicketingListCommentsParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface TicketingGetCommentParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface TicketingDownloadTicketingAttachmentParams {
  id: string;
  subresourceid: string;
  /** The format to download the file in */
  format?: string | null;
  /** The export format of the file */
  exportFormat?: string | null;
}

export interface TicketingListAttachmentsParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface TicketingGetAttachmentParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface TicketingListTicketTypesParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface TicketingGetTicketTypeParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface TicketingListProjectsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface TicketingGetProjectParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface TicketingListProjectComponentsParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface TicketingGetProjectComponentParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface TicketingListProjectTicketTypesParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface TicketingListTicketStatusesParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields to return in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

/**
 * Ticketing API Client
 * Auto-generated from OpenAPI specification
 */
export class TicketingClient {
  private baseUrl: string;
  private headers: Record<string, string>;

  constructor(config: StackOneClientConfig) {
    this.baseUrl = config.baseUrl || 'https://api.stackone.com';
    const authToken = Buffer.from(`${config.apiKey}:`).toString('base64');
    this.headers = {
      Authorization: `Basic ${authToken}`,
      'x-account-id': config.accountId,
      ...config.headers,
    };
  }

  /**
   * List Tickets
   */
  async listTickets(params?: TicketingListTicketsParams): Promise<TicketingTicketsPaginated> {
    let url = `${this.baseUrl}/unified/ticketing/tickets`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingTicketsPaginated>;
  }

  /**
   * Create Ticket
   */
  async createTicket(params: TicketingCreateTicketParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/ticketing/tickets`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get Ticket
   */
  async getTicket(params: TicketingGetTicketParams): Promise<TicketingTicketResult> {
    let url = `${this.baseUrl}/unified/ticketing/tickets/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingTicketResult>;
  }

  /**
   * Update Ticket
   */
  async updateTicket(params: TicketingUpdateTicketParams): Promise<UpdateResult> {
    const url = `${this.baseUrl}/unified/ticketing/tickets/${params.id}`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PATCH',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UpdateResult>;
  }

  /**
   * List Users
   */
  async listUsers(params?: TicketingListUsersParams): Promise<TicketingUsersPaginated> {
    let url = `${this.baseUrl}/unified/ticketing/users`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingUsersPaginated>;
  }

  /**
   * Get User
   */
  async getUser(params: TicketingGetUserParams): Promise<TicketingUserResult> {
    let url = `${this.baseUrl}/unified/ticketing/users/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingUserResult>;
  }

  /**
   * List Comments
   */
  async listComments(params: TicketingListCommentsParams): Promise<TicketingCommentsPaginated> {
    let url = `${this.baseUrl}/unified/ticketing/tickets/${params.id}/comments`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingCommentsPaginated>;
  }

  /**
   * Get Comment
   */
  async getComment(params: TicketingGetCommentParams): Promise<TicketingCommentResult> {
    let url = `${this.baseUrl}/unified/ticketing/tickets/${params.id}/comments/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingCommentResult>;
  }

  /**
   * Download Attachment
   */
  async downloadTicketingAttachment(
    params: TicketingDownloadTicketingAttachmentParams
  ): Promise<void> {
    let url = `${this.baseUrl}/unified/ticketing/tickets/${params.id}/attachments/${params.subresourceid}/download`;
    const queryParts: string[] = [];
    if (params.format !== undefined) {
      queryParts.push(`format=${encodeURIComponent(String(params.format))}`);
    }
    if (params.exportFormat !== undefined) {
      queryParts.push(`export_format=${encodeURIComponent(String(params.exportFormat))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return;
  }

  /**
   * List Attachments
   */
  async listAttachments(
    params: TicketingListAttachmentsParams
  ): Promise<TicketingAttachmentsPaginated> {
    let url = `${this.baseUrl}/unified/ticketing/tickets/${params.id}/attachments`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingAttachmentsPaginated>;
  }

  /**
   * Get Attachment
   */
  async getAttachment(params: TicketingGetAttachmentParams): Promise<TicketingAttachmentResult> {
    let url = `${this.baseUrl}/unified/ticketing/tickets/${params.id}/attachments/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingAttachmentResult>;
  }

  /**
   * List Ticket Types
   */
  async listTicketTypes(
    params?: TicketingListTicketTypesParams
  ): Promise<TicketingTicketTypePaginated> {
    let url = `${this.baseUrl}/unified/ticketing/ticket_types`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingTicketTypePaginated>;
  }

  /**
   * Get Ticket Type
   */
  async getTicketType(params: TicketingGetTicketTypeParams): Promise<TicketingTicketTypeResult> {
    let url = `${this.baseUrl}/unified/ticketing/ticket_types/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingTicketTypeResult>;
  }

  /**
   * List Projects
   */
  async listProjects(params?: TicketingListProjectsParams): Promise<TicketingProjectsPaginated> {
    let url = `${this.baseUrl}/unified/ticketing/projects`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingProjectsPaginated>;
  }

  /**
   * Get Project
   */
  async getProject(params: TicketingGetProjectParams): Promise<TicketingProjectResult> {
    let url = `${this.baseUrl}/unified/ticketing/projects/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingProjectResult>;
  }

  /**
   * List Project Components
   */
  async listProjectComponents(
    params: TicketingListProjectComponentsParams
  ): Promise<TicketingComponentsPaginated> {
    let url = `${this.baseUrl}/unified/ticketing/projects/${params.id}/components`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingComponentsPaginated>;
  }

  /**
   * Get Project Component
   */
  async getProjectComponent(
    params: TicketingGetProjectComponentParams
  ): Promise<TicketingComponentResult> {
    let url = `${this.baseUrl}/unified/ticketing/projects/${params.id}/components/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingComponentResult>;
  }

  /**
   * List Project Ticket Types
   */
  async listProjectTicketTypes(
    params: TicketingListProjectTicketTypesParams
  ): Promise<TicketingTicketTypePaginated> {
    let url = `${this.baseUrl}/unified/ticketing/projects/${params.id}/ticket_types`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingTicketTypePaginated>;
  }

  /**
   * List Ticket Statuses
   */
  async listTicketStatuses(
    params: TicketingListTicketStatusesParams
  ): Promise<TicketingTicketStatusesPaginated> {
    let url = `${this.baseUrl}/unified/ticketing/tickets/${params.id}/statuses`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<TicketingTicketStatusesPaginated>;
  }
}
