// Auto-generated TypeScript SDK from OpenAPI specification
// DO NOT EDIT THIS FILE DIRECTLY

import type { StackOneClientConfig } from './types';

// ============================================================
// Type Definitions
// ============================================================

// Auto-generated TypeScript interfaces from OpenAPI schemas
// DO NOT EDIT THIS FILE DIRECTLY

export interface Answer {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Type of the answer */
  type?: AnswerEnum | null;
  /** Values of the answer */
  values?: string[] | null;
}

export interface AnswerEnum {
  /** The type of the answer. */
  value?:
    | 'short_text'
    | 'long_text'
    | 'attachment'
    | 'multi_select'
    | 'single_select'
    | 'boolean'
    | 'number'
    | 'date'
    | 'video'
    | 'reference_check'
    | 'url'
    | 'unmapped_value'
    | null;
  /** The source value of the answer type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface Application {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** Unique identifier of the candidate */
  candidate_id?: string | null;
  /** Provider's unique identifier of the candidate */
  remote_candidate_id?: string | null;
  /** Unique identifier of the job */
  job_id?: string | null;
  /** Provider's unique identifier of the job */
  remote_job_id?: string | null;
  interview_stage?: InterviewStage | null;
  application_stage?: ApplicationStage | null;
  /** Unique identifier of the interview stage */
  interview_stage_id?: string | null;
  /** Provider's unique identifier of the interview stage */
  remote_interview_stage_id?: string | null;
  /** Unique identifier of the application stage */
  application_stage_id?: string | null;
  /** Unique identifier of the application stage */
  remote_application_stage_id?: string | null;
  rejected_reasons?: RejectedReason[] | null;
  /** Unique identifiers of the rejection reasons */
  rejected_reason_ids?: string[] | null;
  /** Provider's unique identifiers of the rejection reasons */
  remote_rejected_reason_ids?: string[] | null;
  /** Date of rejection */
  rejected_at?: string | null;
  /** Unique identifier of the location */
  location_id?: string | null;
  /** Provider's unique identifier of the location */
  remote_location_id?: string | null;
  /** Unique identifiers of the locations */
  location_ids?: string[] | null;
  /** Remote's unique identifiers of the locations */
  remote_location_ids?: string[] | null;
  application_status?: ApplicationStatusEnum | null;
  /** Questionnaires associated with the application */
  questionnaires?: Questionnaire[] | null;
  candidate?: ApplicationCandidate | null;
  /** Use `documents` expand instead */
  attachments?: ApplicationAttachment[] | null;
  /** The documents attached to this application (eg. resume, cover letter etc.) */
  documents?: AtsDocumentApiModel[] | null;
  result_links?: ResultLink[] | null;
  source?: Source | null;
  /** Date of creation */
  created_at?: string | null;
  /** Date of last update */
  updated_at?: string | null;
  /** The application custom fields */
  custom_fields?: CustomFields[] | null;
}

export interface ApplicationAttachment {
  /** The file name of the attachment. */
  file_name?: string | null;
  /** The content of the attachment. */
  content?: string | null;
  /** The URL of the attachment. */
  url?: string | null;
  content_type?: AttachmentContentType | null;
}

export interface ApplicationCandidate {
  /** Candidate name */
  name?: string | null;
  /** First name of the candidate */
  first_name?: string | null;
  /** Last name of the candidate */
  last_name?: string | null;
  /** Email of the candidate */
  email?: string | null;
  /** List of candidate emails */
  emails?: CandidateEmail[] | null;
  /** List of candidate phone numbers including the type of the number when available */
  phone_numbers?: PhoneNumber[] | null;
  /** List of candidate social links */
  social_links?: SocialLink[] | null;
  /** Candidate company */
  company?: string | null;
  /** Candidate title */
  title?: string | null;
}

export interface ApplicationChanges {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Timestamp when the change was created */
  created_at: string;
  /** Timestamp when the change became effective */
  effective_at?: string | null;
  /** The actor who made the change */
  actor?: ChangesActor | null;
  /** The type of change that occurred to the application */
  change_type?: ApplicationChangeTypeEnum | null;
  /** The new values for changed application properties. Only includes fields that commonly change over the application lifecycle. */
  new_values: ApplicationChangesDataModel;
}

export interface ApplicationChangesDataModel {
  /** Unique identifier of the interview stage */
  interview_stage_id?: string | null;
  /** Unique identifiers of the rejection reasons */
  rejected_reason_ids?: string[] | null;
  application_status?: ApplicationStatusEnum | null;
}

export interface ApplicationChangesPaginated {
  next?: string | null;
  data?: ApplicationChanges[] | null;
  raw?: RawResponse[] | null;
}

export interface ApplicationChangeTypeEnum {
  /** The type of change that occurred to the application */
  value?: 'application_status' | 'interview_stage' | 'rejected_reasons' | 'unmapped_value' | null;
  /** The source value of the change type */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface ApplicationResult {
  data: Application;
  raw?: RawResponse[] | null;
}

export interface ApplicationsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: Application[];
  raw?: RawResponse[] | null;
}

export interface ApplicationStage {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** Application Stage name */
  name?: string | null;
  /** Application Stage order */
  order?: number | null;
  /** Application Stage created date */
  created_at?: string | null;
  /** Application Stage updated date */
  updated_at?: string | null;
}

export interface ApplicationStageResult {
  data: ApplicationStage;
  raw?: RawResponse[] | null;
}

export interface ApplicationStagesPaginated {
  next_page?: string | null;
  next?: string | null;
  data: ApplicationStage[];
  raw?: RawResponse[] | null;
}

export interface ApplicationStatusEnum {
  /** The status of the application. */
  value?:
    | 'active'
    | 'assessment'
    | 'background_check'
    | 'converted'
    | 'declined_by_candidate'
    | 'hired'
    | 'interview'
    | 'lead'
    | 'offer'
    | 'reference_check'
    | 'rejected'
    | 'review'
    | 'screen'
    | 'new'
    | 'onboarding'
    | 'created'
    | 'accepted'
    | 'short_list'
    | 'approved'
    | 'unmapped_value'
    | null;
  /** The source value of the application status. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface AssessmentPackage {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Package name */
  name?: string | null;
  /** Package description */
  description?: string | null;
}

export interface AssessmentPackagePaginated {
  next_page?: string | null;
  next?: string | null;
  data: AssessmentPackage[];
  raw?: RawResponse[] | null;
}

export interface AssessmentPackageResult {
  data: AssessmentPackage;
  raw?: RawResponse[] | null;
}

export interface AssessmentTypeEnum {
  /** The type of the description. */
  value?:
    | 'responsibilities'
    | 'skills'
    | 'benefits'
    | 'company_overview'
    | 'description'
    | 'other'
    | 'unmapped_value'
    | null;
  /** The source value of the description type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface AtsCreateApplicationRequestDto {
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
  /** Unique identifier of the job */
  job_id?: string | null;
  /** Unique identifier of the job posting that is associated with application */
  job_posting_id?: string | null;
  /** Unique identifier of the location */
  location_id?: string | null;
  application_status?: ApplicationStatusEnum | null;
  /** Questionnaires associated with the application */
  questionnaires?: CreateQuestionnaire[] | null;
  source?: CreateSource | null;
  /** Unique identifier of the candidate. Provide this OR candidate, but not both. */
  candidate_id?: string | null;
  /** Candidate Properties. Provide this OR candidate_id, but not both. Providing this attempts to create a new candidate with the application. */
  candidate?: CreateCandidate | null;
  /** Document Properties. Providing this attempts to upload files with the application. */
  documents?: AtsDocumentsUploadRequestDto[] | null;
}

export interface AtsCreateBackgroundCheckOrderRequestDto {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  application?: OrderApplicationApiModel | null;
  job?: OrderJobApiModel | null;
  candidate?: OrderCandidateApiModel | null;
  requester?: OrderJobHiringTeamApiModel | null;
  /** Results update url */
  results_update_url?: string | null;
  package?: OrderBackgroundCheckPackageApiModel | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface AtsCreateBackgroundCheckPackagesRequestDto {
  /** Package name */
  name?: string | null;
  /** Package description */
  description?: string | null;
  /** Package tests */
  tests?: CreatePackage[] | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface AtsCreateCandidateRequestDto {
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The candidate personal phone number */
  phone_number?: string | null;
  /** List of candidate phone numbers including the type of the number when available */
  phone_numbers?: PhoneNumber[] | null;
  /** Candidate name */
  name?: string | null;
  /** Candidate first name */
  first_name?: string | null;
  /** Candidate last name */
  last_name?: string | null;
  /** Candidate email */
  email?: string | null;
  /** List of candidate social links */
  social_links?: SocialLink[] | null;
  /** Candidate company */
  company?: string | null;
  /** Candidate title */
  title?: string | null;
  /** Candidate hired date */
  hired_at?: string | null;
  /** Candidate country */
  country?: string | null;
  /** The candidate custom fields */
  custom_fields?: CustomFields[] | null;
}

export interface AtsCreateCandidatesAssessmentsRequestDto {
  /** Unique identifier */
  id?: string | null;
  package?: OrderPackageApiModel | null;
  application?: OrderApplicationApiModel | null;
  job?: OrderJobApiModel | null;
  candidate?: OrderCandidateApiModel | null;
  requester?: OrderJobHiringTeamApiModel | null;
  /** Results update url */
  results_update_url?: string | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface AtsCreateJobRequestDto {
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** Code of the job */
  code?: string | null;
  /** Title of the job */
  title?: string | null;
  /** Description of the job */
  description?: string | null;
  /** Status of the job */
  status?: string | null;
  /** Status of the job */
  job_status?: AtsJobStatusEnum | null;
  /** Department ids of the job */
  department_ids?: string[] | null;
  /** Location ids of the job */
  location_ids?: string[] | null;
  /** Hiring team for the job. */
  hiring_team?: AtsJobHiringTeam[] | null;
  /** Interview stages for the job. */
  interview_stages?: InterviewStage[] | null;
  /** Confidential status of the job */
  confidential?: 'true' | 'false' | 'unmapped_value' | null;
  /** The job custom fields */
  custom_fields?: CustomFields[] | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface AtsCreateNotesRequestDto {
  content?: NoteContentApiModel[] | null;
  /** Unique identifier of the author */
  author_id?: string | null;
  /** Visibility of the note */
  visibility?: NotesVisibilityEnum | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface AtsCreateOfferRequestDto {
  application_id?: string | null;
  /** Date of creation */
  start_date?: string | null;
  offer_status?: OfferStatusEnum | null;
  salary?: number | null;
  currency?: string | null;
  offer_history?: OfferHistory[] | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface AtsDocumentApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The name of the file */
  name?: string | null;
  /** The category of the the document */
  category?: FileCategoryEnumApiModel | null;
  /** The content of the file. Deprecated, use `url` and `file_format` one level up instead */
  contents?: Content[] | null;
  /** The categoryId of the documents */
  category_id?: string | null;
  /** The creation date of the file */
  created_at?: string | null;
  /** The update date of the file */
  updated_at?: string | null;
  /** URL where the file content is located */
  remote_url?: string | null;
  /** The file format of the file */
  file_format?: FileFormatEnum | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The content type of the document */
  type?: AtsDocumentTypeEnum | null;
}

export interface AtsDocumentResult {
  data: AtsDocumentApiModel;
  raw?: RawResponse[] | null;
}

export interface AtsDocumentsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: AtsDocumentApiModel[];
  raw?: RawResponse[] | null;
}

export interface AtsDocumentsUploadCategoryEnumApiModel {
  /** The category name to associate with the file */
  value?:
    | 'resume'
    | 'avatar'
    | 'cover_letter'
    | 'profile_picture'
    | 'policy'
    | 'passport'
    | 'assessment'
    | 'interview_attachment'
    | 'take_home_test'
    | 'offer_letter'
    | 'signed_offer_letter'
    | 'national_id'
    | 'offer_packet'
    | 'other'
    | 'unmapped_value'
    | null;
  /** The provider specific category for associating uploaded files, if provided, the value will be ignored. */
  source_value?: string | null;
}

export interface AtsDocumentsUploadRequestDto {
  /** The filename of the file to upload */
  name?: string | null;
  /** The file format of the file */
  file_format?: FileFormatEnum | null;
  /** The base64 encoded content of the file to upload */
  content?: string | null;
  /** The categoryId of the documents */
  category_id?: string | null;
  /** The path for the file to be uploaded to */
  path?: string | null;
  /** The confidentiality level of the file to be uploaded */
  confidential?: ConfidentialEnumApiModel | null;
  /** The category to be associated with the file to be uploaded. Id will take precedence over name. */
  category?: AtsDocumentsUploadCategoryEnumApiModel | null;
}

export interface AtsDocumentTypeEnum {
  /** The category of the file */
  value?:
    | 'resume'
    | 'avatar'
    | 'cover_letter'
    | 'profile_picture'
    | 'policy'
    | 'passport'
    | 'assessment'
    | 'interview_attachment'
    | 'take_home_test'
    | 'offer_letter'
    | 'signed_offer_letter'
    | 'national_id'
    | 'offer_packet'
    | 'other'
    | 'unmapped_value'
    | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface AtsJob {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** Code of the job */
  code?: string | null;
  /** Title of the job */
  title?: string | null;
  /** Description of the job */
  description?: string | null;
  /** Status of the job */
  status?: string | null;
  /** Status of the job */
  job_status?: AtsJobStatusEnum | null;
  /** Department ids of the job */
  department_ids?: string[] | null;
  /** Provider's department ids of the job */
  remote_department_ids?: string[] | null;
  /** Location ids of the job */
  location_ids?: string[] | null;
  /** Provider's location ids of the job */
  remote_location_ids?: string[] | null;
  /** Hiring team for the job. */
  hiring_team?: AtsJobHiringTeam[] | null;
  /** Interview stages for the job. */
  interview_stages?: InterviewStage[] | null;
  /** Confidential status of the job */
  confidential?: 'true' | 'false' | 'unmapped_value' | null;
  /** The job custom fields */
  custom_fields?: CustomFields[] | null;
  /** Date of creation */
  created_at?: string | null;
  /** Date of last update */
  updated_at?: string | null;
}

export interface AtsJobHiringTeam {
  /** User ID of the hiring team member. */
  user_id?: string | null;
  /** Provider's unique identifier of the user */
  remote_user_id?: string | null;
  /** First name of the hiring team member. */
  first_name?: string | null;
  /** Last name of the hiring team member. */
  last_name?: string | null;
  /** Email of the hiring team member. */
  email?: string | null;
  /** Role of the hiring team member. */
  role?: string | null;
}

export interface AtsJobResult {
  data: AtsJob;
  raw?: RawResponse[] | null;
}

export interface AtsJobsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: AtsJob[];
  raw?: RawResponse[] | null;
}

export interface AtsJobStatusEnum {
  /** The status of the job. */
  value?:
    | 'published'
    | 'draft'
    | 'pending'
    | 'internal'
    | 'archived'
    | 'closed'
    | 'open'
    | 'deleted'
    | 'on_hold'
    | 'unmapped_value'
    | null;
  /** The source value of the job status. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface ATSLocation {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  name?: string | null;
}

export interface ATSLocationResult {
  data: ATSLocation;
  raw?: RawResponse[] | null;
}

export interface ATSLocationsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: ATSLocation[];
  raw?: RawResponse[] | null;
}

export interface AtsMoveApplicationRequestDto {
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
  /** Unique identifier of the application stage. */
  interview_stage_id?: string | null;
}

export interface AtsRejectApplicationRequestDto {
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
  /** Unique identifier of the rejection reason */
  rejected_reason_id?: string | null;
}

export interface AtsUpdateApplicationRequestDto {
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
  /** The application custom fields */
  custom_fields?: CustomFields[] | null;
  application_status?: ApplicationStatusEnum | null;
  source?: CreateSource | null;
}

export interface AtsUpdateBackgroundCheckPackagesRequestDto {
  /** Package name */
  name?: string | null;
  /** Package description */
  description?: string | null;
  /** Package tests */
  tests?: UpdatePackage[] | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface AtsUpdateBackgroundCheckResultRequestDto {
  score?: ScoreApiModel | null;
  /** The start date of the candidate test */
  start_date?: string | null;
  /** The submission date of the candidate test */
  submission_date?: string | null;
  /** The summary about the result of the test */
  summary?: string | null;
  result?: ResultEnum | null;
  /** The test`s result url */
  result_url?: string | null;
  attachments?: Attachment[] | null;
  candidate?: UpdateResultCandidateApiModel | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface AtsUpdateCandidateRequestDto {
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** Candidate name */
  name?: string | null;
  /** Candidate first name */
  first_name?: string | null;
  /** Candidate last name */
  last_name?: string | null;
  /** Candidate email */
  email?: string | null;
  /** List of candidate emails */
  emails?: CandidateEmail[] | null;
  /** List of candidate social links */
  social_links?: SocialLink[] | null;
  /** Candidate phone number */
  phone?: string | null;
  /** List of candidate phone numbers including the type of the number when available */
  phone_numbers?: PhoneNumber[] | null;
  /** Candidate company */
  company?: string | null;
  /** Candidate title */
  title?: string | null;
  /** List of candidate application IDs */
  application_ids?: string[] | null;
  /** Candidate hired date */
  hired_at?: string | null;
  /** Candidate country */
  country?: string | null;
  /** The candidate custom fields */
  custom_fields?: CustomFields[] | null;
}

export interface AtsUpdateCandidatesAssessmentsResultsRequestDto {
  score?: ScoreApiModel | null;
  /** The start date of the candidate test */
  start_date?: string | null;
  /** The submission date of the candidate test */
  submission_date?: string | null;
  /** The summary about the result of the test */
  summary?: string | null;
  result?: ResultEnum | null;
  /** The test`s result url */
  result_url?: string | null;
  attachments?: Attachment[] | null;
  candidate?: UpdateResultCandidateApiModel | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface AtsUpdateJobRequestDto {
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** Code of the job */
  code?: string | null;
  /** Title of the job */
  title?: string | null;
  /** Description of the job */
  description?: string | null;
  /** Status of the job */
  status?: string | null;
  /** Status of the job */
  job_status?: AtsJobStatusEnum | null;
  /** Department ids of the job */
  department_ids?: string[] | null;
  /** Location ids of the job */
  location_ids?: string[] | null;
  /** Hiring team for the job. */
  hiring_team?: AtsJobHiringTeam[] | null;
  /** Interview stages for the job. */
  interview_stages?: InterviewStage[] | null;
  /** Confidential status of the job */
  confidential?: 'true' | 'false' | 'unmapped_value' | null;
  /** The job custom fields */
  custom_fields?: CustomFields[] | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface AtsUpdateNotesRequestDto {
  content?: NoteContentApiModel[] | null;
  /** Unique identifier of the author */
  author_id?: string | null;
  /** Visibility of the note */
  visibility?: NotesVisibilityEnum | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface Attachment {
  /** The URL of the attachment. */
  url?: string | null;
  content_type?: AttachmentContentType | null;
}

export interface AttachmentContentType {
  /** The content type of the attachment. */
  value?: 'text' | 'pdf' | 'video' | 'other' | 'unmapped_value' | null;
  /** The source value of the content type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface BackgroundCheckPackage {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Package name */
  name?: string | null;
  /** Package description */
  description?: string | null;
  /** Package tests */
  tests?: Package[] | null;
}

export interface BackgroundCheckPackagePaginated {
  next_page?: string | null;
  next?: string | null;
  data: BackgroundCheckPackage[];
  raw?: RawResponse[] | null;
}

export interface BackgroundCheckPackageResult {
  data: BackgroundCheckPackage;
  raw?: RawResponse[] | null;
}

export interface BadGatewayResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface BadRequestResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
  /** Error details */
  data?: UnifiedError | null;
  /** List of provider-specific errors */
  provider_errors?: ProviderError[] | null;
}

export interface Candidate {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** Candidate name */
  name?: string | null;
  /** Candidate first name */
  first_name?: string | null;
  /** Candidate last name */
  last_name?: string | null;
  /** Candidate email */
  email?: string | null;
  /** List of candidate emails */
  emails?: CandidateEmail[] | null;
  /** List of candidate social links */
  social_links?: SocialLink[] | null;
  /** Candidate phone number */
  phone?: string | null;
  /** List of candidate phone numbers including the type of the number when available */
  phone_numbers?: PhoneNumber[] | null;
  /** Candidate company */
  company?: string | null;
  /** Candidate title */
  title?: string | null;
  /** List of candidate application IDs */
  application_ids?: string[] | null;
  /** Provider's list of candidate application IDs */
  remote_application_ids?: string[] | null;
  /** Candidate hired date */
  hired_at?: string | null;
  /** Candidate country */
  country?: string | null;
  /** The candidate custom fields */
  custom_fields?: CustomFields[] | null;
  /** List of candidate tags indicating metadata associated with the candidate */
  tags?: Tag[] | null;
  /** Candidate created date */
  created_at?: string | null;
  /** Candidate updated date */
  updated_at?: string | null;
}

export interface CandidateEmail {
  /** Type of the email */
  type?: string | null;
  /** Email value */
  value?: string | null;
}

export interface CandidateResult {
  data: Candidate;
  raw?: RawResponse[] | null;
}

export interface CandidatesPaginated {
  next_page?: string | null;
  next?: string | null;
  data: Candidate[];
  raw?: RawResponse[] | null;
}

export interface ChangesActor {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
}

export interface CompensationTypeEnum {
  /** The type of the compensation. */
  value?:
    | 'salary'
    | 'hourly'
    | 'commission'
    | 'bonus'
    | 'equity'
    | 'other'
    | 'unmapped_value'
    | null;
  /** The source value of the compensation type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface ConditionTypeEnum {
  /** The type of the question's condition */
  value?: 'equals_to' | 'contains' | 'unmapped_value' | null;
  /** The source value of the question's condition type */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface ConfidentialEnumApiModel {
  /** Whether the file is confidential or not */
  value?: 'true' | 'false' | 'unmapped_value' | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface ConflictResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface Content {
  /** URL where the file content is located */
  url?: string | null;
  /** Unified download URL for retrieving file content. */
  unified_url?: string | null;
  /** The file format of the file */
  file_format?: FileFormatEnum | null;
}

export interface CreateAnswer {
  /** Unique identifier */
  id?: string | null;
  /** Type of the answer */
  type?: AnswerEnum | null;
  /** Values of the answer */
  values?: string[] | null;
}

export interface CreateAssessmentOrderResult {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Test url */
  test_url?: string | null;
}

export interface CreateBackgroundCheckOrderResult {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Test url */
  test_url?: string | null;
}

export interface CreateCandidate {
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The candidate personal phone number */
  phone_number?: string | null;
  /** List of candidate phone numbers including the type of the number when available */
  phone_numbers?: PhoneNumber[] | null;
  /** Candidate name */
  name?: string | null;
  /** Candidate first name */
  first_name?: string | null;
  /** Candidate last name */
  last_name?: string | null;
  /** Candidate email */
  email?: string | null;
  /** List of candidate social links */
  social_links?: SocialLink[] | null;
  /** Candidate company */
  company?: string | null;
  /** Candidate title */
  title?: string | null;
  /** Candidate hired date */
  hired_at?: string | null;
  /** Candidate country */
  country?: string | null;
  /** The candidate custom fields */
  custom_fields?: CustomFields[] | null;
}

export interface CreatePackage {
  /** Package name */
  name?: string | null;
  /** Package description */
  description?: string | null;
}

export interface CreateQuestionnaire {
  /** Unique identifier */
  id?: string | null;
  answers?: CreateAnswer[] | null;
}

export interface CreateResult {
  statusCode: number;
  message: string;
  timestamp: string;
  data: CreateResultDataApiModel;
}

export interface CreateResultDataApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
}

export interface CreateSource {
  /** Unique identifier */
  id?: string | null;
  /** The source of the application */
  name?: string | null;
}

export interface CustomFieldDefinition {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  name?: string | null;
  description?: string | null;
  /** The type of the custom field. */
  type?: CustomFieldTypeEnum | null;
  /** An array of possible options for the custom field. */
  options?: CustomFieldOption[] | null;
}

export interface CustomFieldDefinitionResultApiModel {
  data: CustomFieldDefinition;
  raw?: RawResponse[] | null;
}

export interface CustomFieldDefinitionsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: CustomFieldDefinition[];
  raw?: RawResponse[] | null;
}

export interface CustomFieldOption {
  /** The unique identifier for the option to be used when updating the custom field */
  id: string;
  /** The human readable value of the option */
  value: string | number | boolean | Record<string, unknown> | unknown[];
}

export interface CustomFields {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The name of the custom field. */
  name?: string | null;
  /** The value associated with the custom field. */
  value?: (string | number | boolean | Record<string, unknown> | unknown[] | string) | null;
  /** The unique identifier for the value of the custom field. */
  value_id?: string | null;
  /** Provider's unique identifier for the value of the custom field. */
  remote_value_id?: string | null;
}

export interface CustomFieldTypeEnum {
  value?:
    | 'date'
    | 'float'
    | 'integer'
    | 'list'
    | 'checkbox'
    | 'text'
    | 'boolean'
    | 'single_select'
    | 'multi_select'
    | 'url'
    | 'other'
    | 'unmapped_value'
    | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface DeleteResult {
  statusCode: number;
  message: string;
  timestamp: string;
}

export interface Department {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  name?: string | null;
}

export interface DepartmentResult {
  data: Department;
  raw?: RawResponse[] | null;
}

export interface DepartmentsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: Department[];
  raw?: RawResponse[] | null;
}

export interface DownloadApiModel {
  /** Headers related to the download */
  headers: DownloadHeadersApiModel;
  /** The file data in binary format */
  data: string;
}

export interface DownloadHeadersApiModel {
  /** Value of the Content-Disposition header */
  'content-disposition'?: string | null;
  /** MIME type of the file */
  'content-type'?: string | null;
  /** Size of the content in bytes */
  'content-length'?: number | null;
  /** Range of the content being sent */
  'content-range'?: string | null;
  /** Encoding of the content */
  'content-encoding'?: string | null;
  /** Transfer encoding type */
  'transfer-encoding'?: string | null;
}

export interface EmploymentContractTypeEnum {
  /** The employment contract type. */
  value?: 'full_time' | 'shifts' | 'part_time' | 'unmapped_value' | null;
  /** The source value of the employment contract type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface EmploymentTypeEnum {
  /** The type of the employment. */
  value?:
    | 'contractor'
    | 'intern'
    | 'permanent'
    | 'apprentice'
    | 'freelance'
    | 'terminated'
    | 'temporary'
    | 'seasonal'
    | 'volunteer'
    | 'probation'
    | 'internal'
    | 'external'
    | 'expatriate'
    | 'employer_of_record'
    | 'casual'
    | 'Programme'
    | 'unmapped_value'
    | null;
  /** The source value of the employment type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface Field {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The label of the field */
  label?: string | null;
  /** The type of the field */
  type?:
    | 'short_text'
    | 'long_text'
    | 'multi_select'
    | 'single_select'
    | 'boolean'
    | 'number'
    | 'date'
    | 'phone'
    | 'email'
    | 'score'
    | 'location'
    | 'unmapped_value'
    | null;
  /** The possible values for the field */
  values?: string[] | null;
  /** Indicates if the field is required */
  required?: (boolean | 'true' | 'false') | null;
}

export interface FileCategoryEnumApiModel {
  /** The category of the file */
  value?: string | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface FileFormatEnum {
  /** The file format of the file, expressed as a file extension */
  value?:
    | 'unmapped_value'
    | 'ez'
    | 'aw'
    | 'atom'
    | 'atomcat'
    | 'atomdeleted'
    | 'atomsvc'
    | 'dwd'
    | 'held'
    | 'rsat'
    | 'bdoc'
    | 'xcs'
    | 'ccxml'
    | 'cdfx'
    | 'cdmia'
    | 'cdmic'
    | 'cdmid'
    | 'cdmio'
    | 'cdmiq'
    | 'cu'
    | 'mpd'
    | 'davmount'
    | 'dbk'
    | 'dssc'
    | 'xdssc'
    | 'es'
    | 'ecma'
    | 'emma'
    | 'emotionml'
    | 'epub'
    | 'exi'
    | 'exp'
    | 'fdt'
    | 'pfr'
    | 'geojson'
    | 'gml'
    | 'gpx'
    | 'gxf'
    | 'gz'
    | 'hjson'
    | 'stk'
    | 'ink'
    | 'inkml'
    | 'ipfix'
    | 'its'
    | 'jar'
    | 'war'
    | 'ear'
    | 'ser'
    | 'class'
    | 'js'
    | 'mjs'
    | 'json'
    | 'map'
    | 'json5'
    | 'jsonml'
    | 'jsonld'
    | 'lgr'
    | 'lostxml'
    | 'hqx'
    | 'cpt'
    | 'mads'
    | 'webmanifest'
    | 'mrc'
    | 'mrcx'
    | 'ma'
    | 'nb'
    | 'mb'
    | 'mathml'
    | 'mbox'
    | 'mscml'
    | 'metalink'
    | 'meta4'
    | 'mets'
    | 'maei'
    | 'musd'
    | 'mods'
    | 'm21'
    | 'mp21'
    | 'mp4s'
    | 'm4p'
    | 'doc'
    | 'dot'
    | 'mxf'
    | 'nq'
    | 'nt'
    | 'cjs'
    | 'bin'
    | 'dms'
    | 'lrf'
    | 'mar'
    | 'so'
    | 'dist'
    | 'distz'
    | 'pkg'
    | 'bpk'
    | 'dump'
    | 'elc'
    | 'deploy'
    | 'exe'
    | 'dll'
    | 'deb'
    | 'dmg'
    | 'iso'
    | 'img'
    | 'msi'
    | 'msp'
    | 'msm'
    | 'buffer'
    | 'oda'
    | 'opf'
    | 'ogx'
    | 'omdoc'
    | 'onetoc'
    | 'onetoc2'
    | 'onetmp'
    | 'onepkg'
    | 'oxps'
    | 'relo'
    | 'xer'
    | 'pdf'
    | 'pgp'
    | 'asc'
    | 'sig'
    | 'prf'
    | 'p10'
    | 'p7m'
    | 'p7c'
    | 'p7s'
    | 'p8'
    | 'ac'
    | 'cer'
    | 'crl'
    | 'pkipath'
    | 'pki'
    | 'pls'
    | 'ai'
    | 'eps'
    | 'ps'
    | 'provx'
    | 'pskcxml'
    | 'raml'
    | 'rdf'
    | 'owl'
    | 'rif'
    | 'rnc'
    | 'rl'
    | 'rld'
    | 'rs'
    | 'rapd'
    | 'sls'
    | 'rusd'
    | 'gbr'
    | 'mft'
    | 'roa'
    | 'rsd'
    | 'rss'
    | 'rtf'
    | 'sbml'
    | 'scq'
    | 'scs'
    | 'spq'
    | 'spp'
    | 'sdp'
    | 'senmlx'
    | 'sensmlx'
    | 'setpay'
    | 'setreg'
    | 'shf'
    | 'siv'
    | 'sieve'
    | 'smi'
    | 'smil'
    | 'rq'
    | 'srx'
    | 'gram'
    | 'grxml'
    | 'sru'
    | 'ssdl'
    | 'ssml'
    | 'swidtag'
    | 'tei'
    | 'teicorpus'
    | 'tfi'
    | 'tsd'
    | 'toml'
    | 'trig'
    | 'ttml'
    | 'ubj'
    | 'rsheet'
    | 'td'
    | 'vxml'
    | 'wasm'
    | 'wgt'
    | 'hlp'
    | 'wsdl'
    | 'wspolicy'
    | 'xaml'
    | 'xav'
    | 'xca'
    | 'xdf'
    | 'xel'
    | 'xns'
    | 'xenc'
    | 'xhtml'
    | 'xht'
    | 'xlf'
    | 'xml'
    | 'xsl'
    | 'xsd'
    | 'rng'
    | 'dtd'
    | 'xop'
    | 'xpl'
    | '*xsl'
    | 'xslt'
    | 'xspf'
    | 'mxml'
    | 'xhvml'
    | 'xvml'
    | 'xvm'
    | 'yang'
    | 'yin'
    | 'zip'
    | '*3gpp'
    | 'adp'
    | 'amr'
    | 'au'
    | 'snd'
    | 'mid'
    | 'midi'
    | 'kar'
    | 'rmi'
    | 'mxmf'
    | '*mp3'
    | 'm4a'
    | 'mp4a'
    | 'mpga'
    | 'mp2'
    | 'mp2a'
    | 'mp3'
    | 'm2a'
    | 'm3a'
    | 'oga'
    | 'ogg'
    | 'spx'
    | 'opus'
    | 's3m'
    | 'sil'
    | 'wav'
    | '*wav'
    | 'weba'
    | 'xm'
    | 'ttc'
    | 'otf'
    | 'ttf'
    | 'woff'
    | 'woff2'
    | 'exr'
    | 'apng'
    | 'avif'
    | 'bmp'
    | 'cgm'
    | 'drle'
    | 'emf'
    | 'fits'
    | 'g3'
    | 'gif'
    | 'heic'
    | 'heics'
    | 'heif'
    | 'heifs'
    | 'hej2'
    | 'hsj2'
    | 'ief'
    | 'jls'
    | 'jp2'
    | 'jpg2'
    | 'jpeg'
    | 'jpg'
    | 'jpe'
    | 'jph'
    | 'jhc'
    | 'jpm'
    | 'jpx'
    | 'jpf'
    | 'jxr'
    | 'jxra'
    | 'jxrs'
    | 'jxs'
    | 'jxsc'
    | 'jxsi'
    | 'jxss'
    | 'ktx'
    | 'ktx2'
    | 'png'
    | 'sgi'
    | 'svg'
    | 'svgz'
    | 't38'
    | 'tif'
    | 'tiff'
    | 'tfx'
    | 'webp'
    | 'wmf'
    | 'disposition-notification'
    | 'u8msg'
    | 'u8dsn'
    | 'u8mdn'
    | 'u8hdr'
    | 'eml'
    | 'mime'
    | '3mf'
    | 'gltf'
    | 'glb'
    | 'igs'
    | 'iges'
    | 'msh'
    | 'mesh'
    | 'silo'
    | 'mtl'
    | 'obj'
    | 'stpx'
    | 'stpz'
    | 'stpxz'
    | 'stl'
    | 'wrl'
    | 'vrml'
    | '*x3db'
    | 'x3dbz'
    | 'x3db'
    | '*x3dv'
    | 'x3dvz'
    | 'x3d'
    | 'x3dz'
    | 'x3dv'
    | 'appcache'
    | 'manifest'
    | 'ics'
    | 'ifb'
    | 'coffee'
    | 'litcoffee'
    | 'css'
    | 'csv'
    | 'html'
    | 'htm'
    | 'shtml'
    | 'jade'
    | 'jsx'
    | 'less'
    | 'markdown'
    | 'md'
    | 'mml'
    | 'mdx'
    | 'n3'
    | 'txt'
    | 'text'
    | 'conf'
    | 'def'
    | 'list'
    | 'log'
    | 'in'
    | 'ini'
    | 'rtx'
    | '*rtf'
    | 'sgml'
    | 'sgm'
    | 'shex'
    | 'slim'
    | 'slm'
    | 'spdx'
    | 'stylus'
    | 'styl'
    | 'tsv'
    | 't'
    | 'tr'
    | 'roff'
    | 'man'
    | 'me'
    | 'ms'
    | 'ttl'
    | 'uri'
    | 'uris'
    | 'urls'
    | 'vcard'
    | 'vtt'
    | '*xml'
    | 'yaml'
    | 'yml'
    | '3gp'
    | '3gpp'
    | '3g2'
    | 'h261'
    | 'h263'
    | 'h264'
    | 'm4s'
    | 'jpgv'
    | '*jpm'
    | 'jpgm'
    | 'mj2'
    | 'mjp2'
    | 'ts'
    | 'mp4'
    | 'mp4v'
    | 'mpg4'
    | 'mpeg'
    | 'mpg'
    | 'mpe'
    | 'm1v'
    | 'm2v'
    | 'ogv'
    | 'qt'
    | 'mov'
    | 'webm'
    | 'cww'
    | '1km'
    | 'plb'
    | 'psb'
    | 'pvb'
    | 'tcap'
    | 'pwn'
    | 'aso'
    | 'imp'
    | 'acu'
    | 'atc'
    | 'acutc'
    | 'air'
    | 'fcdt'
    | 'fxp'
    | 'fxpl'
    | 'xdp'
    | 'xfdf'
    | 'ahead'
    | 'azf'
    | 'azs'
    | 'azw'
    | 'acc'
    | 'ami'
    | 'apk'
    | 'cii'
    | 'fti'
    | 'atx'
    | 'mpkg'
    | 'key'
    | 'm3u8'
    | 'numbers'
    | 'pages'
    | 'pkpass'
    | 'swi'
    | 'iota'
    | 'aep'
    | 'bmml'
    | 'mpm'
    | 'bmi'
    | 'rep'
    | 'cdxml'
    | 'mmd'
    | 'cdy'
    | 'csl'
    | 'cla'
    | 'rp9'
    | 'c4g'
    | 'c4d'
    | 'c4f'
    | 'c4p'
    | 'c4u'
    | 'c11amc'
    | 'c11amz'
    | 'csp'
    | 'cdbcmsg'
    | 'cmc'
    | 'clkx'
    | 'clkk'
    | 'clkp'
    | 'clkt'
    | 'clkw'
    | 'wbs'
    | 'pml'
    | 'ppd'
    | 'car'
    | 'pcurl'
    | 'dart'
    | 'rdz'
    | 'dbf'
    | 'uvf'
    | 'uvvf'
    | 'uvd'
    | 'uvvd'
    | 'uvt'
    | 'uvvt'
    | 'uvx'
    | 'uvvx'
    | 'uvz'
    | 'uvvz'
    | 'fe_launch'
    | 'dna'
    | 'mlp'
    | 'mle'
    | 'dpg'
    | 'dfac'
    | 'kpxx'
    | 'ait'
    | 'svc'
    | 'geo'
    | 'mag'
    | 'nml'
    | 'esf'
    | 'msf'
    | 'qam'
    | 'slt'
    | 'ssf'
    | 'es3'
    | 'et3'
    | 'ez2'
    | 'ez3'
    | 'fdf'
    | 'mseed'
    | 'seed'
    | 'dataless'
    | 'gph'
    | 'ftc'
    | 'fm'
    | 'frame'
    | 'maker'
    | 'book'
    | 'fnc'
    | 'ltf'
    | 'fsc'
    | 'oas'
    | 'oa2'
    | 'oa3'
    | 'fg5'
    | 'bh2'
    | 'ddd'
    | 'xdw'
    | 'xbd'
    | 'fzs'
    | 'txd'
    | 'ggb'
    | 'ggt'
    | 'gex'
    | 'gre'
    | 'gxt'
    | 'g2w'
    | 'g3w'
    | 'gmx'
    | 'gdoc'
    | 'gslides'
    | 'gsheet'
    | 'kml'
    | 'kmz'
    | 'gqf'
    | 'gqs'
    | 'gac'
    | 'ghf'
    | 'gim'
    | 'grv'
    | 'gtm'
    | 'tpl'
    | 'vcg'
    | 'hal'
    | 'zmm'
    | 'hbci'
    | 'les'
    | 'hpgl'
    | 'hpid'
    | 'hps'
    | 'jlt'
    | 'pcl'
    | 'pclxl'
    | 'sfd-hdstx'
    | 'mpy'
    | 'afp'
    | 'listafp'
    | 'list3820'
    | 'irm'
    | 'sc'
    | 'icc'
    | 'icm'
    | 'igl'
    | 'ivp'
    | 'ivu'
    | 'igm'
    | 'xpw'
    | 'xpx'
    | 'i2g'
    | 'qbo'
    | 'qfx'
    | 'rcprofile'
    | 'irp'
    | 'xpr'
    | 'fcs'
    | 'jam'
    | 'rms'
    | 'jisp'
    | 'joda'
    | 'ktz'
    | 'ktr'
    | 'karbon'
    | 'chrt'
    | 'kfo'
    | 'flw'
    | 'kon'
    | 'kpr'
    | 'kpt'
    | 'ksp'
    | 'kwd'
    | 'kwt'
    | 'htke'
    | 'kia'
    | 'kne'
    | 'knp'
    | 'skp'
    | 'skd'
    | 'skt'
    | 'skm'
    | 'sse'
    | 'lasxml'
    | 'lbd'
    | 'lbe'
    | 'apr'
    | 'pre'
    | 'nsf'
    | 'org'
    | 'scm'
    | 'lwp'
    | 'portpkg'
    | 'mvt'
    | 'mcd'
    | 'mc1'
    | 'cdkey'
    | 'mwf'
    | 'mfm'
    | 'flo'
    | 'igx'
    | 'mif'
    | 'daf'
    | 'dis'
    | 'mbk'
    | 'mqy'
    | 'msl'
    | 'plc'
    | 'txf'
    | 'mpn'
    | 'mpc'
    | 'xul'
    | 'cil'
    | 'cab'
    | 'xls'
    | 'xlm'
    | 'xla'
    | 'xlc'
    | 'xlt'
    | 'xlw'
    | 'xlam'
    | 'xlsb'
    | 'xlsm'
    | 'xltm'
    | 'eot'
    | 'chm'
    | 'ims'
    | 'lrm'
    | 'thmx'
    | 'msg'
    | 'cat'
    | '*stl'
    | 'ppt'
    | 'pps'
    | 'pot'
    | 'ppam'
    | 'pptm'
    | 'sldm'
    | 'ppsm'
    | 'potm'
    | 'mpp'
    | 'mpt'
    | 'docm'
    | 'dotm'
    | 'wps'
    | 'wks'
    | 'wcm'
    | 'wdb'
    | 'wpl'
    | 'xps'
    | 'mseq'
    | 'mus'
    | 'msty'
    | 'taglet'
    | 'nlu'
    | 'ntf'
    | 'nitf'
    | 'nnd'
    | 'nns'
    | 'nnw'
    | '*ac'
    | 'ngdat'
    | 'n-gage'
    | 'rpst'
    | 'rpss'
    | 'edm'
    | 'edx'
    | 'ext'
    | 'odc'
    | 'otc'
    | 'odb'
    | 'odf'
    | 'odft'
    | 'odg'
    | 'otg'
    | 'odi'
    | 'oti'
    | 'odp'
    | 'otp'
    | 'ods'
    | 'ots'
    | 'odt'
    | 'odm'
    | 'ott'
    | 'oth'
    | 'xo'
    | 'dd2'
    | 'obgx'
    | 'oxt'
    | 'osm'
    | 'pptx'
    | 'sldx'
    | 'ppsx'
    | 'potx'
    | 'xlsx'
    | 'xltx'
    | 'docx'
    | 'dotx'
    | 'mgp'
    | 'dp'
    | 'esa'
    | 'pdb'
    | 'pqa'
    | 'oprc'
    | 'paw'
    | 'str'
    | 'ei6'
    | 'efif'
    | 'wg'
    | 'plf'
    | 'pbd'
    | 'box'
    | 'mgz'
    | 'qps'
    | 'ptid'
    | 'qxd'
    | 'qxt'
    | 'qwd'
    | 'qwt'
    | 'qxl'
    | 'qxb'
    | 'rar'
    | 'bed'
    | 'mxl'
    | 'musicxml'
    | 'cryptonote'
    | 'cod'
    | 'rm'
    | 'rmvb'
    | 'link66'
    | 'st'
    | 'see'
    | 'sema'
    | 'semd'
    | 'semf'
    | 'ifm'
    | 'itp'
    | 'iif'
    | 'ipk'
    | 'twd'
    | 'twds'
    | 'mmf'
    | 'teacher'
    | 'fo'
    | 'sdkm'
    | 'sdkd'
    | 'dxp'
    | 'sfs'
    | 'sdc'
    | 'sda'
    | 'sdd'
    | 'smf'
    | 'sdw'
    | 'vor'
    | 'sgl'
    | 'smzip'
    | 'sm'
    | 'wadl'
    | 'sxc'
    | 'stc'
    | 'sxd'
    | 'std'
    | 'sxi'
    | 'sti'
    | 'sxm'
    | 'sxw'
    | 'sxg'
    | 'stw'
    | 'sus'
    | 'susp'
    | 'svd'
    | 'sis'
    | 'sisx'
    | 'xsm'
    | 'bdm'
    | 'xdm'
    | 'ddf'
    | 'tao'
    | 'pcap'
    | 'cap'
    | 'dmp'
    | 'tmo'
    | 'tpt'
    | 'mxs'
    | 'tra'
    | 'ufd'
    | 'ufdl'
    | 'utz'
    | 'umj'
    | 'unityweb'
    | 'uoml'
    | 'vcx'
    | 'vsd'
    | 'vst'
    | 'vss'
    | 'vsw'
    | 'vis'
    | 'vsf'
    | 'wbxml'
    | 'wmlc'
    | 'wmlsc'
    | 'wtb'
    | 'nbp'
    | 'wpd'
    | 'wqd'
    | 'stf'
    | 'xar'
    | 'xfdl'
    | 'hvd'
    | 'hvs'
    | 'hvp'
    | 'osf'
    | 'osfpvg'
    | 'saf'
    | 'spf'
    | 'cmp'
    | 'zir'
    | 'zirz'
    | 'zaz'
    | '7z'
    | 'abw'
    | 'ace'
    | '*dmg'
    | 'arj'
    | 'aab'
    | 'x32'
    | 'u32'
    | 'vox'
    | 'aam'
    | 'aas'
    | 'bcpio'
    | '*bdoc'
    | 'torrent'
    | 'blb'
    | 'blorb'
    | 'bz'
    | 'bz2'
    | 'boz'
    | 'cbr'
    | 'cba'
    | 'cbt'
    | 'cbz'
    | 'cb7'
    | 'vcd'
    | 'cfs'
    | 'chat'
    | 'pgn'
    | 'crx'
    | 'cco'
    | 'nsc'
    | 'cpio'
    | 'csh'
    | '*deb'
    | 'udeb'
    | 'dgc'
    | 'dir'
    | 'dcr'
    | 'dxr'
    | 'cst'
    | 'cct'
    | 'cxt'
    | 'w3d'
    | 'fgd'
    | 'swa'
    | 'wad'
    | 'ncx'
    | 'dtb'
    | 'res'
    | 'dvi'
    | 'evy'
    | 'eva'
    | 'bdf'
    | 'gsf'
    | 'psf'
    | 'pcf'
    | 'snf'
    | 'pfa'
    | 'pfb'
    | 'pfm'
    | 'afm'
    | 'arc'
    | 'spl'
    | 'gca'
    | 'ulx'
    | 'gnumeric'
    | 'gramps'
    | 'gtar'
    | 'hdf'
    | 'php'
    | 'install'
    | '*iso'
    | '*key'
    | '*numbers'
    | '*pages'
    | 'jardiff'
    | 'jnlp'
    | 'kdbx'
    | 'latex'
    | 'luac'
    | 'lzh'
    | 'lha'
    | 'run'
    | 'mie'
    | 'prc'
    | 'mobi'
    | 'application'
    | 'lnk'
    | 'wmd'
    | 'wmz'
    | 'xbap'
    | 'mdb'
    | 'obd'
    | 'crd'
    | 'clp'
    | '*exe'
    | '*dll'
    | 'com'
    | 'bat'
    | '*msi'
    | 'mvb'
    | 'm13'
    | 'm14'
    | '*wmf'
    | '*wmz'
    | '*emf'
    | 'emz'
    | 'mny'
    | 'pub'
    | 'scd'
    | 'trm'
    | 'wri'
    | 'nc'
    | 'cdf'
    | 'pac'
    | 'nzb'
    | 'pl'
    | 'pm'
    | '*prc'
    | '*pdb'
    | 'p12'
    | 'pfx'
    | 'p7b'
    | 'spc'
    | 'p7r'
    | '*rar'
    | 'rpm'
    | 'ris'
    | 'sea'
    | 'sh'
    | 'shar'
    | 'swf'
    | 'xap'
    | 'sql'
    | 'sit'
    | 'sitx'
    | 'srt'
    | 'sv4cpio'
    | 'sv4crc'
    | 't3'
    | 'gam'
    | 'tar'
    | 'tcl'
    | 'tk'
    | 'tex'
    | 'tfm'
    | 'texinfo'
    | 'texi'
    | '*obj'
    | 'ustar'
    | 'hdd'
    | 'ova'
    | 'ovf'
    | 'vbox'
    | 'vbox-extpack'
    | 'vdi'
    | 'vhd'
    | 'vmdk'
    | 'src'
    | 'webapp'
    | 'der'
    | 'crt'
    | 'pem'
    | 'fig'
    | '*xlf'
    | 'xpi'
    | 'xz'
    | 'z1'
    | 'z2'
    | 'z3'
    | 'z4'
    | 'z5'
    | 'z6'
    | 'z7'
    | 'z8'
    | 'uva'
    | 'uvva'
    | 'eol'
    | 'dra'
    | 'dts'
    | 'dtshd'
    | 'lvp'
    | 'pya'
    | 'ecelp4800'
    | 'ecelp7470'
    | 'ecelp9600'
    | 'rip'
    | 'aac'
    | 'aif'
    | 'aiff'
    | 'aifc'
    | 'caf'
    | 'flac'
    | '*m4a'
    | 'mka'
    | 'm3u'
    | 'wax'
    | 'wma'
    | 'ram'
    | 'ra'
    | 'rmp'
    | '*ra'
    | 'cdx'
    | 'cif'
    | 'cmdf'
    | 'cml'
    | 'csml'
    | 'xyz'
    | 'btif'
    | 'pti'
    | 'psd'
    | 'azv'
    | 'uvi'
    | 'uvvi'
    | 'uvg'
    | 'uvvg'
    | 'djvu'
    | 'djv'
    | '*sub'
    | 'dwg'
    | 'dxf'
    | 'fbs'
    | 'fpx'
    | 'fst'
    | 'mmr'
    | 'rlc'
    | 'ico'
    | 'dds'
    | 'mdi'
    | 'wdp'
    | 'npx'
    | 'b16'
    | 'tap'
    | 'vtf'
    | 'wbmp'
    | 'xif'
    | 'pcx'
    | '3ds'
    | 'ras'
    | 'cmx'
    | 'fh'
    | 'fhc'
    | 'fh4'
    | 'fh5'
    | 'fh7'
    | '*ico'
    | 'jng'
    | 'sid'
    | '*bmp'
    | '*pcx'
    | 'pic'
    | 'pct'
    | 'pnm'
    | 'pbm'
    | 'pgm'
    | 'ppm'
    | 'rgb'
    | 'tga'
    | 'xbm'
    | 'xpm'
    | 'xwd'
    | 'wsc'
    | 'dae'
    | 'dwf'
    | 'gdl'
    | 'gtw'
    | 'mts'
    | 'ogex'
    | 'x_b'
    | 'x_t'
    | 'vds'
    | 'usdz'
    | 'bsp'
    | 'vtu'
    | 'dsc'
    | 'curl'
    | 'dcurl'
    | 'mcurl'
    | 'scurl'
    | 'sub'
    | 'fly'
    | 'flx'
    | 'gv'
    | '3dml'
    | 'spot'
    | 'jad'
    | 'wml'
    | 'wmls'
    | 's'
    | 'asm'
    | 'c'
    | 'cc'
    | 'cxx'
    | 'cpp'
    | 'h'
    | 'hh'
    | 'dic'
    | 'htc'
    | 'f'
    | 'for'
    | 'f77'
    | 'f90'
    | 'hbs'
    | 'java'
    | 'lua'
    | 'mkd'
    | 'nfo'
    | 'opml'
    | '*org'
    | 'p'
    | 'pas'
    | 'pde'
    | 'sass'
    | 'scss'
    | 'etx'
    | 'sfv'
    | 'ymp'
    | 'uu'
    | 'vcs'
    | 'vcf'
    | 'uvh'
    | 'uvvh'
    | 'uvm'
    | 'uvvm'
    | 'uvp'
    | 'uvvp'
    | 'uvs'
    | 'uvvs'
    | 'uvv'
    | 'uvvv'
    | 'dvb'
    | 'fvt'
    | 'mxu'
    | 'm4u'
    | 'pyv'
    | 'uvu'
    | 'uvvu'
    | 'viv'
    | 'f4v'
    | 'fli'
    | 'flv'
    | 'm4v'
    | 'mkv'
    | 'mk3d'
    | 'mks'
    | 'mng'
    | 'asf'
    | 'asx'
    | 'vob'
    | 'wm'
    | 'wmv'
    | 'wmx'
    | 'wvx'
    | 'avi'
    | 'movie'
    | 'smv'
    | 'ice'
    | 'mht'
    | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface ForbiddenResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface InternalServerErrorResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface Interview {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  application_id?: string | null;
  /** Provider's unique identifier of the application */
  remote_application_id?: string | null;
  interview_stage_id?: string | null;
  /** Provider's unique identifier of the interview stage */
  remote_interview_stage_id?: string | null;
  interview_stage?: InterviewStage | null;
  interview_status?: InterviewStatusEnum | null;
  interviewer_ids?: string[] | null;
  /** Provider's unique identifiers of the interviewers */
  remote_interviewer_ids?: string[] | null;
  interview_parts?: InterviewPart[] | null;
  interviewers?: Interviewer[] | null;
  /** Interview start date */
  start_at?: string | null;
  /** Interview end date */
  end_at?: string | null;
  meeting_url?: string | null;
  /** Interview created date */
  created_at?: string | null;
  /** Interview updated date */
  updated_at?: string | null;
}

export interface Interviewer {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  first_name?: string | null;
  last_name?: string | null;
  name?: string | null;
  email?: string | null;
}

export interface InterviewPart {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  type?: InterviewTypeEnum | null;
  /** The title of interview, usually corresponding to the title of an associated calendar event */
  title?: string | null;
  /** The user (interviewer) IDs taking part in this specific interview. */
  interviewer_ids?: string[] | null;
  /** Provider's user (interviewer) IDs taking part in this specific interview. */
  remote_interviewer_ids?: string[] | null;
  /** The meeting URL for the interview - this may be populated using the underlying location if the location string extracted is a valid url. */
  meeting_url?: string | null;
  /** The video meeting provider used for the interview. */
  meeting_provider?: string | null;
  /** The specific interview part's start date */
  start_at?: string | null;
  /** The specific interview part's end date */
  end_at?: string | null;
  /** Interview part created date */
  created_at?: string | null;
  /** Interview part updated date */
  updated_at?: string | null;
}

export interface InterviewsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: Interview[];
  raw?: RawResponse[] | null;
}

export interface InterviewsResult {
  data: Interview;
  raw?: RawResponse[] | null;
}

export interface InterviewStage {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  name?: string | null;
  order?: number | null;
  /** Interview Stage created date */
  created_at?: string | null;
  /** Interview Stage updated date */
  updated_at?: string | null;
}

export interface InterviewStageResult {
  data: InterviewStage;
  raw?: RawResponse[] | null;
}

export interface InterviewStagesPaginated {
  next_page?: string | null;
  next?: string | null;
  data: InterviewStage[];
  raw?: RawResponse[] | null;
}

export interface InterviewStatusEnum {
  /** The status of the interview. */
  value?:
    | 'unscheduled'
    | 'scheduled'
    | 'completed'
    | 'cancelled'
    | 'pending_feedback'
    | 'unmapped_value'
    | null;
  /** The source value of the interview status. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface InterviewTypeEnum {
  /** The type of the interview. */
  value?:
    | 'screening'
    | 'lunch'
    | 'on_site'
    | 'presentation'
    | 'sell'
    | 'culture'
    | 'informal'
    | 'test'
    | 'phone'
    | 'video'
    | 'unmapped_value'
    | null;
  /** The source value of the interview type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface JobPosting {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  title?: string | null;
  locations?: JobPostingLocation[] | null;
  internal?: 'true' | 'false' | 'unmapped_value' | null;
  status?: JobPostingStatusEnum | null;
  job_id?: string | null;
  /** Provider's unique identifier of the job posting */
  remote_job_posting_id?: string | null;
  content?: JobPostingContent | null;
  compensation?: JobPostingCompensation[] | null;
  employment_type?: EmploymentTypeEnum | null;
  employment_contract_type?: EmploymentContractTypeEnum | null;
  external_url?: string | null;
  external_apply_url?: string | null;
  questionnaires?: JobPostingQuestionnaire[] | null;
  /** The posting start date */
  start_date?: string | null;
  /** Date of creation */
  created_at?: string | null;
  /** Date of last update */
  updated_at?: string | null;
}

export interface JobPostingCompensation {
  title?: string | null;
  type?: CompensationTypeEnum | null;
  pay_period?: PayPeriodEnum | null;
  pay_frequency?: PayFrequencyEnum | null;
  currency?: string | null;
  value?: string | null;
  min_value_range?: string | null;
  max_value_range?: string | null;
}

export interface JobPostingContent {
  plain?: string | null;
  html?: string | null;
  sections?: JobPostingContentSection[] | null;
}

export interface JobPostingContentSection {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  type?: AssessmentTypeEnum | null;
  label?: string | null;
  content?: string | null;
}

export interface JobPostingLocation {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  name?: string | null;
}

export interface JobPostingQuestionnaire {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  name?: string | null;
  internal?: (boolean | 'true' | 'false') | null;
  questions?: Question[] | null;
}

export interface JobPostingResult {
  data: JobPosting;
  raw?: RawResponse[] | null;
}

export interface JobPostingsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: JobPosting[];
  raw?: RawResponse[] | null;
}

export interface JobPostingStatusEnum {
  /** The status of the job postings. */
  value?:
    | 'live'
    | 'draft'
    | 'pending'
    | 'internal'
    | 'rejected'
    | 'closed'
    | 'archived'
    | 'unmapped_value'
    | null;
  /** The source value of the job postings status. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface List {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  name?: string | null;
  items?: ListItem[] | null;
  /** Timestamp when the list was created */
  created_at?: string | null;
  /** Timestamp when the list was last updated */
  updated_at?: string | null;
  /** The list type */
  type?: ListTypeEnum | null;
}

export interface ListItem {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
}

export interface ListResult {
  data: List;
  raw?: RawResponse[] | null;
}

export interface ListsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: List[];
  raw?: RawResponse[] | null;
}

export interface ListTypeEnum {
  /** The type of the list. */
  value?: 'candidates' | 'contacts' | 'companies' | 'unmapped_value' | null;
  /** The source value of the list type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface MoveApplicationResult {
  statusCode: number;
  message: string;
  timestamp: string;
  data: CreateResultDataApiModel;
}

export interface Note {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  content?: NoteContentApiModel[] | null;
  /** Unique identifier of the author */
  author_id?: string | null;
  /** Provider's unique identifier of the author */
  remote_author_id?: string | null;
  /** Visibility of the note */
  visibility?: NotesVisibilityEnum | null;
  /** Date of creation */
  created_at?: string | null;
  /** Date of last update */
  updated_at?: string | null;
  /** Date of Deletion */
  deleted_at?: string | null;
}

export interface NoteContentApiModel {
  /** Body of the note */
  body?: string | null;
}

export interface NoteResult {
  data: Note;
  raw?: RawResponse[] | null;
}

export interface NotesPaginated {
  next_page?: string | null;
  next?: string | null;
  data: Note[];
  raw?: RawResponse[] | null;
}

export interface NotesVisibilityEnum {
  /** The visibility of the notes. */
  value?: 'private' | 'public' | 'unmapped_value' | null;
  /** The source value of the notes visibility. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface NotFoundResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface NotImplementedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface Offer {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  application_id?: string | null;
  /** Provider's unique identifier of the application */
  remote_application_id?: string | null;
  /** Date of creation */
  start_date?: string | null;
  offer_status?: OfferStatusEnum | null;
  salary?: number | null;
  currency?: string | null;
  /** Date of creation */
  created_at?: string | null;
  /** Date of last update */
  updated_at?: string | null;
  offer_history?: OfferHistory[] | null;
}

export interface OfferHistory {
  /** Start Date of the offer */
  start_date?: string | null;
  salary?: number | null;
  currency?: string | null;
  /** Date of creation */
  created_at?: string | null;
  /** Date of last update */
  updated_at?: string | null;
}

export interface OffersPaginated {
  next_page?: string | null;
  next?: string | null;
  data: Offer[];
  raw?: RawResponse[] | null;
}

export interface OffersResult {
  data: Offer;
  raw?: RawResponse[] | null;
}

export interface OfferStatusEnum {
  /** The status of the offer. */
  value?:
    | 'pending'
    | 'retracted'
    | 'accepted'
    | 'rejected'
    | 'created'
    | 'approved'
    | 'not_approved'
    | 'unmapped_value'
    | null;
  /** The source value of the offer status. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface OrderApplicationApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  application_status?: ApplicationStatusEnum | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface OrderBackgroundCheckPackageApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Package name */
  name?: string | null;
  /** Package description */
  description?: string | null;
  /** Package tests */
  tests?: Package[] | null;
}

export interface OrderCandidateApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Candidate first name */
  first_name?: string | null;
  /** Candidate last name */
  last_name?: string | null;
  /** List of candidate emails */
  emails?: CandidateEmail[] | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
  /** Candidate profile url */
  profile_url?: string | null;
}

export interface OrderJobApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Title of the job */
  title?: string | null;
  /** Hiring team for the job. */
  hiring_team?: AtsJobHiringTeam[] | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface OrderJobHiringTeamApiModel {
  /** User ID of the hiring team member. */
  user_id?: string | null;
  /** Provider's unique identifier of the user */
  remote_user_id?: string | null;
  /** First name of the hiring team member. */
  first_name?: string | null;
  /** Last name of the hiring team member. */
  last_name?: string | null;
  /** Email of the hiring team member. */
  email?: string | null;
  /** Role of the hiring team member. */
  role?: string | null;
}

export interface OrderPackageApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Package name */
  name?: string | null;
  /** Package description */
  description?: string | null;
}

export interface Package {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Package name */
  name?: string | null;
  /** Package description */
  description?: string | null;
}

export interface ParentQuestion {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** List of parent questions's option IDs */
  option_ids?: string[] | null;
  /** Provider's list of parent questions's option IDs */
  remote_option_ids?: string[] | null;
  condition_type?: ConditionTypeEnum | null;
}

export interface PayFrequencyEnum {
  /** The pay frequency of the job postings. */
  value?:
    | 'hourly'
    | 'weekly'
    | 'bi_weekly'
    | 'four_weekly'
    | 'semi_monthly'
    | 'monthly'
    | 'bi_monthly'
    | 'quarterly'
    | 'semi_annually'
    | 'yearly'
    | 'thirteen_monthly'
    | 'pro_rata'
    | 'unmapped_value'
    | 'half_yearly'
    | 'daily'
    | null;
  /** The source value of the pay frequency. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface PayPeriodEnum {
  /** The pay period of the job postings. */
  value?:
    | 'hour'
    | 'day'
    | 'week'
    | 'every_two_weeks'
    | 'month'
    | 'twice_a_month'
    | 'every_two_months'
    | 'quarter'
    | 'every_six_months'
    | 'year'
    | 'one_off'
    | 'none'
    | 'unmapped_value'
    | null;
  /** The source value of the pay period. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface PhoneNumber {
  /** Type of phone number */
  type?: 'personal' | 'work' | 'mobile' | 'home' | 'unknown' | 'other' | 'unmapped_value' | null;
  /** Phone number string */
  phone?: string | null;
}

export interface PreconditionFailedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface ProviderError {
  /** HTTP status code of the provider error */
  status?: number | null;
  /** URL that caused the error */
  url?: string | null;
  /** Raw error response from the provider */
  raw?: Record<string, unknown> | null;
  /** Response headers */
  headers?: Record<string, unknown> | null;
}

export interface ProviderErrorApiModel {
  status?: number | null;
  url?: string | null;
  raw?: Record<string, unknown> | null;
  headers?: Record<string, unknown> | null;
}

export interface Question {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  name?: string | null;
  type?: QuestionsTypeEnum | null;
  text?: string | null;
  required?: (boolean | 'true' | 'false') | null;
  multiple_choice_answers?: QuestionMultipleChoiceAnswers[] | null;
  parent_question?: ParentQuestion | null;
}

export interface QuestionMultipleChoiceAnswers {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  text?: string | null;
}

export interface Questionnaire {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  answers?: Answer[] | null;
}

export interface QuestionsTypeEnum {
  /** The type of the questions. */
  value?:
    | 'short_text'
    | 'long_text'
    | 'attachment'
    | 'multi_select'
    | 'single_select'
    | 'boolean'
    | 'number'
    | 'date'
    | 'video'
    | 'reference_check'
    | 'url'
    | 'unmapped_value'
    | null;
  /** The source value of the questions type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface RawResponse {
  method: string;
  url: string;
  body?: (string | Record<string, unknown> | number[]) | null;
  response?: (Record<string, unknown> | unknown[] | string) | null;
}

export interface Reference {
  /** The reference id */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The reference name */
  name?: string | null;
  /** The reference status */
  active?: (boolean | 'true' | 'false') | null;
}

export interface ReferencePaginated {
  next_page?: string | null;
  next?: string | null;
  data: Reference[];
  raw?: RawResponse[] | null;
}

export interface ReferenceResult {
  data: Reference;
  raw?: RawResponse[] | null;
}

export interface RejectApplicationResult {
  statusCode: number;
  message: string;
  timestamp: string;
  data: CreateResultDataApiModel;
}

export interface RejectedReason {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The label of the rejected reason. */
  label?: string | null;
  /** The string type of the rejected reason. */
  type?: string | null;
  rejected_reason_type?: RejectedReasonTypeEnum | null;
}

export interface RejectedReasonResult {
  data: RejectedReason;
  raw?: RawResponse[] | null;
}

export interface RejectedReasonsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: RejectedReason[];
  raw?: RawResponse[] | null;
}

export interface RejectedReasonTypeEnum {
  /** The type of the rejected reason. */
  value?:
    | 'rejected_by_candidate'
    | 'rejected_by_organization'
    | 'other'
    | 'unknown'
    | 'unmapped_value'
    | null;
  /** The source value of the rejected reason type. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface RequestTimedOutResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface ResultEnum {
  /** The result of the test. */
  value?:
    | 'initiated'
    | 'in_progress'
    | 'cancelled'
    | 'completed'
    | 'expired'
    | 'failed'
    | 'passed'
    | 'unmapped_value'
    | null;
  /** The source value of the test result. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface ResultLink {
  /** The label of the result link. */
  label?: string | null;
  /** The URL of the result link. */
  url?: string | null;
}

export interface ScheduledInterview {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  application_id?: string | null;
  /** Provider's unique identifier of the application */
  remote_application_id?: string | null;
  interview_stage_id?: string | null;
  /** Provider's unique identifier of the interview stage */
  remote_interview_stage_id?: string | null;
  interview_stage?: InterviewStage | null;
  interview_status?: InterviewStatusEnum | null;
  interviewer_ids?: string[] | null;
  /** Provider's unique identifiers of the interviewers */
  remote_interviewer_ids?: string[] | null;
  interview_parts?: InterviewPart[] | null;
  interviewers?: Interviewer[] | null;
  /** Interview start date */
  start_at?: string | null;
  /** Interview end date */
  end_at?: string | null;
  meeting_url?: string | null;
  /** Interview created date */
  created_at?: string | null;
  /** Interview updated date */
  updated_at?: string | null;
}

export interface ScheduledInterviewsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: ScheduledInterview[];
  raw?: RawResponse[] | null;
}

export interface ScheduledInterviewsResult {
  data: ScheduledInterview;
  raw?: RawResponse[] | null;
}

export interface ScoreApiModel {
  /** The label of the score */
  label?: string | null;
  /** The value is the actual score */
  value?: string | null;
  /** The minimum value of the score */
  min?: string | null;
  /** The maximum value of the score */
  max?: string | null;
}

export interface Scorecard {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The sections in the scorecard */
  sections?: ScorecardSection[] | null;
  /** The label of the scorecard */
  label?: string | null;
  /** The candidate ID associated with the scorecard */
  candidate_id?: string | null;
  /** Provider's unique identifier of the candidate */
  remote_candidate_id?: string | null;
  /** The application ID associated with the scorecard */
  application_id?: string | null;
  /** Provider's unique identifier of the application */
  remote_application_id?: string | null;
  /** The interview ID associated with the scorecard */
  interview_id?: string | null;
  /** Provider's unique identifier of the interview */
  remote_interview_id?: string | null;
  /** The author ID of the scorecard */
  author_id?: string | null;
  /** Provider's unique identifier of the author */
  remote_author_id?: string | null;
  /** The overall recommendation */
  overall_recommendation?:
    | 'strong_yes'
    | 'yes'
    | 'no'
    | 'strong_no'
    | 'no_decision'
    | 'unmapped_value'
    | null;
  /** The creation date of the scorecard */
  created_at?: string | null;
  /** The update date of the scorecard */
  updated_at?: string | null;
}

export interface ScorecardSection {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The label of the section */
  label?: string | null;
  /** The fields within the section */
  fields?: Field[] | null;
}

export interface ScorecardsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: Scorecard[];
  raw?: RawResponse[] | null;
}

export interface ScorecardsResult {
  data: Scorecard;
  raw?: RawResponse[] | null;
}

export interface SocialLink {
  /** Type of the social link */
  type?: string | null;
  /** URL of the social link */
  url?: string | null;
}

export interface Source {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The source of the application */
  name?: string | null;
}

export interface Tag {
  /** Remote ID of the tag */
  remote_id?: string | null;
  /** Name of the tag */
  name?: string | null;
}

export interface TooManyRequestsResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UnauthorizedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UnifiedError {
  /** HTTP status code */
  statusCode?: number | null;
  /** Error message */
  message?: string | null;
  /** Response headers */
  headers?: Record<string, unknown> | null;
}

export interface UnifiedWarningApiModel {
  message?: string | null;
}

export interface UnprocessableEntityResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UpdatePackage {
  /** Unique identifier */
  id?: string | null;
  /** Package name */
  name?: string | null;
  /** Package description */
  description?: string | null;
}

export interface UpdateResult {
  statusCode: number;
  message: string;
  timestamp: string;
}

export interface UpdateResultCandidateApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Candidate profile url */
  profile_url?: string | null;
}

export interface User {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  email?: string | null;
  first_name?: string | null;
  last_name?: string | null;
  name?: string | null;
  phone?: string | null;
}

export interface UserResult {
  data: User;
  raw?: RawResponse[] | null;
}

export interface UsersPaginated {
  next_page?: string | null;
  next?: string | null;
  data: User[];
  raw?: RawResponse[] | null;
}

export interface WriteResultApiModel {
  statusCode?: number | null;
  message?: string | null;
  timestamp?: string | null;
  provider_errors?: ProviderErrorApiModel[] | null;
  unified_warnings?: UnifiedWarningApiModel[] | null;
}

// ============================================================
// Client Class
// ============================================================

export interface AtsListApplicationsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** ATS Application Filter */
  filter?: {
    updated_after?: string | null;
    created_after?: string | null;
    job_id?: string | null;
    stage?: string | null;
    application_stage_id?: string | null;
  } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
  /** The comma separated list of fields that will be included in the response */
  include?: string | null;
}

export interface AtsCreateApplicationParams {
  body: AtsCreateApplicationRequestDto;
}

export interface AtsGetApplicationParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
  /** The comma separated list of fields that will be included in the response */
  include?: string | null;
}

export interface AtsUpdateApplicationParams {
  id: string;
  body: AtsUpdateApplicationRequestDto;
}

export interface AtsListApplicationsOffersParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsMoveApplicationParams {
  id: string;
  body: AtsMoveApplicationRequestDto;
}

export interface AtsRejectApplicationParams {
  id: string;
  body: AtsRejectApplicationRequestDto;
}

export interface AtsGetApplicationOfferParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListApplicationScorecardsParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetApplicationScorecardParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListApplicationChangesParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** Filter parameters for application changes (supports created_after and change_type) */
  filter?: {
    created_after?: string | null;
    change_type?:
      | 'application_status'
      | 'interview_stage'
      | 'rejected_reasons'
      | 'unmapped_value'
      | null;
  } | null;
}

export interface AtsListApplicationNotesParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsCreateApplicationNoteParams {
  id: string;
  body: AtsCreateNotesRequestDto;
}

export interface AtsGetApplicationNoteParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsUpdateApplicationNoteParams {
  id: string;
  subresourceid: string;
  body: AtsUpdateNotesRequestDto;
}

export interface AtsListApplicationsScheduledInterviewsParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetApplicationScheduledInterviewParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsUploadApplicationDocumentParams {
  id: string;
  body: AtsDocumentsUploadRequestDto;
}

export interface AtsDownloadApplicationDocumentParams {
  id: string;
  subresourceid: string;
  /** The format to download the file in */
  format?: string | null;
  /** The export format of the file */
  exportFormat?: string | null;
}

export interface AtsListApplicationDocumentsParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** ATS Document Filter */
  filter?: { updated_after?: string | null; type?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetApplicationDocumentParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListCandidatesParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** ATS Candidate Filter */
  filter?: {
    updated_after?: string | null;
    created_after?: string | null;
    email?: string | null;
  } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** The comma separated list of fields that will be included in the response */
  include?: string | null;
}

export interface AtsCreateCandidateParams {
  body: AtsCreateCandidateRequestDto;
}

export interface AtsGetCandidateParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** The comma separated list of fields that will be included in the response */
  include?: string | null;
}

export interface AtsUpdateCandidateParams {
  id: string;
  body: AtsUpdateCandidateRequestDto;
}

export interface AtsListCandidateNotesParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsCreateCandidateNoteParams {
  id: string;
  body: AtsCreateNotesRequestDto;
}

export interface AtsGetCandidateNoteParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListApplicationCustomFieldDefinitionsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetApplicationCustomFieldDefinitionParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsListCandidateCustomFieldDefinitionsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetCandidateCustomFieldDefinitionParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsListJobCustomFieldDefinitionsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetJobCustomFieldDefinitionParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsListDepartmentsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetDepartmentParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListApplicationStagesParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetApplicationStageParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListInterviewsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** ATS Interviews Filter */
  filter?: { updated_after?: string | null; created_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetInterviewParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListJobsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** ATS Jobs filters */
  filter?: {
    updated_after?: string | null;
    created_after?: string | null;
    status?: 'open' | 'draft' | null;
    job_status?: 'open' | 'draft' | null;
  } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
  /** The comma separated list of fields that will be included in the response */
  include?: string | null;
}

export interface AtsCreateJobParams {
  body: AtsCreateJobRequestDto;
}

export interface AtsListJobApplicationStagesParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetJobParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
  /** The comma separated list of fields that will be included in the response */
  include?: string | null;
}

export interface AtsUpdateJobParams {
  id: string;
  body: AtsUpdateJobRequestDto;
}

export interface AtsGetJobApplicationStageParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListListsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetListParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListLocationsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetLocationParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListRejectedReasonsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetRejectedReasonParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListUsersParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetUserParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListJobPostingsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** ATS Job Postings Filter */
  filter?: { updated_after?: string | null; created_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** The comma separated list of fields that will be included in the response */
  include?: string | null;
}

export interface AtsGetJobPostingParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** The comma separated list of fields that will be included in the response */
  include?: string | null;
}

export interface AtsListOffersParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsCreateOfferParams {
  body: AtsCreateOfferRequestDto;
}

export interface AtsGetOfferParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsListAssessmentsPackagesParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields to return in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetAssessmentsPackageParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields to return in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsOrderAssessmentsRequestParams {
  body: AtsCreateCandidatesAssessmentsRequestDto;
}

export interface AtsUpdateAssessmentsResultParams {
  id: string;
  body: AtsUpdateCandidatesAssessmentsResultsRequestDto;
}

export interface AtsListBackgroundCheckPackagesParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsCreateBackgroundCheckPackageParams {
  body: AtsCreateBackgroundCheckPackagesRequestDto;
}

export interface AtsGetBackgroundCheckPackageParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface AtsDeleteBackgroundCheckPackageParams {
  id: string;
}

export interface AtsUpdateBackgroundCheckPackageParams {
  id: string;
  body: AtsUpdateBackgroundCheckPackagesRequestDto;
}

export interface AtsOrderBackgroundCheckRequestParams {
  body: AtsCreateBackgroundCheckOrderRequestDto;
}

export interface AtsUpdateBackgroundCheckResultParams {
  id: string;
  body: AtsUpdateBackgroundCheckResultRequestDto;
}

export interface AtsListApplicationDocumentCategoriesParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface AtsGetApplicationDocumentCategoryParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

/**
 * Ats API Client
 * Auto-generated from OpenAPI specification
 */
export class AtsClient {
  private baseUrl: string;
  private headers: Record<string, string>;

  constructor(config: StackOneClientConfig) {
    this.baseUrl = config.baseUrl || 'https://api.stackone.com';
    const authToken = Buffer.from(`${config.apiKey}:`).toString('base64');
    this.headers = {
      Authorization: `Basic ${authToken}`,
      'x-account-id': config.accountId,
      ...config.headers,
    };
  }

  /**
   * List Applications
   */
  async listApplications(params?: AtsListApplicationsParams): Promise<ApplicationsPaginated> {
    let url = `${this.baseUrl}/unified/ats/applications`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (params?.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params?.expand))}`);
    }
    if (params?.include !== undefined) {
      queryParts.push(`include=${encodeURIComponent(String(params?.include))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ApplicationsPaginated>;
  }

  /**
   * Create Application
   */
  async createApplication(params: AtsCreateApplicationParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/ats/applications`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get Application
   */
  async getApplication(params: AtsGetApplicationParams): Promise<ApplicationResult> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params.expand))}`);
    }
    if (params.include !== undefined) {
      queryParts.push(`include=${encodeURIComponent(String(params.include))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ApplicationResult>;
  }

  /**
   * Update Application
   */
  async updateApplication(params: AtsUpdateApplicationParams): Promise<UpdateResult> {
    const url = `${this.baseUrl}/unified/ats/applications/${params.id}`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PATCH',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UpdateResult>;
  }

  /**
   * List Application Offers
   */
  async listApplicationsOffers(params: AtsListApplicationsOffersParams): Promise<OffersPaginated> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/offers`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<OffersPaginated>;
  }

  /**
   * Move Application
   */
  async moveApplication(params: AtsMoveApplicationParams): Promise<MoveApplicationResult> {
    const url = `${this.baseUrl}/unified/ats/applications/${params.id}/move`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<MoveApplicationResult>;
  }

  /**
   * Reject Application
   */
  async rejectApplication(params: AtsRejectApplicationParams): Promise<RejectApplicationResult> {
    const url = `${this.baseUrl}/unified/ats/applications/${params.id}/reject`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<RejectApplicationResult>;
  }

  /**
   * Get Application Offer
   */
  async getApplicationOffer(params: AtsGetApplicationOfferParams): Promise<OffersResult> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/offers/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<OffersResult>;
  }

  /**
   * List Application Scorecards
   */
  async listApplicationScorecards(
    params: AtsListApplicationScorecardsParams
  ): Promise<ScorecardsPaginated> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/scorecards`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ScorecardsPaginated>;
  }

  /**
   * Get Application Scorecard
   */
  async getApplicationScorecard(
    params: AtsGetApplicationScorecardParams
  ): Promise<ScorecardsResult> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/scorecards/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ScorecardsResult>;
  }

  /**
   * List Application Changes
   */
  async listApplicationChanges(
    params: AtsListApplicationChangesParams
  ): Promise<ApplicationChangesPaginated> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/changes`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ApplicationChangesPaginated>;
  }

  /**
   * List Application Notes
   */
  async listApplicationNotes(params: AtsListApplicationNotesParams): Promise<NotesPaginated> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/notes`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<NotesPaginated>;
  }

  /**
   * Create Application Note
   */
  async createApplicationNote(params: AtsCreateApplicationNoteParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/ats/applications/${params.id}/notes`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get Application Note
   */
  async getApplicationNote(params: AtsGetApplicationNoteParams): Promise<NoteResult> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/notes/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<NoteResult>;
  }

  /**
   * Update Application Note
   */
  async updateApplicationNote(params: AtsUpdateApplicationNoteParams): Promise<UpdateResult> {
    const url = `${this.baseUrl}/unified/ats/applications/${params.id}/notes/${params.subresourceid}`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PATCH',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UpdateResult>;
  }

  /**
   * List Applications scheduled interviews
   */
  async listApplicationsScheduledInterviews(
    params: AtsListApplicationsScheduledInterviewsParams
  ): Promise<ScheduledInterviewsPaginated> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/scheduled_interviews`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ScheduledInterviewsPaginated>;
  }

  /**
   * Get Applications scheduled interview
   */
  async getApplicationScheduledInterview(
    params: AtsGetApplicationScheduledInterviewParams
  ): Promise<ScheduledInterviewsResult> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/scheduled_interviews/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ScheduledInterviewsResult>;
  }

  /**
   * Upload Application Document
   */
  async uploadApplicationDocument(
    params: AtsUploadApplicationDocumentParams
  ): Promise<WriteResultApiModel> {
    const url = `${this.baseUrl}/unified/ats/applications/${params.id}/documents/upload`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<WriteResultApiModel>;
  }

  /**
   * Download Application Document
   */
  async downloadApplicationDocument(
    params: AtsDownloadApplicationDocumentParams
  ): Promise<DownloadApiModel> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/documents/${params.subresourceid}/download`;
    const queryParts: string[] = [];
    if (params.format !== undefined) {
      queryParts.push(`format=${encodeURIComponent(String(params.format))}`);
    }
    if (params.exportFormat !== undefined) {
      queryParts.push(`export_format=${encodeURIComponent(String(params.exportFormat))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<DownloadApiModel>;
  }

  /**
   * List Application Documents
   */
  async listApplicationDocuments(
    params: AtsListApplicationDocumentsParams
  ): Promise<AtsDocumentsPaginated> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/documents`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<AtsDocumentsPaginated>;
  }

  /**
   * Get Application Document
   */
  async getApplicationDocument(
    params: AtsGetApplicationDocumentParams
  ): Promise<AtsDocumentResult> {
    let url = `${this.baseUrl}/unified/ats/applications/${params.id}/documents/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<AtsDocumentResult>;
  }

  /**
   * List Candidates
   */
  async listCandidates(params?: AtsListCandidatesParams): Promise<CandidatesPaginated> {
    let url = `${this.baseUrl}/unified/ats/candidates`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (params?.include !== undefined) {
      queryParts.push(`include=${encodeURIComponent(String(params?.include))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CandidatesPaginated>;
  }

  /**
   * Create Candidate
   */
  async createCandidate(params: AtsCreateCandidateParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/ats/candidates`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get Candidate
   */
  async getCandidate(params: AtsGetCandidateParams): Promise<CandidateResult> {
    let url = `${this.baseUrl}/unified/ats/candidates/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.include !== undefined) {
      queryParts.push(`include=${encodeURIComponent(String(params.include))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CandidateResult>;
  }

  /**
   * Update Candidate
   */
  async updateCandidate(params: AtsUpdateCandidateParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/ats/candidates/${params.id}`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PATCH',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * List Candidate Notes
   */
  async listCandidateNotes(params: AtsListCandidateNotesParams): Promise<NotesPaginated> {
    let url = `${this.baseUrl}/unified/ats/candidates/${params.id}/notes`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<NotesPaginated>;
  }

  /**
   * Create Candidate Note
   */
  async createCandidateNote(params: AtsCreateCandidateNoteParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/ats/candidates/${params.id}/notes`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get Candidate Note
   */
  async getCandidateNote(params: AtsGetCandidateNoteParams): Promise<NoteResult> {
    let url = `${this.baseUrl}/unified/ats/candidates/${params.id}/notes/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<NoteResult>;
  }

  /**
   * List Application Custom Field Definitions
   */
  async listApplicationCustomFieldDefinitions(
    params?: AtsListApplicationCustomFieldDefinitionsParams
  ): Promise<CustomFieldDefinitionsPaginated> {
    let url = `${this.baseUrl}/unified/ats/custom_field_definitions/applications`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CustomFieldDefinitionsPaginated>;
  }

  /**
   * Get Application Custom Field Definition
   */
  async getApplicationCustomFieldDefinition(
    params: AtsGetApplicationCustomFieldDefinitionParams
  ): Promise<CustomFieldDefinitionResultApiModel> {
    let url = `${this.baseUrl}/unified/ats/custom_field_definitions/applications/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CustomFieldDefinitionResultApiModel>;
  }

  /**
   * List Candidate Custom Field Definitions
   */
  async listCandidateCustomFieldDefinitions(
    params?: AtsListCandidateCustomFieldDefinitionsParams
  ): Promise<CustomFieldDefinitionsPaginated> {
    let url = `${this.baseUrl}/unified/ats/custom_field_definitions/candidates`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CustomFieldDefinitionsPaginated>;
  }

  /**
   * Get Candidate Custom Field Definition
   */
  async getCandidateCustomFieldDefinition(
    params: AtsGetCandidateCustomFieldDefinitionParams
  ): Promise<CustomFieldDefinitionResultApiModel> {
    let url = `${this.baseUrl}/unified/ats/custom_field_definitions/candidates/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CustomFieldDefinitionResultApiModel>;
  }

  /**
   * List Job Custom Field Definitions
   */
  async listJobCustomFieldDefinitions(
    params?: AtsListJobCustomFieldDefinitionsParams
  ): Promise<CustomFieldDefinitionsPaginated> {
    let url = `${this.baseUrl}/unified/ats/custom_field_definitions/jobs`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CustomFieldDefinitionsPaginated>;
  }

  /**
   * Get Job Custom Field Definition
   */
  async getJobCustomFieldDefinition(
    params: AtsGetJobCustomFieldDefinitionParams
  ): Promise<CustomFieldDefinitionResultApiModel> {
    let url = `${this.baseUrl}/unified/ats/custom_field_definitions/jobs/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CustomFieldDefinitionResultApiModel>;
  }

  /**
   * List Departments
   */
  async listDepartments(params?: AtsListDepartmentsParams): Promise<DepartmentsPaginated> {
    let url = `${this.baseUrl}/unified/ats/departments`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<DepartmentsPaginated>;
  }

  /**
   * Get Department
   */
  async getDepartment(params: AtsGetDepartmentParams): Promise<DepartmentResult> {
    let url = `${this.baseUrl}/unified/ats/departments/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<DepartmentResult>;
  }

  /**
   * List Application Stages
   */
  async listApplicationStages(
    params?: AtsListApplicationStagesParams
  ): Promise<InterviewStagesPaginated> {
    let url = `${this.baseUrl}/unified/ats/application_stages`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<InterviewStagesPaginated>;
  }

  /**
   * Get Application Stage
   */
  async getApplicationStage(params: AtsGetApplicationStageParams): Promise<InterviewStageResult> {
    let url = `${this.baseUrl}/unified/ats/application_stages/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<InterviewStageResult>;
  }

  /**
   * List Interviews
   */
  async listInterviews(params?: AtsListInterviewsParams): Promise<InterviewsPaginated> {
    let url = `${this.baseUrl}/unified/ats/interviews`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<InterviewsPaginated>;
  }

  /**
   * Get Interview
   */
  async getInterview(params: AtsGetInterviewParams): Promise<InterviewsResult> {
    let url = `${this.baseUrl}/unified/ats/interviews/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<InterviewsResult>;
  }

  /**
   * List Jobs
   */
  async listJobs(params?: AtsListJobsParams): Promise<AtsJobsPaginated> {
    let url = `${this.baseUrl}/unified/ats/jobs`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (params?.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params?.expand))}`);
    }
    if (params?.include !== undefined) {
      queryParts.push(`include=${encodeURIComponent(String(params?.include))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<AtsJobsPaginated>;
  }

  /**
   * Create Job
   */
  async createJob(params: AtsCreateJobParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/ats/jobs`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * List Job Application Stages
   */
  async listJobApplicationStages(
    params: AtsListJobApplicationStagesParams
  ): Promise<ApplicationStagesPaginated> {
    let url = `${this.baseUrl}/unified/ats/jobs/${params.id}/application_stages`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ApplicationStagesPaginated>;
  }

  /**
   * Get Job
   */
  async getJob(params: AtsGetJobParams): Promise<AtsJobResult> {
    let url = `${this.baseUrl}/unified/ats/jobs/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params.expand))}`);
    }
    if (params.include !== undefined) {
      queryParts.push(`include=${encodeURIComponent(String(params.include))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<AtsJobResult>;
  }

  /**
   * Update Job
   */
  async updateJob(params: AtsUpdateJobParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/ats/jobs/${params.id}`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PATCH',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get Job Application Stage
   */
  async getJobApplicationStage(
    params: AtsGetJobApplicationStageParams
  ): Promise<ApplicationStageResult> {
    let url = `${this.baseUrl}/unified/ats/jobs/${params.id}/application_stages/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ApplicationStageResult>;
  }

  /**
   * Get all Lists
   */
  async listLists(params?: AtsListListsParams): Promise<ListsPaginated> {
    let url = `${this.baseUrl}/unified/ats/lists`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ListsPaginated>;
  }

  /**
   * Get List
   */
  async getList(params: AtsGetListParams): Promise<ListResult> {
    let url = `${this.baseUrl}/unified/ats/lists/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ListResult>;
  }

  /**
   * List locations
   */
  async listLocations(params?: AtsListLocationsParams): Promise<ATSLocationsPaginated> {
    let url = `${this.baseUrl}/unified/ats/locations`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ATSLocationsPaginated>;
  }

  /**
   * Get Location
   */
  async getLocation(params: AtsGetLocationParams): Promise<ATSLocationResult> {
    let url = `${this.baseUrl}/unified/ats/locations/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ATSLocationResult>;
  }

  /**
   * List Rejected Reasons
   */
  async listRejectedReasons(
    params?: AtsListRejectedReasonsParams
  ): Promise<RejectedReasonsPaginated> {
    let url = `${this.baseUrl}/unified/ats/rejected_reasons`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<RejectedReasonsPaginated>;
  }

  /**
   * Get Rejected Reason
   */
  async getRejectedReason(params: AtsGetRejectedReasonParams): Promise<RejectedReasonResult> {
    let url = `${this.baseUrl}/unified/ats/rejected_reasons/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<RejectedReasonResult>;
  }

  /**
   * List Users
   */
  async listUsers(params?: AtsListUsersParams): Promise<UsersPaginated> {
    let url = `${this.baseUrl}/unified/ats/users`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UsersPaginated>;
  }

  /**
   * Get User
   */
  async getUser(params: AtsGetUserParams): Promise<UserResult> {
    let url = `${this.baseUrl}/unified/ats/users/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UserResult>;
  }

  /**
   * List Job Postings
   */
  async listJobPostings(params?: AtsListJobPostingsParams): Promise<JobPostingsPaginated> {
    let url = `${this.baseUrl}/unified/ats/job_postings`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (params?.include !== undefined) {
      queryParts.push(`include=${encodeURIComponent(String(params?.include))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<JobPostingsPaginated>;
  }

  /**
   * Get Job Posting
   */
  async getJobPosting(params: AtsGetJobPostingParams): Promise<JobPostingResult> {
    let url = `${this.baseUrl}/unified/ats/job_postings/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.include !== undefined) {
      queryParts.push(`include=${encodeURIComponent(String(params.include))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<JobPostingResult>;
  }

  /**
   * List Offers
   */
  async listOffers(params?: AtsListOffersParams): Promise<OffersPaginated> {
    let url = `${this.baseUrl}/unified/ats/offers`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<OffersPaginated>;
  }

  /**
   * Create Offer
   */
  async createOffer(params: AtsCreateOfferParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/ats/offers`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get Offer
   */
  async getOffer(params: AtsGetOfferParams): Promise<OffersResult> {
    let url = `${this.baseUrl}/unified/ats/offers/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<OffersResult>;
  }

  /**
   * List Assessments Packages
   */
  async listAssessmentsPackages(
    params?: AtsListAssessmentsPackagesParams
  ): Promise<AssessmentPackagePaginated> {
    let url = `${this.baseUrl}/unified/ats/assessments/packages`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<AssessmentPackagePaginated>;
  }

  /**
   * Get Assessments Package
   */
  async getAssessmentsPackage(
    params: AtsGetAssessmentsPackageParams
  ): Promise<AssessmentPackageResult> {
    let url = `${this.baseUrl}/unified/ats/assessments/packages/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<AssessmentPackageResult>;
  }

  /**
   * Order Assessments Request
   */
  async orderAssessmentsRequest(
    params: AtsOrderAssessmentsRequestParams
  ): Promise<CreateAssessmentOrderResult> {
    const url = `${this.baseUrl}/unified/ats/assessments/orders`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateAssessmentOrderResult>;
  }

  /**
   * Update Assessments Result
   */
  async updateAssessmentsResult(params: AtsUpdateAssessmentsResultParams): Promise<UpdateResult> {
    const url = `${this.baseUrl}/unified/ats/assessments/orders/${params.id}/result`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PATCH',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UpdateResult>;
  }

  /**
   * List Background Check Packages
   */
  async listBackgroundCheckPackages(
    params?: AtsListBackgroundCheckPackagesParams
  ): Promise<BackgroundCheckPackagePaginated> {
    let url = `${this.baseUrl}/unified/ats/background_checks/packages`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<BackgroundCheckPackagePaginated>;
  }

  /**
   * Create Background Check Package
   */
  async createBackgroundCheckPackage(
    params: AtsCreateBackgroundCheckPackageParams
  ): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/ats/background_checks/packages`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get Background Check Package
   */
  async getBackgroundCheckPackage(
    params: AtsGetBackgroundCheckPackageParams
  ): Promise<BackgroundCheckPackageResult> {
    let url = `${this.baseUrl}/unified/ats/background_checks/packages/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<BackgroundCheckPackageResult>;
  }

  /**
   * Delete Background Check Package
   */
  async deleteBackgroundCheckPackage(
    params: AtsDeleteBackgroundCheckPackageParams
  ): Promise<DeleteResult> {
    const url = `${this.baseUrl}/unified/ats/background_checks/packages/${params.id}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'DELETE',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<DeleteResult>;
  }

  /**
   * Update Background Check Package
   */
  async updateBackgroundCheckPackage(
    params: AtsUpdateBackgroundCheckPackageParams
  ): Promise<UpdateResult> {
    const url = `${this.baseUrl}/unified/ats/background_checks/packages/${params.id}`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PATCH',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UpdateResult>;
  }

  /**
   * Order Background Check Request
   */
  async orderBackgroundCheckRequest(
    params: AtsOrderBackgroundCheckRequestParams
  ): Promise<CreateBackgroundCheckOrderResult> {
    const url = `${this.baseUrl}/unified/ats/background_checks/orders`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateBackgroundCheckOrderResult>;
  }

  /**
   * Update Background Check Result
   */
  async updateBackgroundCheckResult(
    params: AtsUpdateBackgroundCheckResultParams
  ): Promise<UpdateResult> {
    const url = `${this.baseUrl}/unified/ats/background_checks/orders/${params.id}/result`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PATCH',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UpdateResult>;
  }

  /**
   * List Application Document Categories
   */
  async listApplicationDocumentCategories(
    params?: AtsListApplicationDocumentCategoriesParams
  ): Promise<ReferencePaginated> {
    let url = `${this.baseUrl}/unified/ats/documents/application_categories`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ReferencePaginated>;
  }

  /**
   * Get Application Document Category
   */
  async getApplicationDocumentCategory(
    params: AtsGetApplicationDocumentCategoryParams
  ): Promise<ReferenceResult> {
    let url = `${this.baseUrl}/unified/ats/documents/application_categories/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ReferenceResult>;
  }
}
