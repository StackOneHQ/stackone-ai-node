// Auto-generated TypeScript SDK from OpenAPI specification
// DO NOT EDIT THIS FILE DIRECTLY

import type { StackOneClientConfig } from './types';

// ============================================================
// Type Definitions
// ============================================================

// Auto-generated TypeScript interfaces from OpenAPI schemas
// DO NOT EDIT THIS FILE DIRECTLY

export interface BadGatewayResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface BadRequestResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
  /** Error details */
  data?: UnifiedError | null;
  /** List of provider-specific errors */
  provider_errors?: ProviderError[] | null;
}

export interface ConflictResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface Content {
  /** URL where the file content is located */
  url?: string | null;
  /** Unified download URL for retrieving file content. */
  unified_url?: string | null;
  /** The file format of the file */
  file_format?: FileFormatEnum | null;
}

export interface DeleteResult {
  statusCode: number;
  message: string;
  timestamp: string;
}

export interface File {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The name of the file */
  name?: string | null;
  /** The category of the file */
  category?: FileCategoryEnumApiModel | null;
  /** The content of the file. Deprecated, use `url` and `file_format` one level up instead */
  contents?: Content[] | null;
  /** The categoryId of the documents */
  category_id?: string | null;
  /** The creation date of the file */
  created_at?: string | null;
  /** The update date of the file */
  updated_at?: string | null;
  /** URL where the file content is located */
  remote_url?: string | null;
  /** The file format of the file */
  file_format?: FileFormatEnum | null;
}

export interface FileCategoryEnumApiModel {
  /** The category of the file */
  value?: string | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface FileFormatEnum {
  /** The file format of the file, expressed as a file extension */
  value?:
    | 'unmapped_value'
    | 'ez'
    | 'aw'
    | 'atom'
    | 'atomcat'
    | 'atomdeleted'
    | 'atomsvc'
    | 'dwd'
    | 'held'
    | 'rsat'
    | 'bdoc'
    | 'xcs'
    | 'ccxml'
    | 'cdfx'
    | 'cdmia'
    | 'cdmic'
    | 'cdmid'
    | 'cdmio'
    | 'cdmiq'
    | 'cu'
    | 'mpd'
    | 'davmount'
    | 'dbk'
    | 'dssc'
    | 'xdssc'
    | 'es'
    | 'ecma'
    | 'emma'
    | 'emotionml'
    | 'epub'
    | 'exi'
    | 'exp'
    | 'fdt'
    | 'pfr'
    | 'geojson'
    | 'gml'
    | 'gpx'
    | 'gxf'
    | 'gz'
    | 'hjson'
    | 'stk'
    | 'ink'
    | 'inkml'
    | 'ipfix'
    | 'its'
    | 'jar'
    | 'war'
    | 'ear'
    | 'ser'
    | 'class'
    | 'js'
    | 'mjs'
    | 'json'
    | 'map'
    | 'json5'
    | 'jsonml'
    | 'jsonld'
    | 'lgr'
    | 'lostxml'
    | 'hqx'
    | 'cpt'
    | 'mads'
    | 'webmanifest'
    | 'mrc'
    | 'mrcx'
    | 'ma'
    | 'nb'
    | 'mb'
    | 'mathml'
    | 'mbox'
    | 'mscml'
    | 'metalink'
    | 'meta4'
    | 'mets'
    | 'maei'
    | 'musd'
    | 'mods'
    | 'm21'
    | 'mp21'
    | 'mp4s'
    | 'm4p'
    | 'doc'
    | 'dot'
    | 'mxf'
    | 'nq'
    | 'nt'
    | 'cjs'
    | 'bin'
    | 'dms'
    | 'lrf'
    | 'mar'
    | 'so'
    | 'dist'
    | 'distz'
    | 'pkg'
    | 'bpk'
    | 'dump'
    | 'elc'
    | 'deploy'
    | 'exe'
    | 'dll'
    | 'deb'
    | 'dmg'
    | 'iso'
    | 'img'
    | 'msi'
    | 'msp'
    | 'msm'
    | 'buffer'
    | 'oda'
    | 'opf'
    | 'ogx'
    | 'omdoc'
    | 'onetoc'
    | 'onetoc2'
    | 'onetmp'
    | 'onepkg'
    | 'oxps'
    | 'relo'
    | 'xer'
    | 'pdf'
    | 'pgp'
    | 'asc'
    | 'sig'
    | 'prf'
    | 'p10'
    | 'p7m'
    | 'p7c'
    | 'p7s'
    | 'p8'
    | 'ac'
    | 'cer'
    | 'crl'
    | 'pkipath'
    | 'pki'
    | 'pls'
    | 'ai'
    | 'eps'
    | 'ps'
    | 'provx'
    | 'pskcxml'
    | 'raml'
    | 'rdf'
    | 'owl'
    | 'rif'
    | 'rnc'
    | 'rl'
    | 'rld'
    | 'rs'
    | 'rapd'
    | 'sls'
    | 'rusd'
    | 'gbr'
    | 'mft'
    | 'roa'
    | 'rsd'
    | 'rss'
    | 'rtf'
    | 'sbml'
    | 'scq'
    | 'scs'
    | 'spq'
    | 'spp'
    | 'sdp'
    | 'senmlx'
    | 'sensmlx'
    | 'setpay'
    | 'setreg'
    | 'shf'
    | 'siv'
    | 'sieve'
    | 'smi'
    | 'smil'
    | 'rq'
    | 'srx'
    | 'gram'
    | 'grxml'
    | 'sru'
    | 'ssdl'
    | 'ssml'
    | 'swidtag'
    | 'tei'
    | 'teicorpus'
    | 'tfi'
    | 'tsd'
    | 'toml'
    | 'trig'
    | 'ttml'
    | 'ubj'
    | 'rsheet'
    | 'td'
    | 'vxml'
    | 'wasm'
    | 'wgt'
    | 'hlp'
    | 'wsdl'
    | 'wspolicy'
    | 'xaml'
    | 'xav'
    | 'xca'
    | 'xdf'
    | 'xel'
    | 'xns'
    | 'xenc'
    | 'xhtml'
    | 'xht'
    | 'xlf'
    | 'xml'
    | 'xsl'
    | 'xsd'
    | 'rng'
    | 'dtd'
    | 'xop'
    | 'xpl'
    | '*xsl'
    | 'xslt'
    | 'xspf'
    | 'mxml'
    | 'xhvml'
    | 'xvml'
    | 'xvm'
    | 'yang'
    | 'yin'
    | 'zip'
    | '*3gpp'
    | 'adp'
    | 'amr'
    | 'au'
    | 'snd'
    | 'mid'
    | 'midi'
    | 'kar'
    | 'rmi'
    | 'mxmf'
    | '*mp3'
    | 'm4a'
    | 'mp4a'
    | 'mpga'
    | 'mp2'
    | 'mp2a'
    | 'mp3'
    | 'm2a'
    | 'm3a'
    | 'oga'
    | 'ogg'
    | 'spx'
    | 'opus'
    | 's3m'
    | 'sil'
    | 'wav'
    | '*wav'
    | 'weba'
    | 'xm'
    | 'ttc'
    | 'otf'
    | 'ttf'
    | 'woff'
    | 'woff2'
    | 'exr'
    | 'apng'
    | 'avif'
    | 'bmp'
    | 'cgm'
    | 'drle'
    | 'emf'
    | 'fits'
    | 'g3'
    | 'gif'
    | 'heic'
    | 'heics'
    | 'heif'
    | 'heifs'
    | 'hej2'
    | 'hsj2'
    | 'ief'
    | 'jls'
    | 'jp2'
    | 'jpg2'
    | 'jpeg'
    | 'jpg'
    | 'jpe'
    | 'jph'
    | 'jhc'
    | 'jpm'
    | 'jpx'
    | 'jpf'
    | 'jxr'
    | 'jxra'
    | 'jxrs'
    | 'jxs'
    | 'jxsc'
    | 'jxsi'
    | 'jxss'
    | 'ktx'
    | 'ktx2'
    | 'png'
    | 'sgi'
    | 'svg'
    | 'svgz'
    | 't38'
    | 'tif'
    | 'tiff'
    | 'tfx'
    | 'webp'
    | 'wmf'
    | 'disposition-notification'
    | 'u8msg'
    | 'u8dsn'
    | 'u8mdn'
    | 'u8hdr'
    | 'eml'
    | 'mime'
    | '3mf'
    | 'gltf'
    | 'glb'
    | 'igs'
    | 'iges'
    | 'msh'
    | 'mesh'
    | 'silo'
    | 'mtl'
    | 'obj'
    | 'stpx'
    | 'stpz'
    | 'stpxz'
    | 'stl'
    | 'wrl'
    | 'vrml'
    | '*x3db'
    | 'x3dbz'
    | 'x3db'
    | '*x3dv'
    | 'x3dvz'
    | 'x3d'
    | 'x3dz'
    | 'x3dv'
    | 'appcache'
    | 'manifest'
    | 'ics'
    | 'ifb'
    | 'coffee'
    | 'litcoffee'
    | 'css'
    | 'csv'
    | 'html'
    | 'htm'
    | 'shtml'
    | 'jade'
    | 'jsx'
    | 'less'
    | 'markdown'
    | 'md'
    | 'mml'
    | 'mdx'
    | 'n3'
    | 'txt'
    | 'text'
    | 'conf'
    | 'def'
    | 'list'
    | 'log'
    | 'in'
    | 'ini'
    | 'rtx'
    | '*rtf'
    | 'sgml'
    | 'sgm'
    | 'shex'
    | 'slim'
    | 'slm'
    | 'spdx'
    | 'stylus'
    | 'styl'
    | 'tsv'
    | 't'
    | 'tr'
    | 'roff'
    | 'man'
    | 'me'
    | 'ms'
    | 'ttl'
    | 'uri'
    | 'uris'
    | 'urls'
    | 'vcard'
    | 'vtt'
    | '*xml'
    | 'yaml'
    | 'yml'
    | '3gp'
    | '3gpp'
    | '3g2'
    | 'h261'
    | 'h263'
    | 'h264'
    | 'm4s'
    | 'jpgv'
    | '*jpm'
    | 'jpgm'
    | 'mj2'
    | 'mjp2'
    | 'ts'
    | 'mp4'
    | 'mp4v'
    | 'mpg4'
    | 'mpeg'
    | 'mpg'
    | 'mpe'
    | 'm1v'
    | 'm2v'
    | 'ogv'
    | 'qt'
    | 'mov'
    | 'webm'
    | 'cww'
    | '1km'
    | 'plb'
    | 'psb'
    | 'pvb'
    | 'tcap'
    | 'pwn'
    | 'aso'
    | 'imp'
    | 'acu'
    | 'atc'
    | 'acutc'
    | 'air'
    | 'fcdt'
    | 'fxp'
    | 'fxpl'
    | 'xdp'
    | 'xfdf'
    | 'ahead'
    | 'azf'
    | 'azs'
    | 'azw'
    | 'acc'
    | 'ami'
    | 'apk'
    | 'cii'
    | 'fti'
    | 'atx'
    | 'mpkg'
    | 'key'
    | 'm3u8'
    | 'numbers'
    | 'pages'
    | 'pkpass'
    | 'swi'
    | 'iota'
    | 'aep'
    | 'bmml'
    | 'mpm'
    | 'bmi'
    | 'rep'
    | 'cdxml'
    | 'mmd'
    | 'cdy'
    | 'csl'
    | 'cla'
    | 'rp9'
    | 'c4g'
    | 'c4d'
    | 'c4f'
    | 'c4p'
    | 'c4u'
    | 'c11amc'
    | 'c11amz'
    | 'csp'
    | 'cdbcmsg'
    | 'cmc'
    | 'clkx'
    | 'clkk'
    | 'clkp'
    | 'clkt'
    | 'clkw'
    | 'wbs'
    | 'pml'
    | 'ppd'
    | 'car'
    | 'pcurl'
    | 'dart'
    | 'rdz'
    | 'dbf'
    | 'uvf'
    | 'uvvf'
    | 'uvd'
    | 'uvvd'
    | 'uvt'
    | 'uvvt'
    | 'uvx'
    | 'uvvx'
    | 'uvz'
    | 'uvvz'
    | 'fe_launch'
    | 'dna'
    | 'mlp'
    | 'mle'
    | 'dpg'
    | 'dfac'
    | 'kpxx'
    | 'ait'
    | 'svc'
    | 'geo'
    | 'mag'
    | 'nml'
    | 'esf'
    | 'msf'
    | 'qam'
    | 'slt'
    | 'ssf'
    | 'es3'
    | 'et3'
    | 'ez2'
    | 'ez3'
    | 'fdf'
    | 'mseed'
    | 'seed'
    | 'dataless'
    | 'gph'
    | 'ftc'
    | 'fm'
    | 'frame'
    | 'maker'
    | 'book'
    | 'fnc'
    | 'ltf'
    | 'fsc'
    | 'oas'
    | 'oa2'
    | 'oa3'
    | 'fg5'
    | 'bh2'
    | 'ddd'
    | 'xdw'
    | 'xbd'
    | 'fzs'
    | 'txd'
    | 'ggb'
    | 'ggt'
    | 'gex'
    | 'gre'
    | 'gxt'
    | 'g2w'
    | 'g3w'
    | 'gmx'
    | 'gdoc'
    | 'gslides'
    | 'gsheet'
    | 'kml'
    | 'kmz'
    | 'gqf'
    | 'gqs'
    | 'gac'
    | 'ghf'
    | 'gim'
    | 'grv'
    | 'gtm'
    | 'tpl'
    | 'vcg'
    | 'hal'
    | 'zmm'
    | 'hbci'
    | 'les'
    | 'hpgl'
    | 'hpid'
    | 'hps'
    | 'jlt'
    | 'pcl'
    | 'pclxl'
    | 'sfd-hdstx'
    | 'mpy'
    | 'afp'
    | 'listafp'
    | 'list3820'
    | 'irm'
    | 'sc'
    | 'icc'
    | 'icm'
    | 'igl'
    | 'ivp'
    | 'ivu'
    | 'igm'
    | 'xpw'
    | 'xpx'
    | 'i2g'
    | 'qbo'
    | 'qfx'
    | 'rcprofile'
    | 'irp'
    | 'xpr'
    | 'fcs'
    | 'jam'
    | 'rms'
    | 'jisp'
    | 'joda'
    | 'ktz'
    | 'ktr'
    | 'karbon'
    | 'chrt'
    | 'kfo'
    | 'flw'
    | 'kon'
    | 'kpr'
    | 'kpt'
    | 'ksp'
    | 'kwd'
    | 'kwt'
    | 'htke'
    | 'kia'
    | 'kne'
    | 'knp'
    | 'skp'
    | 'skd'
    | 'skt'
    | 'skm'
    | 'sse'
    | 'lasxml'
    | 'lbd'
    | 'lbe'
    | 'apr'
    | 'pre'
    | 'nsf'
    | 'org'
    | 'scm'
    | 'lwp'
    | 'portpkg'
    | 'mvt'
    | 'mcd'
    | 'mc1'
    | 'cdkey'
    | 'mwf'
    | 'mfm'
    | 'flo'
    | 'igx'
    | 'mif'
    | 'daf'
    | 'dis'
    | 'mbk'
    | 'mqy'
    | 'msl'
    | 'plc'
    | 'txf'
    | 'mpn'
    | 'mpc'
    | 'xul'
    | 'cil'
    | 'cab'
    | 'xls'
    | 'xlm'
    | 'xla'
    | 'xlc'
    | 'xlt'
    | 'xlw'
    | 'xlam'
    | 'xlsb'
    | 'xlsm'
    | 'xltm'
    | 'eot'
    | 'chm'
    | 'ims'
    | 'lrm'
    | 'thmx'
    | 'msg'
    | 'cat'
    | '*stl'
    | 'ppt'
    | 'pps'
    | 'pot'
    | 'ppam'
    | 'pptm'
    | 'sldm'
    | 'ppsm'
    | 'potm'
    | 'mpp'
    | 'mpt'
    | 'docm'
    | 'dotm'
    | 'wps'
    | 'wks'
    | 'wcm'
    | 'wdb'
    | 'wpl'
    | 'xps'
    | 'mseq'
    | 'mus'
    | 'msty'
    | 'taglet'
    | 'nlu'
    | 'ntf'
    | 'nitf'
    | 'nnd'
    | 'nns'
    | 'nnw'
    | '*ac'
    | 'ngdat'
    | 'n-gage'
    | 'rpst'
    | 'rpss'
    | 'edm'
    | 'edx'
    | 'ext'
    | 'odc'
    | 'otc'
    | 'odb'
    | 'odf'
    | 'odft'
    | 'odg'
    | 'otg'
    | 'odi'
    | 'oti'
    | 'odp'
    | 'otp'
    | 'ods'
    | 'ots'
    | 'odt'
    | 'odm'
    | 'ott'
    | 'oth'
    | 'xo'
    | 'dd2'
    | 'obgx'
    | 'oxt'
    | 'osm'
    | 'pptx'
    | 'sldx'
    | 'ppsx'
    | 'potx'
    | 'xlsx'
    | 'xltx'
    | 'docx'
    | 'dotx'
    | 'mgp'
    | 'dp'
    | 'esa'
    | 'pdb'
    | 'pqa'
    | 'oprc'
    | 'paw'
    | 'str'
    | 'ei6'
    | 'efif'
    | 'wg'
    | 'plf'
    | 'pbd'
    | 'box'
    | 'mgz'
    | 'qps'
    | 'ptid'
    | 'qxd'
    | 'qxt'
    | 'qwd'
    | 'qwt'
    | 'qxl'
    | 'qxb'
    | 'rar'
    | 'bed'
    | 'mxl'
    | 'musicxml'
    | 'cryptonote'
    | 'cod'
    | 'rm'
    | 'rmvb'
    | 'link66'
    | 'st'
    | 'see'
    | 'sema'
    | 'semd'
    | 'semf'
    | 'ifm'
    | 'itp'
    | 'iif'
    | 'ipk'
    | 'twd'
    | 'twds'
    | 'mmf'
    | 'teacher'
    | 'fo'
    | 'sdkm'
    | 'sdkd'
    | 'dxp'
    | 'sfs'
    | 'sdc'
    | 'sda'
    | 'sdd'
    | 'smf'
    | 'sdw'
    | 'vor'
    | 'sgl'
    | 'smzip'
    | 'sm'
    | 'wadl'
    | 'sxc'
    | 'stc'
    | 'sxd'
    | 'std'
    | 'sxi'
    | 'sti'
    | 'sxm'
    | 'sxw'
    | 'sxg'
    | 'stw'
    | 'sus'
    | 'susp'
    | 'svd'
    | 'sis'
    | 'sisx'
    | 'xsm'
    | 'bdm'
    | 'xdm'
    | 'ddf'
    | 'tao'
    | 'pcap'
    | 'cap'
    | 'dmp'
    | 'tmo'
    | 'tpt'
    | 'mxs'
    | 'tra'
    | 'ufd'
    | 'ufdl'
    | 'utz'
    | 'umj'
    | 'unityweb'
    | 'uoml'
    | 'vcx'
    | 'vsd'
    | 'vst'
    | 'vss'
    | 'vsw'
    | 'vis'
    | 'vsf'
    | 'wbxml'
    | 'wmlc'
    | 'wmlsc'
    | 'wtb'
    | 'nbp'
    | 'wpd'
    | 'wqd'
    | 'stf'
    | 'xar'
    | 'xfdl'
    | 'hvd'
    | 'hvs'
    | 'hvp'
    | 'osf'
    | 'osfpvg'
    | 'saf'
    | 'spf'
    | 'cmp'
    | 'zir'
    | 'zirz'
    | 'zaz'
    | '7z'
    | 'abw'
    | 'ace'
    | '*dmg'
    | 'arj'
    | 'aab'
    | 'x32'
    | 'u32'
    | 'vox'
    | 'aam'
    | 'aas'
    | 'bcpio'
    | '*bdoc'
    | 'torrent'
    | 'blb'
    | 'blorb'
    | 'bz'
    | 'bz2'
    | 'boz'
    | 'cbr'
    | 'cba'
    | 'cbt'
    | 'cbz'
    | 'cb7'
    | 'vcd'
    | 'cfs'
    | 'chat'
    | 'pgn'
    | 'crx'
    | 'cco'
    | 'nsc'
    | 'cpio'
    | 'csh'
    | '*deb'
    | 'udeb'
    | 'dgc'
    | 'dir'
    | 'dcr'
    | 'dxr'
    | 'cst'
    | 'cct'
    | 'cxt'
    | 'w3d'
    | 'fgd'
    | 'swa'
    | 'wad'
    | 'ncx'
    | 'dtb'
    | 'res'
    | 'dvi'
    | 'evy'
    | 'eva'
    | 'bdf'
    | 'gsf'
    | 'psf'
    | 'pcf'
    | 'snf'
    | 'pfa'
    | 'pfb'
    | 'pfm'
    | 'afm'
    | 'arc'
    | 'spl'
    | 'gca'
    | 'ulx'
    | 'gnumeric'
    | 'gramps'
    | 'gtar'
    | 'hdf'
    | 'php'
    | 'install'
    | '*iso'
    | '*key'
    | '*numbers'
    | '*pages'
    | 'jardiff'
    | 'jnlp'
    | 'kdbx'
    | 'latex'
    | 'luac'
    | 'lzh'
    | 'lha'
    | 'run'
    | 'mie'
    | 'prc'
    | 'mobi'
    | 'application'
    | 'lnk'
    | 'wmd'
    | 'wmz'
    | 'xbap'
    | 'mdb'
    | 'obd'
    | 'crd'
    | 'clp'
    | '*exe'
    | '*dll'
    | 'com'
    | 'bat'
    | '*msi'
    | 'mvb'
    | 'm13'
    | 'm14'
    | '*wmf'
    | '*wmz'
    | '*emf'
    | 'emz'
    | 'mny'
    | 'pub'
    | 'scd'
    | 'trm'
    | 'wri'
    | 'nc'
    | 'cdf'
    | 'pac'
    | 'nzb'
    | 'pl'
    | 'pm'
    | '*prc'
    | '*pdb'
    | 'p12'
    | 'pfx'
    | 'p7b'
    | 'spc'
    | 'p7r'
    | '*rar'
    | 'rpm'
    | 'ris'
    | 'sea'
    | 'sh'
    | 'shar'
    | 'swf'
    | 'xap'
    | 'sql'
    | 'sit'
    | 'sitx'
    | 'srt'
    | 'sv4cpio'
    | 'sv4crc'
    | 't3'
    | 'gam'
    | 'tar'
    | 'tcl'
    | 'tk'
    | 'tex'
    | 'tfm'
    | 'texinfo'
    | 'texi'
    | '*obj'
    | 'ustar'
    | 'hdd'
    | 'ova'
    | 'ovf'
    | 'vbox'
    | 'vbox-extpack'
    | 'vdi'
    | 'vhd'
    | 'vmdk'
    | 'src'
    | 'webapp'
    | 'der'
    | 'crt'
    | 'pem'
    | 'fig'
    | '*xlf'
    | 'xpi'
    | 'xz'
    | 'z1'
    | 'z2'
    | 'z3'
    | 'z4'
    | 'z5'
    | 'z6'
    | 'z7'
    | 'z8'
    | 'uva'
    | 'uvva'
    | 'eol'
    | 'dra'
    | 'dts'
    | 'dtshd'
    | 'lvp'
    | 'pya'
    | 'ecelp4800'
    | 'ecelp7470'
    | 'ecelp9600'
    | 'rip'
    | 'aac'
    | 'aif'
    | 'aiff'
    | 'aifc'
    | 'caf'
    | 'flac'
    | '*m4a'
    | 'mka'
    | 'm3u'
    | 'wax'
    | 'wma'
    | 'ram'
    | 'ra'
    | 'rmp'
    | '*ra'
    | 'cdx'
    | 'cif'
    | 'cmdf'
    | 'cml'
    | 'csml'
    | 'xyz'
    | 'btif'
    | 'pti'
    | 'psd'
    | 'azv'
    | 'uvi'
    | 'uvvi'
    | 'uvg'
    | 'uvvg'
    | 'djvu'
    | 'djv'
    | '*sub'
    | 'dwg'
    | 'dxf'
    | 'fbs'
    | 'fpx'
    | 'fst'
    | 'mmr'
    | 'rlc'
    | 'ico'
    | 'dds'
    | 'mdi'
    | 'wdp'
    | 'npx'
    | 'b16'
    | 'tap'
    | 'vtf'
    | 'wbmp'
    | 'xif'
    | 'pcx'
    | '3ds'
    | 'ras'
    | 'cmx'
    | 'fh'
    | 'fhc'
    | 'fh4'
    | 'fh5'
    | 'fh7'
    | '*ico'
    | 'jng'
    | 'sid'
    | '*bmp'
    | '*pcx'
    | 'pic'
    | 'pct'
    | 'pnm'
    | 'pbm'
    | 'pgm'
    | 'ppm'
    | 'rgb'
    | 'tga'
    | 'xbm'
    | 'xpm'
    | 'xwd'
    | 'wsc'
    | 'dae'
    | 'dwf'
    | 'gdl'
    | 'gtw'
    | 'mts'
    | 'ogex'
    | 'x_b'
    | 'x_t'
    | 'vds'
    | 'usdz'
    | 'bsp'
    | 'vtu'
    | 'dsc'
    | 'curl'
    | 'dcurl'
    | 'mcurl'
    | 'scurl'
    | 'sub'
    | 'fly'
    | 'flx'
    | 'gv'
    | '3dml'
    | 'spot'
    | 'jad'
    | 'wml'
    | 'wmls'
    | 's'
    | 'asm'
    | 'c'
    | 'cc'
    | 'cxx'
    | 'cpp'
    | 'h'
    | 'hh'
    | 'dic'
    | 'htc'
    | 'f'
    | 'for'
    | 'f77'
    | 'f90'
    | 'hbs'
    | 'java'
    | 'lua'
    | 'mkd'
    | 'nfo'
    | 'opml'
    | '*org'
    | 'p'
    | 'pas'
    | 'pde'
    | 'sass'
    | 'scss'
    | 'etx'
    | 'sfv'
    | 'ymp'
    | 'uu'
    | 'vcs'
    | 'vcf'
    | 'uvh'
    | 'uvvh'
    | 'uvm'
    | 'uvvm'
    | 'uvp'
    | 'uvvp'
    | 'uvs'
    | 'uvvs'
    | 'uvv'
    | 'uvvv'
    | 'dvb'
    | 'fvt'
    | 'mxu'
    | 'm4u'
    | 'pyv'
    | 'uvu'
    | 'uvvu'
    | 'viv'
    | 'f4v'
    | 'fli'
    | 'flv'
    | 'm4v'
    | 'mkv'
    | 'mk3d'
    | 'mks'
    | 'mng'
    | 'asf'
    | 'asx'
    | 'vob'
    | 'wm'
    | 'wmv'
    | 'wmx'
    | 'wvx'
    | 'avi'
    | 'movie'
    | 'smv'
    | 'ice'
    | 'mht'
    | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface ForbiddenResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface GroupTypeEnum {
  value?:
    | 'workspace'
    | 'team'
    | 'department'
    | 'group'
    | 'organization'
    | 'unmapped_value'
    | 'cost_center'
    | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface IamGroup {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  name?: string | null;
  description?: string | null;
  type?: GroupTypeEnum | null;
  roles?: IamRole[] | null;
  /** The parent group id for when a group belongs to another group. */
  parent_id?: string | null;
  /** Provider's unique identifier of the parent group id for when a group belongs to another group. */
  remote_parent_id?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
}

export interface IamGroupResult {
  data: IamGroup;
  raw?: RawResponse[] | null;
}

export interface IamGroupsPaginated {
  next_page?: string | null;
  next?: string | null;
  data: IamGroup[];
  raw?: RawResponse[] | null;
}

export interface IamMfaTypeEnum {
  /** The unified value for the type of multi-factor authentication. If the provider does not send back a type but does specify that MFA is set-up for this user, the value will be set to 'unknown'.' */
  value?:
    | 'sms'
    | 'email'
    | 'push'
    | 'totp'
    | 'phone_call'
    | 'question'
    | 'software_token'
    | 'hardware_token'
    | 'web'
    | 'unknown'
    | 'unmapped_value'
    | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface IamPermission {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The name of the permission. */
  name?: string | null;
  type?: IamPermissionTypeEnum | null;
  /** The resources that the permission applies to. */
  resources?: IamResource[] | null;
  description?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
}

export interface IamPermissionTypeEnum {
  /** The type of the permission, e.g. read, read_write, delete, etc. */
  value?: 'read' | 'read_write' | 'approve' | 'delete' | 'use' | 'export' | 'unmapped_value' | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface IamPoliciesPaginated {
  next_page?: string | null;
  next?: string | null;
  data: IamPolicy[];
  raw?: RawResponse[] | null;
}

export interface IamPolicy {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The name of the policy. */
  name?: string | null;
  /** The set of permissions associated with the policy. */
  permissions?: IamPermission[] | null;
  description?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
}

export interface IamPolicyResult {
  data: IamPolicy;
  raw?: RawResponse[] | null;
}

export interface IamResource {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The name of the resource. */
  name?: string | null;
  /** The location of the resource. */
  location?: string | null;
  type?: IamResourceTypeEnum | null;
  description?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
}

export interface IamResourceTypeEnum {
  /** The type of the resource, e.g. user, group, permission, etc. */
  value?: 'project' | 'file' | 'folder' | 'product' | 'property' | 'user' | 'unmapped_value' | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface IamRole {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  name?: string | null;
  description?: string | null;
  type?: RoleTypeEnum | null;
  /** The set of policies associated with the role. */
  policies?: IamPolicy[] | null;
  created_at?: string | null;
  updated_at?: string | null;
}

export interface IamRoleResult {
  data: IamRole;
  raw?: RawResponse[] | null;
}

export interface IamRolesPaginated {
  next_page?: string | null;
  next?: string | null;
  data: IamRole[];
  raw?: RawResponse[] | null;
}

export interface IamUpdateUserRequestDto {
  /** Primary email address of the user. This is generally a work email address. */
  primary_email_address?: string | null;
  first_name?: string | null;
  last_name?: string | null;
  /** User's name which (can be a full name or display name) */
  name?: string | null;
  username?: string | null;
  /** Indicates if the user is a bot or service user */
  is_bot_user?: (boolean | 'true' | 'false') | null;
  status?: UserStatusEnum | null;
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
}

export interface IamUser {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** Primary email address of the user. This is generally a work email address. */
  primary_email_address?: string | null;
  first_name?: string | null;
  last_name?: string | null;
  /** User's name which (can be a full name or display name) */
  name?: string | null;
  username?: string | null;
  /** Indicates if the user is a bot or service user */
  is_bot_user?: (boolean | 'true' | 'false') | null;
  /** List of roles the user is assigned to */
  roles?: IamRole[] | null;
  /** List of groups the user is assigned to */
  groups?: IamGroup[] | null;
  status?: UserStatusEnum | null;
  /** The date this user was last active */
  last_active_at?: string | null;
  /** The date this user last logged in */
  last_login_at?: string | null;
  /** The date the user was created */
  created_at?: string | null;
  /** The date the user was created */
  updated_at?: string | null;
  /** The list of Multi-Factor Authentication (MFA) types enabled for the user. */
  multi_factor_enabled?: IamMfaTypeEnum[] | null;
  /** The user's avatar data. This generally contains a URL within this property's 'contents' array. */
  avatar?: File | null;
}

export interface IamUserResult {
  data: IamUser;
  raw?: RawResponse[] | null;
}

export interface IamUsersPaginated {
  next_page?: string | null;
  next?: string | null;
  data: IamUser[];
  raw?: RawResponse[] | null;
}

export interface InternalServerErrorResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface NotFoundResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface NotImplementedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface PreconditionFailedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface ProviderError {
  /** HTTP status code of the provider error */
  status?: number | null;
  /** URL that caused the error */
  url?: string | null;
  /** Raw error response from the provider */
  raw?: Record<string, unknown> | null;
  /** Response headers */
  headers?: Record<string, unknown> | null;
}

export interface RawResponse {
  method: string;
  url: string;
  body?: (string | Record<string, unknown> | number[]) | null;
  response?: (Record<string, unknown> | unknown[] | string) | null;
}

export interface RequestTimedOutResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface RoleTypeEnum {
  value?:
    | 'admin'
    | 'viewer'
    | 'editor'
    | 'basic'
    | 'guest'
    | 'unassigned'
    | 'restricted'
    | 'unmapped_value'
    | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface TooManyRequestsResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UnauthorizedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UnifiedError {
  /** HTTP status code */
  statusCode?: number | null;
  /** Error message */
  message?: string | null;
  /** Response headers */
  headers?: Record<string, unknown> | null;
}

export interface UnprocessableEntityResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UpdateResult {
  statusCode: number;
  message: string;
  timestamp: string;
}

export interface UserStatusEnum {
  /** The status of the user, e.g. whether the user is enabled, has been disabled (eg. by an admin), or is pending (ie: awaiting approval by the user or an admin). */
  value?: 'enabled' | 'disabled' | 'pending' | 'unmapped_value' | null;
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

// ============================================================
// Client Class
// ============================================================

export interface IamListUsersParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
}

export interface IamGetUserParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
}

export interface IamDeleteUserParams {
  id: string;
}

export interface IamUpdateUserParams {
  id: string;
  body: IamUpdateUserRequestDto;
}

export interface IamListRolesParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
}

export interface IamGetRoleParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
}

export interface IamListGroupsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
}

export interface IamGetGroupParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
}

export interface IamListPoliciesParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
}

export interface IamGetPolicyParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** The comma separated list of fields that will be expanded in the response */
  expand?: string | null;
}

/**
 * Iam API Client
 * Auto-generated from OpenAPI specification
 */
export class IamClient {
  private baseUrl: string;
  private headers: Record<string, string>;

  constructor(config: StackOneClientConfig) {
    this.baseUrl = config.baseUrl || 'https://api.stackone.com';
    const authToken = Buffer.from(`${config.apiKey}:`).toString('base64');
    this.headers = {
      Authorization: `Basic ${authToken}`,
      'x-account-id': config.accountId,
      ...config.headers,
    };
  }

  /**
   * List Users
   */
  async listUsers(params?: IamListUsersParams): Promise<IamUsersPaginated> {
    let url = `${this.baseUrl}/unified/iam/users`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (params?.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params?.expand))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<IamUsersPaginated>;
  }

  /**
   * Get User
   */
  async getUser(params: IamGetUserParams): Promise<IamUserResult> {
    let url = `${this.baseUrl}/unified/iam/users/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params.expand))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<IamUserResult>;
  }

  /**
   * Delete User
   */
  async deleteUser(params: IamDeleteUserParams): Promise<DeleteResult> {
    const url = `${this.baseUrl}/unified/iam/users/${params.id}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'DELETE',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<DeleteResult>;
  }

  /**
   * Update User
   */
  async updateUser(params: IamUpdateUserParams): Promise<UpdateResult> {
    const url = `${this.baseUrl}/unified/iam/users/${params.id}`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PATCH',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UpdateResult>;
  }

  /**
   * List Roles
   */
  async listRoles(params?: IamListRolesParams): Promise<IamRolesPaginated> {
    let url = `${this.baseUrl}/unified/iam/roles`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (params?.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params?.expand))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<IamRolesPaginated>;
  }

  /**
   * Get Role
   */
  async getRole(params: IamGetRoleParams): Promise<IamRoleResult> {
    let url = `${this.baseUrl}/unified/iam/roles/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params.expand))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<IamRoleResult>;
  }

  /**
   * List Groups
   */
  async listGroups(params?: IamListGroupsParams): Promise<IamGroupsPaginated> {
    let url = `${this.baseUrl}/unified/iam/groups`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (params?.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params?.expand))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<IamGroupsPaginated>;
  }

  /**
   * Get Group
   */
  async getGroup(params: IamGetGroupParams): Promise<IamGroupResult> {
    let url = `${this.baseUrl}/unified/iam/groups/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params.expand))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<IamGroupResult>;
  }

  /**
   * List Policies
   */
  async listPolicies(params?: IamListPoliciesParams): Promise<IamPoliciesPaginated> {
    let url = `${this.baseUrl}/unified/iam/policies`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (params?.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params?.expand))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<IamPoliciesPaginated>;
  }

  /**
   * Get Policy
   */
  async getPolicy(params: IamGetPolicyParams): Promise<IamPolicyResult> {
    let url = `${this.baseUrl}/unified/iam/policies/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.expand !== undefined) {
      queryParts.push(`expand=${encodeURIComponent(String(params.expand))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<IamPolicyResult>;
  }
}
