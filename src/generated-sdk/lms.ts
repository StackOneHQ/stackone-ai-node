// Auto-generated TypeScript SDK from OpenAPI specification
// DO NOT EDIT THIS FILE DIRECTLY

import type { StackOneClientConfig } from './types';

// ============================================================
// Type Definitions
// ============================================================

// Auto-generated TypeScript interfaces from OpenAPI schemas
// DO NOT EDIT THIS FILE DIRECTLY

export interface AdditionalData {
  /** The name of the additional data field. Speak to your Solutions Engineer to understand the id for the specific use case */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The value of the additional data */
  value?: (string | string[]) | null;
}

export interface Assignment {
  /** The ID associated with this assignment */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The external reference associated with this assignment */
  external_reference?: string | null;
  /** The learning_object_id associated with this assignment. This is not required unless specified in an integration. */
  learning_object_id?: string | null;
  /** Provider's unique identifier of the learning object related to the assignment */
  remote_learning_object_id?: string | null;
  /** The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments. */
  learning_object_external_reference?: string | null;
  /** The progress associated with this assigment */
  progress?: number | null;
  /** The date the assignment was last updated */
  updated_at?: string | null;
  /** The date the assignment was created */
  created_at?: string | null;
  /** The date the assignment is due to be completed */
  due_date?: string | null;
  /** The status of the assignment */
  status?: AssignmentStatusEnum | null;
  /** The learning object type of the assignment */
  learning_object_type?: LearningObjectTypeEnum | null;
  /** The user ID associated with this assignment */
  user_id?: string | null;
  /** Provider's unique identifier of the user related to the assignment */
  remote_user_id?: string | null;
  /** The certification URL associated with this assignment */
  certificate_url?: string | null;
  /** The result of the assignment */
  result?: ResultStatusEnum | null;
  /** The date the content was completed */
  completed_at?: string | null;
  /** The course ID associated with this assignment */
  course_id?: string | null;
  /** Provider's unique identifier of the course related to the assignment */
  remote_course_id?: string | null;
}

export interface AssignmentResult {
  data: Assignment;
  raw?: RawResponse[] | null;
}

export interface AssignmentsPaginated {
  next?: string | null;
  data: Assignment[];
  raw?: RawResponse[] | null;
}

export interface AssignmentStatusEnum {
  /** The StackOne unified assignment status. */
  value?: 'pending' | 'in_progress' | 'completed' | 'unmapped_value' | null;
  /** The original status value from the provider before normalization. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface AuthorModel {
  /** The ID of the author */
  id?: string | null;
  /** The name of the author */
  name?: string | null;
}

export interface BadGatewayResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface BadRequestResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
  /** Error details */
  data?: UnifiedError | null;
  /** List of provider-specific errors */
  provider_errors?: ProviderError[] | null;
}

export interface BatchResultApiModel {
  statusCode?: number | null;
  message?: string | null;
  timestamp?: string | null;
  errors?: string[][] | null;
}

export interface CategoriesPaginated {
  next?: string | null;
  data: Category[];
  raw?: RawResponse[] | null;
}

export interface Category {
  /** The ID associated with this category */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The name associated with this category */
  name?: string | null;
  /** Whether the category is active and therefore available for use */
  active?: (boolean | 'true' | 'false') | null;
  /** The hierarchal level of the category */
  hierarchy?: CategoryLevelEnumModel | null;
  /** The hierarchal level of the category */
  level?: CategoryLevelEnumModel | null;
  /** The language associated with this category */
  language?: LanguageEnum | null;
}

export interface CategoryLevelEnumModel {
  /** The unified category level. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead. */
  value?: 'primary' | 'secondary' | 'tertiary' | 'unmapped_value' | null;
  /** For read operations: the original category level from the provider. For write operations: fallback value used when value is omitted or "unmapped_value". You must ensure this matches the provider's format. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface CategoryResult {
  data: Category;
  raw?: RawResponse[] | null;
}

export interface Completion {
  /** The ID associated with this completion */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The external reference of the learning object associated with this completion, this is the main identifier for creating completions. */
  learning_object_external_reference?: string | null;
  /** The external reference associated with this completion */
  external_reference?: string | null;
  /** The result of the completion */
  result?: ResultStatusEnum | null;
  /** The date the content was completed */
  completed_at?: string | null;
  /** The created date of the completion */
  created_at?: string | null;
  /** The updated date of the completion */
  updated_at?: string | null;
  /** The learning object type of the completion */
  learning_object_type?: LearningObjectTypeEnum | null;
  /** The id of the learning object associated with this completion. This is not required unless specified in an integration. */
  learning_object_id?: string | null;
  /** Provider's unique identifier of the learning object related to the completion */
  remote_learning_object_id?: string | null;
  /** The user ID associated with this completion */
  user_id?: string | null;
  /** Provider's unique identifier of the user related to the completion */
  remote_user_id?: string | null;
  /** ISO 8601 duration format representing the time spent on completing the learning object */
  time_spent?: string | null;
  /** The certification URL associated with this completion */
  certificate_url?: string | null;
  /** The external ID associated with this completion */
  external_id?: string | null;
  /** The external reference associated with this content */
  content_external_reference?: string | null;
  /** Provider's unique identifier of the content external reference */
  remote_external_id?: string | null;
  /** The content ID associated with this completion */
  content_id?: string | null;
  /** Provider's unique identifier of the content associated with the completion */
  remote_content_id?: string | null;
  /** The course ID associated with this completion */
  course_id?: string | null;
  /** Provider's unique identifier of the course associated with the completion */
  remote_course_id?: string | null;
}

export interface CompletionResult {
  data: Completion;
  raw?: RawResponse[] | null;
}

export interface CompletionsPaginated {
  next?: string | null;
  data: Completion[];
  raw?: RawResponse[] | null;
}

export interface ConflictResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface Content {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The external ID associated with this content */
  external_reference?: string | null;
  /** The parent ID/IDs associated with this content */
  course_ids?: string[] | null;
  /** Provider's unique identifier of the parent course ID associated with this content */
  remote_course_ids?: string[] | null;
  /** The title of the content */
  title?: string | null;
  /** The description of the content */
  description?: string | null;
  /** The languages associated with this content */
  languages?: LanguageEnum[] | null;
  /** The external URL of the content */
  content_url?: string | null;
  /** The mobile friendly URL of the content */
  mobile_launch_content_url?: string | null;
  /** The type of content */
  content_type?: ContentTypeEnum | null;
  /** The URL of the thumbnail image associated with the content. */
  cover_url?: string | null;
  /** Whether the content is active and available for users. */
  active?: (boolean | 'true' | 'false') | null;
  /** The duration of the content following the ISO8601 standard. If duration_unit is applicable we will derive this from the smallest unit given in the duration string or the minimum unit accepted by the provider. */
  duration?: string | null;
  /** The categories associated with this content */
  categories?: Category[] | null;
  /** The skills associated with this course */
  skills?: Skills[] | null;
  /** The order of the individual content within a content grouping. This is not applicable for pushing individual content. */
  order?: number | null;
  /** The name of the content provider */
  provider?: string | null;
  /** A short description or summary for the content */
  short_description?: string | null;
  /** Localised content information */
  localizations?: LocalizationModel[] | null;
  /** A list of tags associated with the content */
  tags?: string[] | null;
  /** The authors of the content */
  authors?: AuthorModel[] | null;
  /** The date on which the content was last updated. */
  updated_at?: string | null;
  /** The date on which the content was created. */
  created_at?: string | null;
}

export interface ContentPaginated {
  next_page?: string | null;
  next?: string | null;
  total?: number | null;
  data: Content[];
  raw?: RawResponse[] | null;
}

export interface ContentResult {
  data: Content;
  raw?: RawResponse[] | null;
}

export interface ContentTypeEnum {
  /** The StackOne unified content type. */
  value?: 'video' | 'quiz' | 'document' | 'audio' | 'article' | 'unmapped_value' | null;
  /** The original value from the provider before normalization. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface Course {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The external ID associated with this course */
  external_reference?: string | null;
  /** The child ID/IDs associated with this course */
  content_ids?: string[] | null;
  /** Provider's unique identifier of the child content IDs associated with this course */
  remote_content_ids?: string[] | null;
  /** The title of the course */
  title?: string | null;
  /** The description of the course */
  description?: string | null;
  /** The languages associated with this course */
  languages?: LanguageEnum[] | null;
  /** The URL of the thumbnail image associated with the course. */
  cover_url?: string | null;
  /** The redirect URL of the course. */
  url?: string | null;
  /** Whether the course is active and available for users. */
  active?: (boolean | 'true' | 'false') | null;
  /** The duration of the course following the ISO8601 standard. If duration_unit is applicable we will derive this from the smallest unit given in the duration string */
  duration?: string | null;
  /** The categories associated with this course */
  categories?: Category[] | null;
  /** The skills associated with this course */
  skills?: Skills[] | null;
  /** The name of the course provider */
  provider?: string | null;
  /** The authors of the course */
  authors?: AuthorModel[] | null;
  /** The date on which the course was last updated. */
  updated_at?: string | null;
  /** The date on which the course was created. */
  created_at?: string | null;
}

export interface CoursePaginated {
  next_page?: string | null;
  next?: string | null;
  total?: number | null;
  data: Course[];
  raw?: RawResponse[] | null;
}

export interface CourseResult {
  data: Course;
  raw?: RawResponse[] | null;
}

export interface CreateCategoriesApiModel {
  /** The ID associated with this category */
  id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The name associated with this category */
  name?: string | null;
  /** The hierarchal level of the category */
  hierarchy?: CategoryLevelEnumModel | null;
  /** The hierarchal level of the category */
  level?: CategoryLevelEnumModel | null;
  /** The language associated with this category */
  language?: LanguageEnum | null;
}

export interface CreateResult {
  statusCode: number;
  message: string;
  timestamp: string;
  data: CreateResultDataApiModel;
}

export interface CreateResultDataApiModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
}

export interface CreateSkillsApiModel {
  /** The ID associated with this skill */
  id?: string | null;
  /** The name associated with this skill */
  name?: string | null;
  /** The hierarchal level of the skill */
  hierarchy?: SkillLevelEnum | null;
  /** The language associated with this skill */
  language?: LanguageEnum | null;
  /** The hierarchal level of the skill */
  level?: SkillLevelEnum | null;
}

export interface DeleteResult {
  statusCode: number;
  message: string;
  timestamp: string;
}

export interface ForbiddenResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface InternalServerErrorResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface LanguageEnum {
  /** The unified locale code. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead. */
  value?:
    | 'ar_AR'
    | 'aa_ER'
    | 'af_NA'
    | 'af_ZA'
    | 'am_ET'
    | 'ar_AE'
    | 'ar_BH'
    | 'ar_DJ'
    | 'ar_DZ'
    | 'ar_EG'
    | 'ar_ER'
    | 'ar_IQ'
    | 'ar_JO'
    | 'ar_KM'
    | 'ar_KW'
    | 'ar_LB'
    | 'ar_LY'
    | 'ar_MA'
    | 'ar_MR'
    | 'ar_OM'
    | 'ar_PS'
    | 'ar_QA'
    | 'ar_SA'
    | 'ar_SD'
    | 'ar_SY'
    | 'ar_TD'
    | 'ar_TN'
    | 'ar_YE'
    | 'ay_BO'
    | 'ay_PE'
    | 'az_AZ'
    | 'az_IR'
    | 'be_BY'
    | 'bg_BG'
    | 'bi_VU'
    | 'bn_BD'
    | 'bn_IN'
    | 'bs_BA'
    | 'bs-ME'
    | 'byn_ER'
    | 'ca_AD'
    | 'ca_ES'
    | 'ca_FR'
    | 'ca_IT'
    | 'ch_GU'
    | 'cs_CZ'
    | 'da_DK'
    | 'de_AT'
    | 'de_BE'
    | 'de_CH'
    | 'de_DE'
    | 'de_LI'
    | 'de_LU'
    | 'de_VA'
    | 'de_MV'
    | 'dv_MV'
    | 'dz_BT'
    | 'el_CY'
    | 'el_GR'
    | 'en_AG'
    | 'en_AI'
    | 'en_AS'
    | 'en_AU'
    | 'en_BB'
    | 'en_BE'
    | 'en_BM'
    | 'en_BS'
    | 'en_BW'
    | 'en_BZ'
    | 'en_CA'
    | 'en_CC'
    | 'en_CK'
    | 'en_CM'
    | 'en_CW'
    | 'en_CX'
    | 'en_DG'
    | 'en_DM'
    | 'en_ER'
    | 'en_FJ'
    | 'en_FK'
    | 'en_FM'
    | 'en_GB'
    | 'en_GD'
    | 'en_GG'
    | 'en_GH'
    | 'en_GI'
    | 'en_GM'
    | 'en_GS'
    | 'en_GU'
    | 'en_GY'
    | 'en_HK'
    | 'en_IE'
    | 'en_IM'
    | 'en_IN'
    | 'en_IO'
    | 'en_JE'
    | 'en_JM'
    | 'en_KE'
    | 'en_KI'
    | 'en_KN'
    | 'en_KY'
    | 'en_LC'
    | 'en_LR'
    | 'en_LS'
    | 'en_MF'
    | 'en_MG'
    | 'en_MH'
    | 'en_MO'
    | 'en_MP'
    | 'en_MS'
    | 'en_MT'
    | 'en_MU'
    | 'en_MW'
    | 'en_MY'
    | 'en_NA'
    | 'en_NF'
    | 'en_NG'
    | 'en_NL'
    | 'en_NR'
    | 'en_NU'
    | 'en_NZ'
    | 'en_PG'
    | 'en_PH'
    | 'en_PK'
    | 'en_PN'
    | 'en_PR'
    | 'en_PW'
    | 'en_RW'
    | 'en_SB'
    | 'en_SC'
    | 'en_SD'
    | 'en_SG'
    | 'en_SH'
    | 'en_SL'
    | 'en_SS'
    | 'en_SX'
    | 'en_SZ'
    | 'en_TC'
    | 'en_TK'
    | 'en_TO'
    | 'en_TT'
    | 'en_TV'
    | 'en_TZ'
    | 'en_UG'
    | 'en_UM'
    | 'en_US'
    | 'en_VC'
    | 'en_VG'
    | 'en_VI'
    | 'en_VU'
    | 'en_WS'
    | 'en_ZA'
    | 'en_ZM'
    | 'en_ZW'
    | 'es_AR'
    | 'es_BO'
    | 'es_BZ'
    | 'es_CL'
    | 'es_CO'
    | 'es_CR'
    | 'es_CU'
    | 'es_DO'
    | 'es_EA'
    | 'es_EC'
    | 'es_EH'
    | 'es_ES'
    | 'es_GQ'
    | 'es_GT'
    | 'es_HN'
    | 'es_IC'
    | 'es_LA'
    | 'es_MX'
    | 'es_NI'
    | 'es_PA'
    | 'es_PE'
    | 'es_PH'
    | 'es_PR'
    | 'es_PY'
    | 'es_SV'
    | 'es_US'
    | 'es_UY'
    | 'es_VE'
    | 'et_EE'
    | 'fa_AF'
    | 'fa_IR'
    | 'fan_GA'
    | 'ff_CM'
    | 'ff_GN'
    | 'ff_MR'
    | 'ff_SN'
    | 'ff_BF'
    | 'fi_FI'
    | 'fj_FJ'
    | 'fo_FO'
    | 'fr_BE'
    | 'fr_BF'
    | 'fr_BI'
    | 'fr_BJ'
    | 'fr_BL'
    | 'fr_CA'
    | 'fr_CD'
    | 'fr_CF'
    | 'fr_CG'
    | 'fr_CH'
    | 'fr_CI'
    | 'fr_CM'
    | 'fr_DJ'
    | 'fr_DZ'
    | 'fr_FR'
    | 'fr_GA'
    | 'fr_GF'
    | 'fr_GG'
    | 'fr_GN'
    | 'fr_GP'
    | 'fr_GQ'
    | 'fr_HT'
    | 'fr_KM'
    | 'fr_JE'
    | 'fr_LU'
    | 'fr_LB'
    | 'fr_MA'
    | 'fr_MC'
    | 'fr_MF'
    | 'fr_MG'
    | 'fr_ML'
    | 'fr_MQ'
    | 'fr_MR'
    | 'fr_MU'
    | 'fr_NC'
    | 'fr_NE'
    | 'fr_PF'
    | 'fr_PM'
    | 'fr_RE'
    | 'fr_RW'
    | 'fr_SC'
    | 'fr_SN'
    | 'fr_SY'
    | 'fr_TD'
    | 'fr_TF'
    | 'fr_TG'
    | 'fr_TN'
    | 'fr_VU'
    | 'fr_VA'
    | 'fr_WF'
    | 'fr_YT'
    | 'ga_IE'
    | 'gn_PY'
    | 'gn_AR'
    | 'gu_IN'
    | 'gv_IM'
    | 'he_IL'
    | 'hi_IN'
    | 'hr_BA'
    | 'hr_HR'
    | 'hr_ME'
    | 'ht_HT'
    | 'hu_HU'
    | 'hy_AM'
    | 'hy_CY'
    | 'id_ID'
    | 'is_IS'
    | 'it_CH'
    | 'it_IT'
    | 'it_SM'
    | 'it_VA'
    | 'ja_JP'
    | 'ka_GE'
    | 'kg_CD'
    | 'kk_KZ'
    | 'kl_GL'
    | 'km_KH'
    | 'ko_KP'
    | 'ko_KR'
    | 'ku_IQ'
    | 'ky_KG'
    | 'la_VA'
    | 'lb_LU'
    | 'ln_AO'
    | 'ln_CD'
    | 'ln_CF'
    | 'ln_CG'
    | 'lo_LA'
    | 'lt_LT'
    | 'lu_CD'
    | 'lv_LV'
    | 'mg_MG'
    | 'mh_MH'
    | 'mi_NZ'
    | 'mk_MK'
    | 'mn_MN'
    | 'mr_IN'
    | 'ms_BN'
    | 'ms_MY'
    | 'ms_SG'
    | 'mt_MT'
    | 'my_MM'
    | 'nb_NO'
    | 'nb_BV'
    | 'nb_ZW'
    | 'ne_NP'
    | 'nl_AW'
    | 'nl_BE'
    | 'nl_BQ'
    | 'nl_CW'
    | 'nl_NL'
    | 'nl_SR'
    | 'nl_SX'
    | 'nl_MF'
    | 'nn_NO'
    | 'nn_BV'
    | 'no_NO'
    | 'no_BV'
    | 'no_SJ'
    | 'nr_ZA'
    | 'ny_MW'
    | 'pa_IN'
    | 'pa_PK'
    | 'pl_PL'
    | 'ps_AF'
    | 'pt_AO'
    | 'pt_BR'
    | 'pt_CH'
    | 'pt_CV'
    | 'pt_GQ'
    | 'pt_GW'
    | 'pt_LU'
    | 'pt_MO'
    | 'pt_MZ'
    | 'pt_PT'
    | 'pt_ST'
    | 'pt_TL'
    | 'qu_BO'
    | 'qu_EC'
    | 'qu_PE'
    | 'rar_CK'
    | 'rm_CH'
    | 'rup_MK'
    | 'ro_MD'
    | 'ro_RO'
    | 'ru_BY'
    | 'ru_KG'
    | 'ru_KZ'
    | 'ru_MD'
    | 'ru_RU'
    | 'ru_UA'
    | 'ru_AQ'
    | 'ru_TJ'
    | 'ru_TM'
    | 'ru_UZ'
    | 'rw_RW'
    | 'se_SE'
    | 'sg_CF'
    | 'si_LK'
    | 'sk_SK'
    | 'sl_SI'
    | 'sm_AS'
    | 'sm_WS'
    | 'sn_ZW'
    | 'so_DJ'
    | 'so_ET'
    | 'so_KE'
    | 'so_SO'
    | 'sq_AL'
    | 'sq_ME'
    | 'sq_XK'
    | 'sr_BA'
    | 'sr_ME'
    | 'sr_RS'
    | 'sr_XK'
    | 'ss_SZ'
    | 'ss_ZA'
    | 'sv_AX'
    | 'sv_FI'
    | 'sv_SE'
    | 'sw_KE'
    | 'sw_TZ'
    | 'sw_UG'
    | 'sw_CD'
    | 'ta_IN'
    | 'ta_MY'
    | 'ta_SG'
    | 'ta_LK'
    | 'te_IN'
    | 'tg_TJ'
    | 'th_TH'
    | 'ti_ER'
    | 'ti_ET'
    | 'tig_ER'
    | 'tk_TM'
    | 'tk_AF'
    | 'tn_BW'
    | 'tn_ZA'
    | 'to_TO'
    | 'tr_CY'
    | 'tr_TR'
    | 'ts_ZA'
    | 'uk_UA'
    | 'ur_IN'
    | 'ur_PK'
    | 'uz_AF'
    | 'uz_UZ'
    | 've_ZA'
    | 'vi_VN'
    | 'xh_ZA'
    | 'zh_CN'
    | 'zh_HK'
    | 'zh_MO'
    | 'zh_SG'
    | 'zh_TW'
    | 'zu_ZA'
    | 'unmapped_value'
    | null;
  /** For read operations: the original language code from the provider. For write operations: fallback value used when value is omitted or "unmapped_value". You must ensure this matches the provider's format. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface LearningObjectTypeEnum {
  /** The StackOne unified learning object type. */
  value?: 'content' | 'course' | 'collection' | 'unmapped_value' | null;
  /** The original learning object type from the provider before normalization. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface LmsBatchUpsertContentRequestDto {
  /** The batch of items to upsert */
  items: LmsUpsertContentRequestDto[];
}

export interface LmsCreateAssignmentRequestDto {
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
  /** The external reference associated with this assignment */
  external_reference?: string | null;
  /** The learning_object_id associated with this assignment. This is not required unless specified in an integration. */
  learning_object_id?: string | null;
  /** The progress associated with this assigment */
  progress?: number | null;
  /** The date the assignment was created */
  created_at?: string | null;
  /** The date the assignment is due to be completed */
  due_date?: string | null;
  /** The status of the assignment */
  status?: AssignmentStatusEnum | null;
  /** The external reference of the learning object associated with this assignment, this is the main identifier for creating assignments. */
  learning_object_external_reference: string;
}

export interface LmsCreateCompletionRequestDto {
  /** Value to pass through to the provider */
  passthrough?: Record<string, unknown> | null;
  /** The result of the completion */
  result?: ResultStatusEnum | null;
  /** The date the content was completed */
  completed_at?: string | null;
  /** The id of the learning object associated with this completion. This is not required unless specified in an integration. */
  learning_object_id?: string | null;
  /** ISO 8601 duration format representing the time spent on completing the learning object */
  time_spent?: string | null;
  /** The external reference associated with this content */
  content_external_reference?: string | null;
  /** The content ID associated with this completion */
  content_id?: string | null;
  /** The external reference of the learning object associated with this completion, this is the main identifier for creating completions. */
  learning_object_external_reference: string;
}

export interface LmsCreateContentRequestDto {
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The title of the content */
  title?: string | null;
  /** The description of the content */
  description?: string | null;
  /** The languages associated with this content */
  languages?: LanguageEnum[] | null;
  /** The external URL of the content */
  content_url?: string | null;
  /** The mobile friendly URL of the content */
  mobile_launch_content_url?: string | null;
  /** The type of content */
  content_type?: WriteContentTypeEnum | null;
  /** The URL of the thumbnail image associated with the content. */
  cover_url?: string | null;
  /** Whether the content is active and available for users. */
  active?: (boolean | 'true' | 'false') | null;
  /** The duration of the content following the ISO8601 standard. If duration_unit is applicable we will derive this from the smallest unit given in the duration string or the minimum unit accepted by the provider. */
  duration?: string | null;
  /** The skills associated with this content */
  skills?: CreateSkillsApiModel[] | null;
  /** The order of the individual content within a content grouping. This is not applicable for pushing individual content. */
  order?: number | null;
  /** A short description or summary for the content */
  short_description?: string | null;
  /** The localization data for this content */
  localizations?: LocalizationModel[] | null;
  /** A list of tags associated with the content */
  tags?: string[] | null;
  /** The authors of the content */
  authors?: AuthorModel[] | null;
  /** The date on which the content was last updated. */
  updated_at?: string | null;
  /** The date on which the content was created. */
  created_at?: string | null;
  /** The external ID associated with this content */
  external_reference: string;
  /** The categories associated with this content */
  categories?: CreateCategoriesApiModel[] | null;
  /** The additional_data associated with this content */
  additional_data?: AdditionalData[] | null;
}

export interface LmsUpsertContentRequestDto {
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The title of the content */
  title?: string | null;
  /** The description of the content */
  description?: string | null;
  /** The languages associated with this content */
  languages?: LanguageEnum[] | null;
  /** The external URL of the content */
  content_url?: string | null;
  /** The mobile friendly URL of the content */
  mobile_launch_content_url?: string | null;
  /** The URL of the thumbnail image associated with the content. */
  cover_url?: string | null;
  /** Whether the content is active and available for users. */
  active?: (boolean | 'true' | 'false') | null;
  /** The duration of the content following the ISO8601 standard. If duration_unit is applicable we will derive this from the smallest unit given in the duration string or the minimum unit accepted by the provider. */
  duration?: string | null;
  /** The skills associated with this content */
  skills?: CreateSkillsApiModel[] | null;
  /** The order of the individual content within a content grouping. This is not applicable for pushing individual content. */
  order?: number | null;
  /** A short description or summary for the content */
  short_description?: string | null;
  /** The localization data for this course */
  localizations?: LocalizationModel[] | null;
  /** A list of tags associated with the content */
  tags?: string[] | null;
  /** The authors of the content */
  authors?: AuthorModel[] | null;
  /** The date on which the content was last updated. */
  updated_at?: string | null;
  /** The date on which the content was created. */
  created_at?: string | null;
  /** The external ID associated with this content */
  external_reference: string;
  /** The categories associated with this content */
  categories?: CreateCategoriesApiModel[] | null;
  /** The additional_data associated with this content */
  additional_data?: AdditionalData[] | null;
  /** The type of content */
  content_type?: WriteContentTypeEnum | null;
}

export interface LmsUser {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** Custom Unified Fields configured in your StackOne project */
  unified_custom_fields?: Record<string, unknown> | null;
  /** The external ID associated with this user */
  external_reference?: string | null;
  /** The user name */
  name?: string | null;
  /** The user email */
  email?: string | null;
  /** The user phone number */
  phone_number?: string | null;
  /** The user active status */
  active?: (boolean | 'true' | 'false') | null;
  /** The created_at date */
  created_at?: string | null;
  /** The updated_at date */
  updated_at?: string | null;
}

export interface LocalizationModel {
  /** The title of the content */
  title?: string | null;
  /** The description of the content */
  description?: string | null;
  /** The language associated with the localization details */
  language?: LanguageEnum | null;
  /** The tags associated with the localization details */
  tags?: string[] | null;
}

export interface NotFoundResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface NotImplementedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface PreconditionFailedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface ProviderError {
  /** HTTP status code of the provider error */
  status?: number | null;
  /** URL that caused the error */
  url?: string | null;
  /** Raw error response from the provider */
  raw?: Record<string, unknown> | null;
  /** Response headers */
  headers?: Record<string, unknown> | null;
}

export interface RawResponse {
  method: string;
  url: string;
  body?: (string | Record<string, unknown> | number[]) | null;
  response?: (Record<string, unknown> | unknown[] | string) | null;
}

export interface RequestTimedOutResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface ResultStatusEnum {
  /** The StackOne unified result status. */
  value?: 'Pass' | 'Fail' | 'unmapped_value' | null;
  /** The original result status from the provider before normalization. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface SkillLevelEnum {
  /** The unified skill level. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead. */
  value?: 'primary' | 'secondary' | 'tertiary' | 'unmapped_value' | null;
  /** For read operations: the original skill level from the provider. For write operations: fallback value used when value is omitted or "unmapped_value". You must ensure this matches the provider's format. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

export interface SkillResult {
  data: Skills;
  raw?: RawResponse[] | null;
}

export interface Skills {
  /** The ID associated with this skill */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The name associated with this skill */
  name?: string | null;
  /** Whether the skill is active and therefore available for use */
  active?: (boolean | 'true' | 'false') | null;
  /** The hierarchal level of the skill */
  hierarchy?: SkillLevelEnum | null;
  /** The language associated with this skill */
  language?: LanguageEnum | null;
  /** The hierarchal level of the skill */
  level?: SkillLevelEnum | null;
}

export interface SkillsPaginated {
  next?: string | null;
  data: Skills[];
  raw?: RawResponse[] | null;
}

export interface TooManyRequestsResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UnauthorizedResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UnifiedError {
  /** HTTP status code */
  statusCode?: number | null;
  /** Error message */
  message?: string | null;
  /** Response headers */
  headers?: Record<string, unknown> | null;
}

export interface UnprocessableEntityResponse {
  /** HTTP status code */
  statusCode: number;
  /** Error message */
  message: string;
  /** Timestamp when the error occurred */
  timestamp: string;
}

export interface UpdateResult {
  statusCode: number;
  message: string;
  timestamp: string;
}

export interface UpsertResult {
  statusCode: number;
  message: string;
  timestamp: string;
  data: UpsertResultDataExternalReferenceModel;
}

export interface UpsertResultDataExternalReferenceModel {
  /** Unique identifier */
  id?: string | null;
  /** Provider's unique identifier */
  remote_id?: string | null;
  /** The external identifier */
  external_reference?: string | null;
}

export interface UserResult {
  data: LmsUser;
  raw?: RawResponse[] | null;
}

export interface UsersPaginated {
  next?: string | null;
  data: LmsUser[];
  raw?: RawResponse[] | null;
}

export interface WriteContentTypeEnum {
  /** The content type for write operations. Provide one of the listed enum values. If omitted or set to "unmapped_value", the source_value will be sent to the provider instead. */
  value?:
    | 'video'
    | 'quiz'
    | 'document'
    | 'audio'
    | 'article'
    | 'book'
    | 'event'
    | 'course'
    | 'collection'
    | 'interactive'
    | 'unmapped_value'
    | null;
  /** The provider-specific value to use when value is omitted or set to "unmapped_value". You are responsible for ensuring this matches the provider's expected format. */
  source_value?: (string | number | boolean | Record<string, unknown> | unknown[]) | null;
}

// ============================================================
// Client Class
// ============================================================

export interface LmsListCoursesParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** LMS Courses Filter */
  filter?: {
    updated_after?: string | null;
    external_reference?: string | null;
    active?: (boolean | string) | null;
  } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface LmsGetCourseParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface LmsListUserAssignmentsParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** LMS Assignment Filter */
  filter?: {
    updated_after?: string | null;
    status?: 'pending' | 'in_progress' | 'completed' | 'unmapped_value' | null;
  } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** The user ID associated with this assignment */
  userId?: string | null;
  /** Provider's unique identifier of the user related to the assignment */
  remoteUserId?: string | null;
}

export interface LmsCreateUserAssignmentParams {
  id: string;
  body: LmsCreateAssignmentRequestDto;
}

export interface LmsGetUserAssignmentParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields to return in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface LmsBatchUpsertContentParams {
  body: LmsBatchUpsertContentRequestDto;
}

export interface LmsListContentParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** LMS Courses Filter */
  filter?: { updated_after?: string | null; active?: (boolean | string) | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface LmsUpsertContentParams {
  body: LmsUpsertContentRequestDto;
}

export interface LmsGetContentParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface LmsUpdateContentParams {
  id: string;
  body: LmsCreateContentRequestDto;
}

export interface LmsListUserCompletionsParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** LMS Completions Filter */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface LmsCreateUserCompletionParams {
  id: string;
  body: LmsCreateCompletionRequestDto;
}

export interface LmsGetUserCompletionParams {
  id: string;
  subresourceid: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields to return in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface LmsDeleteUserCompletionParams {
  id: string;
  subresourceid: string;
}

export interface LmsListCompletionsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** LMS Completions Filter */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface LmsGetCompletionParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields to return in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface LmsGetCategoryParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface LmsListCategoriesParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface LmsListUsersParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** LMS Users Filter */
  filter?: {
    updated_after?: string | null;
    email?: string | null;
    external_reference?: string | null;
  } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface LmsGetUserParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface LmsGetSkillParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
}

export interface LmsListSkillsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** Filter parameters that allow greater customisation of the list response */
  filter?: { updated_after?: string | null } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
}

export interface LmsListAssignmentsParams {
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields that will be returned in the response (if empty, all fields are returned) */
  fields?: string | null;
  /** LMS Assignment Filter */
  filter?: {
    updated_after?: string | null;
    status?: 'pending' | 'in_progress' | 'completed' | 'unmapped_value' | null;
  } | null;
  /** The number of results per page (default value is 25) */
  pageSize?: string | null;
  /** The unified cursor */
  next?: string | null;
  /** The user ID associated with this assignment */
  userId?: string | null;
  /** Provider's unique identifier of the user related to the assignment */
  remoteUserId?: string | null;
}

export interface LmsGetAssignmentParams {
  id: string;
  /** Indicates that the raw request result should be returned in addition to the mapped result (default value is false) */
  raw?: boolean | null;
  /** Query parameters that can be used to pass through parameters to the underlying provider request by surrounding them with 'proxy' key */
  proxy?: Record<string, unknown> | null;
  /** The comma separated list of fields to return in the response (if empty, all fields are returned) */
  fields?: string | null;
}

/**
 * Lms API Client
 * Auto-generated from OpenAPI specification
 */
export class LmsClient {
  private baseUrl: string;
  private headers: Record<string, string>;

  constructor(config: StackOneClientConfig) {
    this.baseUrl = config.baseUrl || 'https://api.stackone.com';
    const authToken = Buffer.from(`${config.apiKey}:`).toString('base64');
    this.headers = {
      Authorization: `Basic ${authToken}`,
      'x-account-id': config.accountId,
      ...config.headers,
    };
  }

  /**
   * List Courses
   */
  async listCourses(params?: LmsListCoursesParams): Promise<CoursePaginated> {
    let url = `${this.baseUrl}/unified/lms/courses`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CoursePaginated>;
  }

  /**
   * Get Course
   */
  async getCourse(params: LmsGetCourseParams): Promise<CourseResult> {
    let url = `${this.baseUrl}/unified/lms/courses/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CourseResult>;
  }

  /**
   * List User Assignments
   */
  async listUserAssignments(params: LmsListUserAssignmentsParams): Promise<AssignmentsPaginated> {
    let url = `${this.baseUrl}/unified/lms/users/${params.id}/assignments`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (params.userId !== undefined) {
      queryParts.push(`user_id=${encodeURIComponent(String(params.userId))}`);
    }
    if (params.remoteUserId !== undefined) {
      queryParts.push(`remote_user_id=${encodeURIComponent(String(params.remoteUserId))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<AssignmentsPaginated>;
  }

  /**
   * Create User Assignment
   */
  async createUserAssignment(params: LmsCreateUserAssignmentParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/lms/users/${params.id}/assignments`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get User Assignment
   */
  async getUserAssignment(params: LmsGetUserAssignmentParams): Promise<AssignmentResult> {
    let url = `${this.baseUrl}/unified/lms/users/${params.id}/assignments/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<AssignmentResult>;
  }

  /**
   * Batch Upsert External Linking Learning Objects
   */
  async batchUpsertContent(params: LmsBatchUpsertContentParams): Promise<unknown> {
    const url = `${this.baseUrl}/unified/lms/content/batch`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<unknown>;
  }

  /**
   * List Content
   */
  async listContent(params?: LmsListContentParams): Promise<ContentPaginated> {
    let url = `${this.baseUrl}/unified/lms/content`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ContentPaginated>;
  }

  /**
   * Upsert External Linking Learning Objects
   */
  async upsertContent(params: LmsUpsertContentParams): Promise<UpsertResult> {
    const url = `${this.baseUrl}/unified/lms/content`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PUT',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UpsertResult>;
  }

  /**
   * Get Content
   */
  async getContent(params: LmsGetContentParams): Promise<ContentResult> {
    let url = `${this.baseUrl}/unified/lms/content/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<ContentResult>;
  }

  /**
   * Update External Linking Learning Objects
   */
  async updateContent(params: LmsUpdateContentParams): Promise<UpdateResult> {
    const url = `${this.baseUrl}/unified/lms/content/${params.id}`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'PATCH',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UpdateResult>;
  }

  /**
   * List User Completions
   */
  async listUserCompletions(params: LmsListUserCompletionsParams): Promise<CompletionsPaginated> {
    let url = `${this.baseUrl}/unified/lms/users/${params.id}/completions`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (params.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params.filter))}`);
    }
    if (params.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params.pageSize))}`);
    }
    if (params.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CompletionsPaginated>;
  }

  /**
   * Create User Completion
   */
  async createUserCompletion(params: LmsCreateUserCompletionParams): Promise<CreateResult> {
    const url = `${this.baseUrl}/unified/lms/users/${params.id}/completions`;
    const headers: Record<string, string> = {
      ...this.headers,
      'Content-Type': 'application/json',
    };
    const options: RequestInit = {
      method: 'POST',
      headers,
      body: params.body ? JSON.stringify(params.body) : undefined,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CreateResult>;
  }

  /**
   * Get User Completion
   */
  async getUserCompletion(params: LmsGetUserCompletionParams): Promise<CompletionResult> {
    let url = `${this.baseUrl}/unified/lms/users/${params.id}/completions/${params.subresourceid}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CompletionResult>;
  }

  /**
   * Delete User Completion
   */
  async deleteUserCompletion(params: LmsDeleteUserCompletionParams): Promise<DeleteResult> {
    const url = `${this.baseUrl}/unified/lms/users/${params.id}/completions/${params.subresourceid}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'DELETE',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<DeleteResult>;
  }

  /**
   * List Completions
   */
  async listCompletions(params?: LmsListCompletionsParams): Promise<CompletionsPaginated> {
    let url = `${this.baseUrl}/unified/lms/completions`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CompletionsPaginated>;
  }

  /**
   * Get Completion
   */
  async getCompletion(params: LmsGetCompletionParams): Promise<CompletionResult> {
    let url = `${this.baseUrl}/unified/lms/completions/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CompletionResult>;
  }

  /**
   * Get Category
   */
  async getCategory(params: LmsGetCategoryParams): Promise<CategoryResult> {
    let url = `${this.baseUrl}/unified/lms/categories/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CategoryResult>;
  }

  /**
   * List Categories
   */
  async listCategories(params?: LmsListCategoriesParams): Promise<CategoriesPaginated> {
    let url = `${this.baseUrl}/unified/lms/categories`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<CategoriesPaginated>;
  }

  /**
   * List Users
   */
  async listUsers(params?: LmsListUsersParams): Promise<UsersPaginated> {
    let url = `${this.baseUrl}/unified/lms/users`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UsersPaginated>;
  }

  /**
   * Get User
   */
  async getUser(params: LmsGetUserParams): Promise<UserResult> {
    let url = `${this.baseUrl}/unified/lms/users/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<UserResult>;
  }

  /**
   * Get Skill
   */
  async getSkill(params: LmsGetSkillParams): Promise<SkillResult> {
    let url = `${this.baseUrl}/unified/lms/skills/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<SkillResult>;
  }

  /**
   * List Skills
   */
  async listSkills(params?: LmsListSkillsParams): Promise<SkillsPaginated> {
    let url = `${this.baseUrl}/unified/lms/skills`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<SkillsPaginated>;
  }

  /**
   * List Assignments
   */
  async listAssignments(params?: LmsListAssignmentsParams): Promise<AssignmentsPaginated> {
    let url = `${this.baseUrl}/unified/lms/assignments`;
    const queryParts: string[] = [];
    if (params?.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params?.raw))}`);
    }
    if (params?.proxy !== undefined) {
      for (const [key, value] of Object.entries(params?.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params?.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params?.fields))}`);
    }
    if (params?.filter !== undefined) {
      queryParts.push(`filter=${encodeURIComponent(String(params?.filter))}`);
    }
    if (params?.pageSize !== undefined) {
      queryParts.push(`page_size=${encodeURIComponent(String(params?.pageSize))}`);
    }
    if (params?.next !== undefined) {
      queryParts.push(`next=${encodeURIComponent(String(params?.next))}`);
    }
    if (params?.userId !== undefined) {
      queryParts.push(`user_id=${encodeURIComponent(String(params?.userId))}`);
    }
    if (params?.remoteUserId !== undefined) {
      queryParts.push(`remote_user_id=${encodeURIComponent(String(params?.remoteUserId))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<AssignmentsPaginated>;
  }

  /**
   * Get Assignment
   */
  async getAssignment(params: LmsGetAssignmentParams): Promise<AssignmentResult> {
    let url = `${this.baseUrl}/unified/lms/assignments/${params.id}`;
    const queryParts: string[] = [];
    if (params.raw !== undefined) {
      queryParts.push(`raw=${encodeURIComponent(String(params.raw))}`);
    }
    if (params.proxy !== undefined) {
      for (const [key, value] of Object.entries(params.proxy as Record<string, unknown>)) {
        if (value !== undefined && value !== null) {
          queryParts.push(`proxy[${key}]=${encodeURIComponent(String(value))}`);
        }
      }
    }
    if (params.fields !== undefined) {
      queryParts.push(`fields=${encodeURIComponent(String(params.fields))}`);
    }
    if (queryParts.length > 0) url += `?${queryParts.join('&')}`;
    const headers: Record<string, string> = {
      ...this.headers,
    };
    const options: RequestInit = {
      method: 'GET',
      headers,
    };
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`API error ${response.status}: ${errorBody}`);
    }
    return response.json() as Promise<AssignmentResult>;
  }
}
