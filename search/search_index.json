{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"StackOne AI SDK # Installation # # Using npm npm install @stackone/ai # Using yarn yarn add @stackone/ai # Using bun bun add @stackone/ai Authentication # Set the STACKONE_API_KEY environment variable: export STACKONE_API_KEY = <your-api-key> or load from a .env file: // Load environment variables from .env file import * as dotenv from 'dotenv' ; dotenv . config (); Account IDs # StackOne uses account IDs to identify different integrations. See the example in the README for more details. This example will use the centralized account ID: import { ACCOUNT_IDS } from './constants' ; const accountId = ACCOUNT_IDS . HRIS ; Quickstart # import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const quickstart = async () : Promise < void > => { const toolset = new StackOneToolSet (); // Get all HRIS-related tools using the StackOneTool method (adds accountId to the request) const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Verify we have tools assert ( tools . length > 0 , 'Expected to find HRIS tools' ); // Use a specific tool const employeeTool = tools . getTool ( 'hris_list_employees' ); assert ( employeeTool !== undefined , 'Expected to find hris_list_employees tool' ); // Execute the tool and verify the response const result = await employeeTool . execute (); assert ( Array . isArray ( result . data ), 'Expected employees to be an array' ); assert ( result . data . length > 0 , 'Expected to find at least one employee' ); }; // Run the example quickstart (); Next Steps # Check out some more examples: OpenAI Integration AI SDK Integration Error Handling EXPERIMENTAL: Document Handling Custom Base URL Account ID Usage","title":"Home"},{"location":"#stackone-ai-sdk","text":"","title":"StackOne AI SDK"},{"location":"#installation","text":"# Using npm npm install @stackone/ai # Using yarn yarn add @stackone/ai # Using bun bun add @stackone/ai","title":"Installation"},{"location":"#authentication","text":"Set the STACKONE_API_KEY environment variable: export STACKONE_API_KEY = <your-api-key> or load from a .env file: // Load environment variables from .env file import * as dotenv from 'dotenv' ; dotenv . config ();","title":"Authentication"},{"location":"#account-ids","text":"StackOne uses account IDs to identify different integrations. See the example in the README for more details. This example will use the centralized account ID: import { ACCOUNT_IDS } from './constants' ; const accountId = ACCOUNT_IDS . HRIS ;","title":"Account IDs"},{"location":"#quickstart","text":"import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const quickstart = async () : Promise < void > => { const toolset = new StackOneToolSet (); // Get all HRIS-related tools using the StackOneTool method (adds accountId to the request) const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Verify we have tools assert ( tools . length > 0 , 'Expected to find HRIS tools' ); // Use a specific tool const employeeTool = tools . getTool ( 'hris_list_employees' ); assert ( employeeTool !== undefined , 'Expected to find hris_list_employees tool' ); // Execute the tool and verify the response const result = await employeeTool . execute (); assert ( Array . isArray ( result . data ), 'Expected employees to be an array' ); assert ( result . data . length > 0 , 'Expected to find at least one employee' ); }; // Run the example quickstart ();","title":"Quickstart"},{"location":"#next-steps","text":"Check out some more examples: OpenAI Integration AI SDK Integration Error Handling EXPERIMENTAL: Document Handling Custom Base URL Account ID Usage","title":"Next Steps"},{"location":"account-id-usage/","text":"Account Id Usage # Example demonstrating different ways to set the account ID when using StackOne tools. This example shows: 1. Setting account ID when initializing the toolset 2. Setting account ID when getting tools 3. Using setAccountId method directly on a tool Usage: bun run examples/account-id-usage.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; const accountIdUsage = async () : Promise < void > => { /* * Set account ID on toolset initialization */ const toolset = new StackOneToolSet ({ accountId : ACCOUNT_IDS.TEST.VALID }); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getStackOneTool ( 'hris_list_employees' ); assert ( employeeTool . getAccountId () === ACCOUNT_IDS . TEST . VALID , 'Account ID should match what was set' ); /* * Setting account ID when getting tools (overrides toolset account ID) */ const toolsWithOverride = toolset . getStackOneTools ( 'hris_*' , ACCOUNT_IDS . TEST . OVERRIDE ); const employeeToolWithOverride = toolsWithOverride . getStackOneTool ( 'hris_list_employees' ); assert ( employeeToolWithOverride ? . getAccountId () === ACCOUNT_IDS . TEST . OVERRIDE , 'Account ID should match what was set' ); /* * Set the account ID directly on the tool */ employeeTool . setAccountId ( ACCOUNT_IDS . TEST . DIRECT ); assert ( employeeTool . getAccountId () === ACCOUNT_IDS . TEST . DIRECT , 'Account ID should match what was set' ); }; accountIdUsage ();","title":"Account IDs"},{"location":"account-id-usage/#account-id-usage","text":"Example demonstrating different ways to set the account ID when using StackOne tools. This example shows: 1. Setting account ID when initializing the toolset 2. Setting account ID when getting tools 3. Using setAccountId method directly on a tool Usage: bun run examples/account-id-usage.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; const accountIdUsage = async () : Promise < void > => { /* * Set account ID on toolset initialization */ const toolset = new StackOneToolSet ({ accountId : ACCOUNT_IDS.TEST.VALID }); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getStackOneTool ( 'hris_list_employees' ); assert ( employeeTool . getAccountId () === ACCOUNT_IDS . TEST . VALID , 'Account ID should match what was set' ); /* * Setting account ID when getting tools (overrides toolset account ID) */ const toolsWithOverride = toolset . getStackOneTools ( 'hris_*' , ACCOUNT_IDS . TEST . OVERRIDE ); const employeeToolWithOverride = toolsWithOverride . getStackOneTool ( 'hris_list_employees' ); assert ( employeeToolWithOverride ? . getAccountId () === ACCOUNT_IDS . TEST . OVERRIDE , 'Account ID should match what was set' ); /* * Set the account ID directly on the tool */ employeeTool . setAccountId ( ACCOUNT_IDS . TEST . DIRECT ); assert ( employeeTool . getAccountId () === ACCOUNT_IDS . TEST . DIRECT , 'Account ID should match what was set' ); }; accountIdUsage ();","title":"Account Id Usage"},{"location":"ai-sdk-integration/","text":"Ai Sdk Integration # This example shows how to use StackOne tools with the AI SDK. import assert from 'node:assert' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; const aiSdkIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get HRIS tools const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); // Convert to AI SDK tools const aiSdkTools = tools . toAISDK (); // Use max steps to automatically call the tool if it's needed const { text } = await generateText ({ model : openai ( 'gpt-5' ), tools : aiSdkTools , prompt : 'Get all details about employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , maxSteps : 3 , }); assert ( text . includes ( 'Michael' ), 'Expected employee name to be included in the response' ); }; aiSdkIntegration ();","title":"AI SDK"},{"location":"ai-sdk-integration/#ai-sdk-integration","text":"This example shows how to use StackOne tools with the AI SDK. import assert from 'node:assert' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; const aiSdkIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get HRIS tools const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); // Convert to AI SDK tools const aiSdkTools = tools . toAISDK (); // Use max steps to automatically call the tool if it's needed const { text } = await generateText ({ model : openai ( 'gpt-5' ), tools : aiSdkTools , prompt : 'Get all details about employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , maxSteps : 3 , }); assert ( text . includes ( 'Michael' ), 'Expected employee name to be included in the response' ); }; aiSdkIntegration ();","title":"Ai Sdk Integration"},{"location":"constants/","text":"Constants # Centralized account IDs for StackOne examples These account IDs are organized by vertical and can be reused across examples. Update these values with your actual account IDs for each integration. export const ACCOUNT_IDS = { // Human Resources Information System HRIS : '46132201201510402136' , // Applicant Tracking System ATS : '46132127373317208518' , // Customer Relationship Management CRM : '46132129512514182883' , // Document Management System DOCUMENTS : '46132143471913690795' , TEST : { VALID : 'test_account_id' , OVERRIDE : 'test_account_id_override' , DIRECT : 'test_account_id_direct' , INVALID : 'invalid_test_account_id' , }, } as const ;","title":"Constants"},{"location":"constants/#constants","text":"Centralized account IDs for StackOne examples These account IDs are organized by vertical and can be reused across examples. Update these values with your actual account IDs for each integration. export const ACCOUNT_IDS = { // Human Resources Information System HRIS : '46132201201510402136' , // Applicant Tracking System ATS : '46132127373317208518' , // Customer Relationship Management CRM : '46132129512514182883' , // Document Management System DOCUMENTS : '46132143471913690795' , TEST : { VALID : 'test_account_id' , OVERRIDE : 'test_account_id_override' , DIRECT : 'test_account_id_direct' , INVALID : 'invalid_test_account_id' , }, } as const ;","title":"Constants"},{"location":"custom-base-url/","text":"Custom Base Url # Example demonstrating how to use a custom base URL with StackOne tools. This is useful for: 1. Testing against development APIs 2. Working with self-hosted StackOne instances Usage: bun run examples/custom-base-url.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const customBaseUrl = async () : Promise < void > => { Default base URL const defaultToolset = new StackOneToolSet (); const hrisTools = defaultToolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Should have at least one HRIS tool' ); const defaultTool = hrisTools . getTool ( 'hris_get_employee' ); if ( ! defaultTool ) { throw new Error ( 'Tool not found' ); } Custom base URL const devToolset = new StackOneToolSet ({ baseUrl : 'https://api.example-dev.com' , }); const devHrisTools = devToolset . getTools ( 'hris_*' ); assert ( devHrisTools . length > 0 , 'Should have at least one HRIS tool' ); const devTool = devHrisTools . getTool ( 'hris_get_employee' ); if ( ! devTool ) { throw new Error ( 'Tool not found' ); } Note this uses the same tools but substitutes the base URL if ( defaultTool && devTool ) { assert ( defaultTool . name === devTool . name , 'Tool names should be the same' ); assert ( defaultTool . executeConfig . url . includes ( 'https://api.stackone.com' ), 'Default tool should use the default base URL' ); assert ( devTool . executeConfig . url . includes ( 'https://api.example-dev.com' ), 'Custom tool should use the custom base URL' ); } }; customBaseUrl ();","title":"Custom Base URL"},{"location":"custom-base-url/#custom-base-url","text":"Example demonstrating how to use a custom base URL with StackOne tools. This is useful for: 1. Testing against development APIs 2. Working with self-hosted StackOne instances Usage: bun run examples/custom-base-url.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const customBaseUrl = async () : Promise < void > => { Default base URL const defaultToolset = new StackOneToolSet (); const hrisTools = defaultToolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Should have at least one HRIS tool' ); const defaultTool = hrisTools . getTool ( 'hris_get_employee' ); if ( ! defaultTool ) { throw new Error ( 'Tool not found' ); } Custom base URL const devToolset = new StackOneToolSet ({ baseUrl : 'https://api.example-dev.com' , }); const devHrisTools = devToolset . getTools ( 'hris_*' ); assert ( devHrisTools . length > 0 , 'Should have at least one HRIS tool' ); const devTool = devHrisTools . getTool ( 'hris_get_employee' ); if ( ! devTool ) { throw new Error ( 'Tool not found' ); } Note this uses the same tools but substitutes the base URL if ( defaultTool && devTool ) { assert ( defaultTool . name === devTool . name , 'Tool names should be the same' ); assert ( defaultTool . executeConfig . url . includes ( 'https://api.stackone.com' ), 'Default tool should use the default base URL' ); assert ( devTool . executeConfig . url . includes ( 'https://api.example-dev.com' ), 'Custom tool should use the custom base URL' ); } }; customBaseUrl ();","title":"Custom Base Url"},{"location":"error-handling/","text":"Error Handling # Error Handling # This example shows how to handle errors when using the StackOne SDK. import assert from 'node:assert' ; import { StackOneAPIError , StackOneError , StackOneToolSet , ToolSetConfigError } from '../src' ; import { ACCOUNT_IDS } from './constants' ; const errorHandling = async () : Promise < void > => { // Example 1: Handle initialization errors const testInitializationErrors = async () : Promise < void > => { // Temporarily save the API key const originalKey = process . env . STACKONE_API_KEY ; // Delete the API key to force an error process . env . STACKONE_API_KEY = undefined ; try { // This will throw a ToolsetConfigError const _toolset = new StackOneToolSet ({ strict : true , }); assert ( false , 'Expected ToolSetConfigError was not thrown' ); } catch ( error ) { assert ( error instanceof ToolSetConfigError , 'Expected error to be ToolSetConfigError' ); } finally { // Restore the API key process . env . STACKONE_API_KEY = originalKey ; } }; // Example 2: Handle API errors const testApiErrors = async () : Promise < void > => { const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . TEST . INVALID ; // Invalid account ID to force an error try { const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); const employeeTool = tools . getTool ( 'hris_list_employees' ); if ( employeeTool ) { // This will throw a StackOneAPIError due to the invalid account ID await employeeTool . execute (); assert ( false , 'Expected StackOneAPIError was not thrown' ); } } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError , 'Expected error to be StackOneAPIError or StackOneError' ); if ( error instanceof StackOneAPIError ) { assert ( error . statusCode !== undefined , 'Expected statusCode to be defined' ); assert ( error . responseBody !== undefined , 'Expected responseBody to be defined' ); } } }; // Example 3: Handle invalid tool name const testInvalidToolName = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const nonExistentTool = tools . getTool ( 'non_existent_tool' ); assert ( nonExistentTool === undefined , 'Expected non-existent tool to be undefined' ); }; // Example 4: Handle invalid arguments const testInvalidArguments = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getTool ( 'hris_get_employee' ); if ( employeeTool ) { try { // This will throw an error due to missing required arguments await employeeTool . execute (); assert ( false , 'Expected error was not thrown for missing arguments' ); } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError || error instanceof Error , 'Expected error to be a known error type' ); } } }; // Run all tests await testInitializationErrors (); await testApiErrors (); await testInvalidToolName (); await testInvalidArguments (); }; // Run the example errorHandling ();","title":"Error Handling"},{"location":"error-handling/#error-handling","text":"","title":"Error Handling"},{"location":"error-handling/#error-handling_1","text":"This example shows how to handle errors when using the StackOne SDK. import assert from 'node:assert' ; import { StackOneAPIError , StackOneError , StackOneToolSet , ToolSetConfigError } from '../src' ; import { ACCOUNT_IDS } from './constants' ; const errorHandling = async () : Promise < void > => { // Example 1: Handle initialization errors const testInitializationErrors = async () : Promise < void > => { // Temporarily save the API key const originalKey = process . env . STACKONE_API_KEY ; // Delete the API key to force an error process . env . STACKONE_API_KEY = undefined ; try { // This will throw a ToolsetConfigError const _toolset = new StackOneToolSet ({ strict : true , }); assert ( false , 'Expected ToolSetConfigError was not thrown' ); } catch ( error ) { assert ( error instanceof ToolSetConfigError , 'Expected error to be ToolSetConfigError' ); } finally { // Restore the API key process . env . STACKONE_API_KEY = originalKey ; } }; // Example 2: Handle API errors const testApiErrors = async () : Promise < void > => { const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . TEST . INVALID ; // Invalid account ID to force an error try { const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); const employeeTool = tools . getTool ( 'hris_list_employees' ); if ( employeeTool ) { // This will throw a StackOneAPIError due to the invalid account ID await employeeTool . execute (); assert ( false , 'Expected StackOneAPIError was not thrown' ); } } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError , 'Expected error to be StackOneAPIError or StackOneError' ); if ( error instanceof StackOneAPIError ) { assert ( error . statusCode !== undefined , 'Expected statusCode to be defined' ); assert ( error . responseBody !== undefined , 'Expected responseBody to be defined' ); } } }; // Example 3: Handle invalid tool name const testInvalidToolName = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const nonExistentTool = tools . getTool ( 'non_existent_tool' ); assert ( nonExistentTool === undefined , 'Expected non-existent tool to be undefined' ); }; // Example 4: Handle invalid arguments const testInvalidArguments = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getTool ( 'hris_get_employee' ); if ( employeeTool ) { try { // This will throw an error due to missing required arguments await employeeTool . execute (); assert ( false , 'Expected error was not thrown for missing arguments' ); } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError || error instanceof Error , 'Expected error to be a known error type' ); } } }; // Run all tests await testInitializationErrors (); await testApiErrors (); await testInvalidToolName (); await testInvalidArguments (); }; // Run the example errorHandling ();","title":"Error Handling"},{"location":"examples.spec/","text":"Examples.Spec # import { describe , expect , it } from 'bun:test' ; import { $ } from 'bun' ; import { directoryExists , joinPaths , listFilesInDirectory } from '../src/utils/file' ; describe ( 'Examples' , () => { it ( 'should run all example files without errors' , async () => { const examplesDir = joinPaths ( process . cwd (), 'examples' ); if ( ! directoryExists ( examplesDir )) { throw new Error ( 'Examples directory not found' ); } const exampleFiles = listFilesInDirectory ( examplesDir , ( fileName ) => fileName . endsWith ( '.ts' ) && ! fileName . includes ( '.spec.' ) ); expect ( exampleFiles . length ). toBeGreaterThan ( 0 ); const results = await Promise . all ( exampleFiles . map ( async ( file ) => { const filePath = joinPaths ( examplesDir , file ); try { const result = await $ `bun run ${ filePath } ` . quiet (); return { file , success : result.exitCode === 0 , exitCode : result.exitCode , stdout : result.stdout?.toString () || '' , stderr : result.stderr?.toString () || '' , }; } catch ( error ) { return { file , success : false , exitCode : 1 , stdout : '' , stderr : error instanceof Error ? error.message : String ( error ), }; } }) ); const failedExamples = results . filter (( result ) => ! result . success ); if ( failedExamples . length > 0 ) { const errorMessage = failedExamples . map (({ file , exitCode , stderr }) => ` ${ file } (exit code: ${ exitCode } ): ${ stderr } ` ) . join ( '\\n' ); throw new Error ( `Examples failed:\\n ${ errorMessage } ` ); } expect ( results . every (( result ) => result . success )). toBe ( true ); }, { timeout : 30000 } ); });","title":"Examples.Spec"},{"location":"examples.spec/#examplesspec","text":"import { describe , expect , it } from 'bun:test' ; import { $ } from 'bun' ; import { directoryExists , joinPaths , listFilesInDirectory } from '../src/utils/file' ; describe ( 'Examples' , () => { it ( 'should run all example files without errors' , async () => { const examplesDir = joinPaths ( process . cwd (), 'examples' ); if ( ! directoryExists ( examplesDir )) { throw new Error ( 'Examples directory not found' ); } const exampleFiles = listFilesInDirectory ( examplesDir , ( fileName ) => fileName . endsWith ( '.ts' ) && ! fileName . includes ( '.spec.' ) ); expect ( exampleFiles . length ). toBeGreaterThan ( 0 ); const results = await Promise . all ( exampleFiles . map ( async ( file ) => { const filePath = joinPaths ( examplesDir , file ); try { const result = await $ `bun run ${ filePath } ` . quiet (); return { file , success : result.exitCode === 0 , exitCode : result.exitCode , stdout : result.stdout?.toString () || '' , stderr : result.stderr?.toString () || '' , }; } catch ( error ) { return { file , success : false , exitCode : 1 , stdout : '' , stderr : error instanceof Error ? error.message : String ( error ), }; } }) ); const failedExamples = results . filter (( result ) => ! result . success ); if ( failedExamples . length > 0 ) { const errorMessage = failedExamples . map (({ file , exitCode , stderr }) => ` ${ file } (exit code: ${ exitCode } ): ${ stderr } ` ) . join ( '\\n' ); throw new Error ( `Examples failed:\\n ${ errorMessage } ` ); } expect ( results . every (( result ) => result . success )). toBe ( true ); }, { timeout : 30000 } ); });","title":"Examples.Spec"},{"location":"experimental-document-handling/","text":"Experimental Document Handling # EXPERIMENTAL: Document Handling with Schema Override + PreExecute This example demonstrates the new experimental schema override + preExecute functionality for handling documents from various sources (local files, URLs, databases, etc.) The new API provides two-stage transformation: 1. Schema Override: Changes the tool's input schema at creation time 2. PreExecute: Transforms from override schema back to original API format at execution time This is an experimental feature and the API may change in future versions. Run this example with: bun run examples/experimental-document-handling.ts import assert from 'node:assert' ; import * as fs from 'node:fs' ; import * as path from 'node:path' ; import type { JSONSchema7Definition } from 'json-schema' ; import { type Experimental_PreExecuteFunction , type Experimental_SchemaOverride , StackOneToolSet , } from '../src' ; import { ACCOUNT_IDS } from './constants' ; const accountId = ACCOUNT_IDS . HRIS ; interface FileFormatParam { value : string ; } interface DocumentParams { content : string ; name : string ; file_format : FileFormatParam ; [ key : string ] : unknown ; } EXPERIMENTAL: Schema override for document upload - changes from complex schema to simple doc_id const createDocumentSchemaOverride = () : Experimental_SchemaOverride => { return ( originalSchema ) => { // Extract only the category from original schema, replace file-related params with doc_id const newProperties : Record < string , JSONSchema7Definition > = {}; // Keep non-file parameters from original schema for ( const [ key , value ] of Object . entries ( originalSchema . properties )) { if ( ! [ 'content' , 'name' , 'file_format' ]. includes ( key )) { newProperties [ key ] = value ; } } // Add simplified document ID parameter newProperties . doc_id = { type : 'string' , description : 'Document identifier or file path' , }; return { type : 'object' , properties : newProperties , required : [ 'doc_id' , ...( originalSchema . required ? . filter ( ( r ) => ! [ 'content' , 'name' , 'file_format' ]. includes ( r ) ) || []), ], }; }; }; EXPERIMENTAL: PreExecute function that transforms doc_id back to original file parameters const createDocumentPreExecute = ( allowedPaths : string []) : Experimental_PreExecuteFunction => { return async ( params ) => { const { doc_id , ... otherParams } = params ; if ( typeof doc_id !== 'string' ) { throw new Error ( 'doc_id must be a string' ); } // Security check: only allow certain paths const isAllowed = allowedPaths . some (( allowedPath ) => doc_id . startsWith ( allowedPath )); if ( ! isAllowed ) { throw new Error ( `Document path not allowed: ${ doc_id } ` ); } if ( ! fs . existsSync ( doc_id )) { throw new Error ( `Document not found: ${ doc_id } ` ); } // Read file and convert to base64 const fileContent = fs . readFileSync ( doc_id ); const base64Content = fileContent . toString ( 'base64' ); const fileName = path . basename ( doc_id ); const extension = path . extname ( doc_id ). slice ( 1 ); // Transform back to original API format return { ... otherParams , content : base64Content , name : fileName , file_format : { value : extension }, }; }; }; EXPERIMENTAL: Schema override for external document references const createExternalDocumentSchemaOverride = () : Experimental_SchemaOverride => { return ( originalSchema ) => { const newProperties : Record < string , JSONSchema7Definition > = {}; // Keep non-file parameters from original schema for ( const [ key , value ] of Object . entries ( originalSchema . properties )) { if ( ! [ 'content' , 'name' , 'file_format' ]. includes ( key )) { newProperties [ key ] = value ; } } // Add external document reference parameter newProperties . document_reference = { type : 'string' , description : 'External document reference (S3 key, database ID, etc.)' , }; return { type : 'object' , properties : newProperties , required : [ 'document_reference' , ...( originalSchema . required ? . filter ( ( r ) => ! [ 'content' , 'name' , 'file_format' ]. includes ( r ) ) || []), ], }; }; }; EXPERIMENTAL: PreExecute function for external document fetching const createExternalDocumentPreExecute = () : Experimental_PreExecuteFunction => { return async ( params ) => { const { document_reference , ... otherParams } = params ; if ( typeof document_reference !== 'string' ) { throw new Error ( 'document_reference must be a string' ); } // Simulate fetching from external source (S3, database, etc.) console . log ( `Fetching document from external source: ${ document_reference } ` ); // In a real implementation, this would fetch from S3, database, etc. const mockDocumentContent = 'This is a mock document fetched from external source' ; const base64Content = Buffer . from ( mockDocumentContent ). toString ( 'base64' ); // Transform back to original API format return { ... otherParams , content : base64Content , name : `external-doc- ${ document_reference } .txt` , file_format : { value : 'txt' }, }; }; }; EXPERIMENTAL: Schema override for multi-source documents (supports both local and external) const createMultiSourceSchemaOverride = () : Experimental_SchemaOverride => { return ( originalSchema ) => { const newProperties : Record < string , JSONSchema7Definition > = {}; // Keep non-file parameters from original schema for ( const [ key , value ] of Object . entries ( originalSchema . properties )) { if ( ! [ 'content' , 'name' , 'file_format' ]. includes ( key )) { newProperties [ key ] = value ; } } // Add both document parameters (user can provide either) newProperties . doc_id = { type : 'string' , description : 'Local document path (takes precedence if both provided)' , }; newProperties . document_reference = { type : 'string' , description : 'External document reference (used if doc_id not provided)' , }; return { type : 'object' , properties : newProperties , required : [ ...( originalSchema . required ? . filter ( ( r ) => ! [ 'content' , 'name' , 'file_format' ]. includes ( r ) ) || []), ], }; }; }; EXPERIMENTAL: PreExecute function for multi-source document handling with fallback const createMultiSourcePreExecute = ( localPaths : string []) : Experimental_PreExecuteFunction => { const localPreExecute = createDocumentPreExecute ( localPaths ); const externalPreExecute = createExternalDocumentPreExecute (); return async ( params ) => { // Try local file first if doc_id is provided if ( params . doc_id ) { try { return await localPreExecute ( params ); } catch ( error ) { console . warn ( `Local file handler failed: ${ error } ` ); } } // Fallback to external handler if document_reference is provided if ( params . document_reference ) { return await externalPreExecute ( params ); } // No document parameters provided throw new Error ( 'Either doc_id or document_reference must be provided' ); }; }; const experimentalDocumentHandling = async () : Promise < void > => { // Create a sample file for testing const sampleFilePath = path . join ( __dirname , 'sample-document.txt' ); fs . writeFileSync ( sampleFilePath , 'This is an experimental document handling test file.' ); try { // Initialize the StackOne toolset const toolset = new StackOneToolSet (); // Get base tools for documents const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); console . log ( '\ud83e\uddea Testing EXPERIMENTAL schema override + preExecute for local files...' ); // EXPERIMENTAL: Create a tool with schema override and preExecute for local files const localDocumentTool = tools . getTool ( 'hris_upload_employee_document' , { experimental_schemaOverride : createDocumentSchemaOverride (), experimental_preExecute : createDocumentPreExecute ([ __dirname ]), }); assert ( localDocumentTool !== undefined , 'Local document tool not found' ); // Use the new simplified schema (doc_id instead of content/name/file_format) const localFileResult = await localDocumentTool . execute ( { doc_id : sampleFilePath , // Simplified schema - just document ID id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true , } ); console . log ( '\u2705 Local file schema override + preExecute successful' ); const localParams = localFileResult . mappedParams as Record < string , unknown > ; const localDocumentParams = localParams as DocumentParams & Record < string , unknown > ; assert ( localDocumentParams . file_format ? . value === 'txt' , 'File format was not transformed correctly' ); assert ( localDocumentParams . name === 'sample-document.txt' , 'File name was not transformed correctly' ); assert ( typeof localDocumentParams . content === 'string' , 'File content was not transformed correctly' ); console . log ( '\ud83e\uddea Testing EXPERIMENTAL schema override + preExecute for external documents...' ); // EXPERIMENTAL: Create a tool for external document references const externalDocumentTool = tools . getTool ( 'hris_upload_employee_document' , { experimental_schemaOverride : createExternalDocumentSchemaOverride (), experimental_preExecute : createExternalDocumentPreExecute (), }); assert ( externalDocumentTool !== undefined , 'External document tool not found' ); const externalResult = await externalDocumentTool . execute ( { document_reference : 'external-doc-123' , // Simplified schema - just reference id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true , } ); console . log ( '\u2705 External document schema override + preExecute successful' ); const externalParams = externalResult . mappedParams as Record < string , unknown > ; const externalDocumentParams = externalParams as DocumentParams & Record < string , unknown > ; assert ( externalDocumentParams . name . includes ( 'external-doc-123' ), 'External document name was not transformed correctly' ); console . log ( '\ud83e\uddea Testing EXPERIMENTAL multi-source schema override + preExecute...' ); // EXPERIMENTAL: Create a tool that supports both local and external documents const multiSourceTool = tools . getTool ( 'hris_upload_employee_document' , { experimental_schemaOverride : createMultiSourceSchemaOverride (), experimental_preExecute : createMultiSourcePreExecute ([ __dirname ]), }); assert ( multiSourceTool !== undefined , 'Multi-source tool not found' ); // Test with local file const multiSourceLocalResult = await multiSourceTool . execute ( { doc_id : sampleFilePath , // Local file takes precedence id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true , } ); console . log ( '\u2705 Multi-source (local) schema override + preExecute successful' ); const multiLocalParams = multiSourceLocalResult . mappedParams as Record < string , unknown > ; const multiLocalDocumentParams = multiLocalParams as DocumentParams & Record < string , unknown > ; assert ( multiLocalDocumentParams . name === 'sample-document.txt' , 'Multi-source local document name was not transformed correctly' ); // Test with external reference const multiSourceExternalResult = await multiSourceTool . execute ( { document_reference : 'external-doc-456' , // Fallback to external id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true , } ); console . log ( '\u2705 Multi-source (external) schema override + preExecute successful' ); const multiExternalParams = multiSourceExternalResult . mappedParams as Record < string , unknown > ; const multiExternalDocumentParams = multiExternalParams as DocumentParams & Record < string , unknown > ; assert ( multiExternalDocumentParams . name . includes ( 'external-doc-456' ), 'Multi-source external document name was not transformed correctly' ); console . log ( '\ud83c\udf89 All EXPERIMENTAL schema override + preExecute tests passed!' ); console . log ( '' ); console . log ( '\ud83d\udccb API Summary:' ); console . log ( ' 1. experimental_schemaOverride: Changes tool input schema at creation time' ); console . log ( ' 2. experimental_preExecute: Transforms from override schema to original API format' ); console . log ( ' 3. Two-stage transformation: Schema definition \u2192 Parameter transformation' ); console . log ( '' ); console . log ( '\u26a0\ufe0f IMPORTANT: This is experimental functionality.' ); console . log ( ' The API may change in future versions.' ); console . log ( ' Use at your own risk in production environments.' ); } finally { // Clean up the sample file if ( fs . existsSync ( sampleFilePath )) { fs . unlinkSync ( sampleFilePath ); } } }; experimentalDocumentHandling ();","title":"Experimental Document Handling"},{"location":"experimental-document-handling/#experimental-document-handling","text":"EXPERIMENTAL: Document Handling with Schema Override + PreExecute This example demonstrates the new experimental schema override + preExecute functionality for handling documents from various sources (local files, URLs, databases, etc.) The new API provides two-stage transformation: 1. Schema Override: Changes the tool's input schema at creation time 2. PreExecute: Transforms from override schema back to original API format at execution time This is an experimental feature and the API may change in future versions. Run this example with: bun run examples/experimental-document-handling.ts import assert from 'node:assert' ; import * as fs from 'node:fs' ; import * as path from 'node:path' ; import type { JSONSchema7Definition } from 'json-schema' ; import { type Experimental_PreExecuteFunction , type Experimental_SchemaOverride , StackOneToolSet , } from '../src' ; import { ACCOUNT_IDS } from './constants' ; const accountId = ACCOUNT_IDS . HRIS ; interface FileFormatParam { value : string ; } interface DocumentParams { content : string ; name : string ; file_format : FileFormatParam ; [ key : string ] : unknown ; } EXPERIMENTAL: Schema override for document upload - changes from complex schema to simple doc_id const createDocumentSchemaOverride = () : Experimental_SchemaOverride => { return ( originalSchema ) => { // Extract only the category from original schema, replace file-related params with doc_id const newProperties : Record < string , JSONSchema7Definition > = {}; // Keep non-file parameters from original schema for ( const [ key , value ] of Object . entries ( originalSchema . properties )) { if ( ! [ 'content' , 'name' , 'file_format' ]. includes ( key )) { newProperties [ key ] = value ; } } // Add simplified document ID parameter newProperties . doc_id = { type : 'string' , description : 'Document identifier or file path' , }; return { type : 'object' , properties : newProperties , required : [ 'doc_id' , ...( originalSchema . required ? . filter ( ( r ) => ! [ 'content' , 'name' , 'file_format' ]. includes ( r ) ) || []), ], }; }; }; EXPERIMENTAL: PreExecute function that transforms doc_id back to original file parameters const createDocumentPreExecute = ( allowedPaths : string []) : Experimental_PreExecuteFunction => { return async ( params ) => { const { doc_id , ... otherParams } = params ; if ( typeof doc_id !== 'string' ) { throw new Error ( 'doc_id must be a string' ); } // Security check: only allow certain paths const isAllowed = allowedPaths . some (( allowedPath ) => doc_id . startsWith ( allowedPath )); if ( ! isAllowed ) { throw new Error ( `Document path not allowed: ${ doc_id } ` ); } if ( ! fs . existsSync ( doc_id )) { throw new Error ( `Document not found: ${ doc_id } ` ); } // Read file and convert to base64 const fileContent = fs . readFileSync ( doc_id ); const base64Content = fileContent . toString ( 'base64' ); const fileName = path . basename ( doc_id ); const extension = path . extname ( doc_id ). slice ( 1 ); // Transform back to original API format return { ... otherParams , content : base64Content , name : fileName , file_format : { value : extension }, }; }; }; EXPERIMENTAL: Schema override for external document references const createExternalDocumentSchemaOverride = () : Experimental_SchemaOverride => { return ( originalSchema ) => { const newProperties : Record < string , JSONSchema7Definition > = {}; // Keep non-file parameters from original schema for ( const [ key , value ] of Object . entries ( originalSchema . properties )) { if ( ! [ 'content' , 'name' , 'file_format' ]. includes ( key )) { newProperties [ key ] = value ; } } // Add external document reference parameter newProperties . document_reference = { type : 'string' , description : 'External document reference (S3 key, database ID, etc.)' , }; return { type : 'object' , properties : newProperties , required : [ 'document_reference' , ...( originalSchema . required ? . filter ( ( r ) => ! [ 'content' , 'name' , 'file_format' ]. includes ( r ) ) || []), ], }; }; }; EXPERIMENTAL: PreExecute function for external document fetching const createExternalDocumentPreExecute = () : Experimental_PreExecuteFunction => { return async ( params ) => { const { document_reference , ... otherParams } = params ; if ( typeof document_reference !== 'string' ) { throw new Error ( 'document_reference must be a string' ); } // Simulate fetching from external source (S3, database, etc.) console . log ( `Fetching document from external source: ${ document_reference } ` ); // In a real implementation, this would fetch from S3, database, etc. const mockDocumentContent = 'This is a mock document fetched from external source' ; const base64Content = Buffer . from ( mockDocumentContent ). toString ( 'base64' ); // Transform back to original API format return { ... otherParams , content : base64Content , name : `external-doc- ${ document_reference } .txt` , file_format : { value : 'txt' }, }; }; }; EXPERIMENTAL: Schema override for multi-source documents (supports both local and external) const createMultiSourceSchemaOverride = () : Experimental_SchemaOverride => { return ( originalSchema ) => { const newProperties : Record < string , JSONSchema7Definition > = {}; // Keep non-file parameters from original schema for ( const [ key , value ] of Object . entries ( originalSchema . properties )) { if ( ! [ 'content' , 'name' , 'file_format' ]. includes ( key )) { newProperties [ key ] = value ; } } // Add both document parameters (user can provide either) newProperties . doc_id = { type : 'string' , description : 'Local document path (takes precedence if both provided)' , }; newProperties . document_reference = { type : 'string' , description : 'External document reference (used if doc_id not provided)' , }; return { type : 'object' , properties : newProperties , required : [ ...( originalSchema . required ? . filter ( ( r ) => ! [ 'content' , 'name' , 'file_format' ]. includes ( r ) ) || []), ], }; }; }; EXPERIMENTAL: PreExecute function for multi-source document handling with fallback const createMultiSourcePreExecute = ( localPaths : string []) : Experimental_PreExecuteFunction => { const localPreExecute = createDocumentPreExecute ( localPaths ); const externalPreExecute = createExternalDocumentPreExecute (); return async ( params ) => { // Try local file first if doc_id is provided if ( params . doc_id ) { try { return await localPreExecute ( params ); } catch ( error ) { console . warn ( `Local file handler failed: ${ error } ` ); } } // Fallback to external handler if document_reference is provided if ( params . document_reference ) { return await externalPreExecute ( params ); } // No document parameters provided throw new Error ( 'Either doc_id or document_reference must be provided' ); }; }; const experimentalDocumentHandling = async () : Promise < void > => { // Create a sample file for testing const sampleFilePath = path . join ( __dirname , 'sample-document.txt' ); fs . writeFileSync ( sampleFilePath , 'This is an experimental document handling test file.' ); try { // Initialize the StackOne toolset const toolset = new StackOneToolSet (); // Get base tools for documents const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); console . log ( '\ud83e\uddea Testing EXPERIMENTAL schema override + preExecute for local files...' ); // EXPERIMENTAL: Create a tool with schema override and preExecute for local files const localDocumentTool = tools . getTool ( 'hris_upload_employee_document' , { experimental_schemaOverride : createDocumentSchemaOverride (), experimental_preExecute : createDocumentPreExecute ([ __dirname ]), }); assert ( localDocumentTool !== undefined , 'Local document tool not found' ); // Use the new simplified schema (doc_id instead of content/name/file_format) const localFileResult = await localDocumentTool . execute ( { doc_id : sampleFilePath , // Simplified schema - just document ID id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true , } ); console . log ( '\u2705 Local file schema override + preExecute successful' ); const localParams = localFileResult . mappedParams as Record < string , unknown > ; const localDocumentParams = localParams as DocumentParams & Record < string , unknown > ; assert ( localDocumentParams . file_format ? . value === 'txt' , 'File format was not transformed correctly' ); assert ( localDocumentParams . name === 'sample-document.txt' , 'File name was not transformed correctly' ); assert ( typeof localDocumentParams . content === 'string' , 'File content was not transformed correctly' ); console . log ( '\ud83e\uddea Testing EXPERIMENTAL schema override + preExecute for external documents...' ); // EXPERIMENTAL: Create a tool for external document references const externalDocumentTool = tools . getTool ( 'hris_upload_employee_document' , { experimental_schemaOverride : createExternalDocumentSchemaOverride (), experimental_preExecute : createExternalDocumentPreExecute (), }); assert ( externalDocumentTool !== undefined , 'External document tool not found' ); const externalResult = await externalDocumentTool . execute ( { document_reference : 'external-doc-123' , // Simplified schema - just reference id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true , } ); console . log ( '\u2705 External document schema override + preExecute successful' ); const externalParams = externalResult . mappedParams as Record < string , unknown > ; const externalDocumentParams = externalParams as DocumentParams & Record < string , unknown > ; assert ( externalDocumentParams . name . includes ( 'external-doc-123' ), 'External document name was not transformed correctly' ); console . log ( '\ud83e\uddea Testing EXPERIMENTAL multi-source schema override + preExecute...' ); // EXPERIMENTAL: Create a tool that supports both local and external documents const multiSourceTool = tools . getTool ( 'hris_upload_employee_document' , { experimental_schemaOverride : createMultiSourceSchemaOverride (), experimental_preExecute : createMultiSourcePreExecute ([ __dirname ]), }); assert ( multiSourceTool !== undefined , 'Multi-source tool not found' ); // Test with local file const multiSourceLocalResult = await multiSourceTool . execute ( { doc_id : sampleFilePath , // Local file takes precedence id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true , } ); console . log ( '\u2705 Multi-source (local) schema override + preExecute successful' ); const multiLocalParams = multiSourceLocalResult . mappedParams as Record < string , unknown > ; const multiLocalDocumentParams = multiLocalParams as DocumentParams & Record < string , unknown > ; assert ( multiLocalDocumentParams . name === 'sample-document.txt' , 'Multi-source local document name was not transformed correctly' ); // Test with external reference const multiSourceExternalResult = await multiSourceTool . execute ( { document_reference : 'external-doc-456' , // Fallback to external id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true , } ); console . log ( '\u2705 Multi-source (external) schema override + preExecute successful' ); const multiExternalParams = multiSourceExternalResult . mappedParams as Record < string , unknown > ; const multiExternalDocumentParams = multiExternalParams as DocumentParams & Record < string , unknown > ; assert ( multiExternalDocumentParams . name . includes ( 'external-doc-456' ), 'Multi-source external document name was not transformed correctly' ); console . log ( '\ud83c\udf89 All EXPERIMENTAL schema override + preExecute tests passed!' ); console . log ( '' ); console . log ( '\ud83d\udccb API Summary:' ); console . log ( ' 1. experimental_schemaOverride: Changes tool input schema at creation time' ); console . log ( ' 2. experimental_preExecute: Transforms from override schema to original API format' ); console . log ( ' 3. Two-stage transformation: Schema definition \u2192 Parameter transformation' ); console . log ( '' ); console . log ( '\u26a0\ufe0f IMPORTANT: This is experimental functionality.' ); console . log ( ' The API may change in future versions.' ); console . log ( ' Use at your own risk in production environments.' ); } finally { // Clean up the sample file if ( fs . existsSync ( sampleFilePath )) { fs . unlinkSync ( sampleFilePath ); } } }; experimentalDocumentHandling ();","title":"Experimental Document Handling"},{"location":"filters/","text":"Filters # Filters Example This example demonstrates how to use filters with the HRIS list employees endpoint. It showcases the deep object serialization implementation that properly converts nested filter objects to OpenAPI deepObject style query parameters. Key features demonstrated: 1. Basic filter usage (updated_after, email, employee_number) 2. Proxy parameter usage for provider-specific filters 3. Complex nested filter combinations 4. Proper serialization of filter objects to query parameters Usage: bun run examples/filters.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; type DryRunResult = { url : string }; const hriseEmployeeFilters = async () : Promise < void > => { // Initialize the toolset const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . TEST . VALID ; // Get the HRIS tools with account ID const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); const employeesTool = tools . getTool ( 'hris_list_employees' ); assert ( employeesTool !== undefined , 'Expected to find hris_list_employees tool' ); console . log ( '\ud83e\uddea Testing HRIS Employee Filters with Deep Object Serialization\\n' ); /* * Example 1: Basic date filter * Demonstrates filtering employees updated after a specific date */ console . log ( '1\ufe0f\u20e3 Basic Date Filter Test' ); const basicDateFilter = ( await employeesTool . execute ( { filter : { updated_after : '2023-01-01T00:00:00.000Z' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { updated_after : '2023-01-01T00:00:00.000Z' } }); console . log ( 'Serialized URL:' , basicDateFilter . url ); // Verify that the filter is properly serialized as deepObject style assert ( basicDateFilter . url . includes ( 'filter%5Bupdated_after%5D=2023-01-01T00%3A00%3A00.000Z' ), 'Expected URL to contain properly serialized date filter' ); console . log ( '\u2705 Date filter serialized correctly\\n' ); /* * Example 2: Email filter * Demonstrates filtering employees by email address */ console . log ( '2\ufe0f\u20e3 Email Filter Test' ); const emailFilter = ( await employeesTool . execute ( { filter : { email : 'john.doe@company.com' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { email : 'john.doe@company.com' } }); console . log ( 'Serialized URL:' , emailFilter . url ); assert ( emailFilter . url . includes ( 'filter%5Bemail%5D=john.doe%40company.com' ), 'Expected URL to contain properly serialized email filter' ); console . log ( '\u2705 Email filter serialized correctly\\n' ); /* * Example 3: Employee number filter * Demonstrates filtering employees by employee number */ console . log ( '3\ufe0f\u20e3 Employee Number Filter Test' ); const employeeNumberFilter = ( await employeesTool . execute ( { filter : { employee_number : 'EMP001' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { employee_number : 'EMP001' } }); console . log ( 'Serialized URL:' , employeeNumberFilter . url ); assert ( employeeNumberFilter . url . includes ( 'filter%5Bemployee_number%5D=EMP001' ), 'Expected URL to contain properly serialized employee number filter' ); console . log ( '\u2705 Employee number filter serialized correctly\\n' ); /* * Example 4: Multiple filters combined * Demonstrates using multiple filter parameters together */ console . log ( '4\ufe0f\u20e3 Multiple Filters Combined Test' ); const multipleFilters = ( await employeesTool . execute ( { filter : { updated_after : '2023-06-01T00:00:00.000Z' , email : 'jane.smith@company.com' , employee_number : 'EMP002' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { updated_after : '2023-06-01T00:00:00.000Z' , email : 'jane.smith@company.com' , employee_number : 'EMP002' , }, }); console . log ( 'Serialized URL:' , ( multipleFilters as { url : string }). url ); // Verify all filters are present in the URL assert ( multipleFilters . url . includes ( 'filter%5Bupdated_after%5D=2023-06-01T00%3A00%3A00.000Z' ), 'Expected URL to contain date filter' ); assert ( multipleFilters . url . includes ( 'filter%5Bemail%5D=jane.smith%40company.com' ), 'Expected URL to contain email filter' ); assert ( multipleFilters . url . includes ( 'filter%5Bemployee_number%5D=EMP002' ), 'Expected URL to contain employee number filter' ); console . log ( '\u2705 Multiple filters serialized correctly\\n' ); /* * Example 5: Proxy parameters for provider-specific filtering * Demonstrates using proxy parameters which also use deepObject serialization */ console . log ( '5\ufe0f\u20e3 Proxy Parameters Test' ); const proxyParameters = ( await employeesTool . execute ( { proxy : { custom_field : 'value123' , provider_filter : { department : 'Engineering' , status : 'active' , }, }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Proxy object:' , { proxy : { custom_field : 'value123' , provider_filter : { department : 'Engineering' , status : 'active' , }, }, }); console . log ( 'Serialized URL:' , proxyParameters . url ); // Verify proxy parameters are properly serialized assert ( proxyParameters . url . includes ( 'proxy%5Bcustom_field%5D=value123' ), 'Expected URL to contain proxy custom_field parameter' ); assert ( proxyParameters . url . includes ( 'proxy%5Bprovider_filter%5D%5Bdepartment%5D=Engineering' ), 'Expected URL to contain nested proxy department parameter' ); assert ( proxyParameters . url . includes ( 'proxy%5Bprovider_filter%5D%5Bstatus%5D=active' ), 'Expected URL to contain nested proxy status parameter' ); console . log ( '\u2705 Proxy parameters with nested objects serialized correctly\\n' ); /* * Example 6: Complex combined scenario * Demonstrates combining filters, proxy parameters, and other query parameters */ console . log ( '6\ufe0f\u20e3 Complex Combined Scenario Test' ); const complexScenario = ( await employeesTool . execute ( { filter : { updated_after : '2023-09-01T00:00:00.000Z' , email : 'admin@company.com' , }, proxy : { include_terminated : 'false' , custom_sorting : { field : 'hire_date' , order : 'desc' , }, }, fields : 'id,first_name,last_name,email,hire_date' , page_size : '50' , }, { dryRun : true } )) as DryRunResult ; console . log ( 'Complex parameters:' , { filter : { updated_after : '2023-09-01T00:00:00.000Z' , email : 'admin@company.com' , }, proxy : { include_terminated : 'false' , custom_sorting : { field : 'hire_date' , order : 'desc' , }, }, fields : 'id,first_name,last_name,email,hire_date' , page_size : '50' , }); console . log ( 'Serialized URL:' , complexScenario . url ); // Verify complex scenario serialization assert ( complexScenario . url . includes ( 'filter%5Bupdated_after%5D=2023-09-01T00%3A00%3A00.000Z' ), 'Expected URL to contain complex date filter' ); assert ( complexScenario . url . includes ( 'filter%5Bemail%5D=admin%40company.com' ), 'Expected URL to contain complex email filter' ); assert ( complexScenario . url . includes ( 'proxy%5Binclude_terminated%5D=false' ), 'Expected URL to contain proxy boolean parameter' ); assert ( complexScenario . url . includes ( 'proxy%5Bcustom_sorting%5D%5Bfield%5D=hire_date' ), 'Expected URL to contain nested proxy field parameter' ); assert ( complexScenario . url . includes ( 'proxy%5Bcustom_sorting%5D%5Border%5D=desc' ), 'Expected URL to contain nested proxy order parameter' ); assert ( complexScenario . url . includes ( 'fields=id%2Cfirst_name%2Clast_name%2Cemail%2Chire_date' ), 'Expected URL to contain fields parameter' ); assert ( complexScenario . url . includes ( 'page_size=50' ), 'Expected URL to contain page_size parameter' ); console . log ( '\u2705 Complex combined scenario serialized correctly\\n' ); /* * Example 7: Edge case - Empty filter objects * Demonstrates handling of empty filter objects */ console . log ( '7\ufe0f\u20e3 Edge Case - Empty Filter Objects Test' ); const emptyFilterTest = ( await employeesTool . execute ( { filter : {}, fields : 'id,first_name,last_name' , }, { dryRun : true } )) as DryRunResult ; console . log ( 'Empty filter object:' , { filter : {}, fields : 'id,first_name,last_name' }); console . log ( 'Serialized URL:' , emptyFilterTest . url ); // Verify that empty filter objects don't create problematic parameters assert ( emptyFilterTest . url . includes ( 'fields=id%2Cfirst_name%2Clast_name' ), 'Expected URL to contain fields parameter even with empty filter' ); // Empty objects should not create parameters assert ( ! emptyFilterTest . url . includes ( 'filter=' ), 'Expected URL to not contain empty filter parameter' ); console . log ( '\u2705 Empty filter objects handled correctly\\n' ); }; // Run the example hriseEmployeeFilters ();","title":"Filters"},{"location":"filters/#filters","text":"Filters Example This example demonstrates how to use filters with the HRIS list employees endpoint. It showcases the deep object serialization implementation that properly converts nested filter objects to OpenAPI deepObject style query parameters. Key features demonstrated: 1. Basic filter usage (updated_after, email, employee_number) 2. Proxy parameter usage for provider-specific filters 3. Complex nested filter combinations 4. Proper serialization of filter objects to query parameters Usage: bun run examples/filters.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; type DryRunResult = { url : string }; const hriseEmployeeFilters = async () : Promise < void > => { // Initialize the toolset const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . TEST . VALID ; // Get the HRIS tools with account ID const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); const employeesTool = tools . getTool ( 'hris_list_employees' ); assert ( employeesTool !== undefined , 'Expected to find hris_list_employees tool' ); console . log ( '\ud83e\uddea Testing HRIS Employee Filters with Deep Object Serialization\\n' ); /* * Example 1: Basic date filter * Demonstrates filtering employees updated after a specific date */ console . log ( '1\ufe0f\u20e3 Basic Date Filter Test' ); const basicDateFilter = ( await employeesTool . execute ( { filter : { updated_after : '2023-01-01T00:00:00.000Z' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { updated_after : '2023-01-01T00:00:00.000Z' } }); console . log ( 'Serialized URL:' , basicDateFilter . url ); // Verify that the filter is properly serialized as deepObject style assert ( basicDateFilter . url . includes ( 'filter%5Bupdated_after%5D=2023-01-01T00%3A00%3A00.000Z' ), 'Expected URL to contain properly serialized date filter' ); console . log ( '\u2705 Date filter serialized correctly\\n' ); /* * Example 2: Email filter * Demonstrates filtering employees by email address */ console . log ( '2\ufe0f\u20e3 Email Filter Test' ); const emailFilter = ( await employeesTool . execute ( { filter : { email : 'john.doe@company.com' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { email : 'john.doe@company.com' } }); console . log ( 'Serialized URL:' , emailFilter . url ); assert ( emailFilter . url . includes ( 'filter%5Bemail%5D=john.doe%40company.com' ), 'Expected URL to contain properly serialized email filter' ); console . log ( '\u2705 Email filter serialized correctly\\n' ); /* * Example 3: Employee number filter * Demonstrates filtering employees by employee number */ console . log ( '3\ufe0f\u20e3 Employee Number Filter Test' ); const employeeNumberFilter = ( await employeesTool . execute ( { filter : { employee_number : 'EMP001' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { employee_number : 'EMP001' } }); console . log ( 'Serialized URL:' , employeeNumberFilter . url ); assert ( employeeNumberFilter . url . includes ( 'filter%5Bemployee_number%5D=EMP001' ), 'Expected URL to contain properly serialized employee number filter' ); console . log ( '\u2705 Employee number filter serialized correctly\\n' ); /* * Example 4: Multiple filters combined * Demonstrates using multiple filter parameters together */ console . log ( '4\ufe0f\u20e3 Multiple Filters Combined Test' ); const multipleFilters = ( await employeesTool . execute ( { filter : { updated_after : '2023-06-01T00:00:00.000Z' , email : 'jane.smith@company.com' , employee_number : 'EMP002' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { updated_after : '2023-06-01T00:00:00.000Z' , email : 'jane.smith@company.com' , employee_number : 'EMP002' , }, }); console . log ( 'Serialized URL:' , ( multipleFilters as { url : string }). url ); // Verify all filters are present in the URL assert ( multipleFilters . url . includes ( 'filter%5Bupdated_after%5D=2023-06-01T00%3A00%3A00.000Z' ), 'Expected URL to contain date filter' ); assert ( multipleFilters . url . includes ( 'filter%5Bemail%5D=jane.smith%40company.com' ), 'Expected URL to contain email filter' ); assert ( multipleFilters . url . includes ( 'filter%5Bemployee_number%5D=EMP002' ), 'Expected URL to contain employee number filter' ); console . log ( '\u2705 Multiple filters serialized correctly\\n' ); /* * Example 5: Proxy parameters for provider-specific filtering * Demonstrates using proxy parameters which also use deepObject serialization */ console . log ( '5\ufe0f\u20e3 Proxy Parameters Test' ); const proxyParameters = ( await employeesTool . execute ( { proxy : { custom_field : 'value123' , provider_filter : { department : 'Engineering' , status : 'active' , }, }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Proxy object:' , { proxy : { custom_field : 'value123' , provider_filter : { department : 'Engineering' , status : 'active' , }, }, }); console . log ( 'Serialized URL:' , proxyParameters . url ); // Verify proxy parameters are properly serialized assert ( proxyParameters . url . includes ( 'proxy%5Bcustom_field%5D=value123' ), 'Expected URL to contain proxy custom_field parameter' ); assert ( proxyParameters . url . includes ( 'proxy%5Bprovider_filter%5D%5Bdepartment%5D=Engineering' ), 'Expected URL to contain nested proxy department parameter' ); assert ( proxyParameters . url . includes ( 'proxy%5Bprovider_filter%5D%5Bstatus%5D=active' ), 'Expected URL to contain nested proxy status parameter' ); console . log ( '\u2705 Proxy parameters with nested objects serialized correctly\\n' ); /* * Example 6: Complex combined scenario * Demonstrates combining filters, proxy parameters, and other query parameters */ console . log ( '6\ufe0f\u20e3 Complex Combined Scenario Test' ); const complexScenario = ( await employeesTool . execute ( { filter : { updated_after : '2023-09-01T00:00:00.000Z' , email : 'admin@company.com' , }, proxy : { include_terminated : 'false' , custom_sorting : { field : 'hire_date' , order : 'desc' , }, }, fields : 'id,first_name,last_name,email,hire_date' , page_size : '50' , }, { dryRun : true } )) as DryRunResult ; console . log ( 'Complex parameters:' , { filter : { updated_after : '2023-09-01T00:00:00.000Z' , email : 'admin@company.com' , }, proxy : { include_terminated : 'false' , custom_sorting : { field : 'hire_date' , order : 'desc' , }, }, fields : 'id,first_name,last_name,email,hire_date' , page_size : '50' , }); console . log ( 'Serialized URL:' , complexScenario . url ); // Verify complex scenario serialization assert ( complexScenario . url . includes ( 'filter%5Bupdated_after%5D=2023-09-01T00%3A00%3A00.000Z' ), 'Expected URL to contain complex date filter' ); assert ( complexScenario . url . includes ( 'filter%5Bemail%5D=admin%40company.com' ), 'Expected URL to contain complex email filter' ); assert ( complexScenario . url . includes ( 'proxy%5Binclude_terminated%5D=false' ), 'Expected URL to contain proxy boolean parameter' ); assert ( complexScenario . url . includes ( 'proxy%5Bcustom_sorting%5D%5Bfield%5D=hire_date' ), 'Expected URL to contain nested proxy field parameter' ); assert ( complexScenario . url . includes ( 'proxy%5Bcustom_sorting%5D%5Border%5D=desc' ), 'Expected URL to contain nested proxy order parameter' ); assert ( complexScenario . url . includes ( 'fields=id%2Cfirst_name%2Clast_name%2Cemail%2Chire_date' ), 'Expected URL to contain fields parameter' ); assert ( complexScenario . url . includes ( 'page_size=50' ), 'Expected URL to contain page_size parameter' ); console . log ( '\u2705 Complex combined scenario serialized correctly\\n' ); /* * Example 7: Edge case - Empty filter objects * Demonstrates handling of empty filter objects */ console . log ( '7\ufe0f\u20e3 Edge Case - Empty Filter Objects Test' ); const emptyFilterTest = ( await employeesTool . execute ( { filter : {}, fields : 'id,first_name,last_name' , }, { dryRun : true } )) as DryRunResult ; console . log ( 'Empty filter object:' , { filter : {}, fields : 'id,first_name,last_name' }); console . log ( 'Serialized URL:' , emptyFilterTest . url ); // Verify that empty filter objects don't create problematic parameters assert ( emptyFilterTest . url . includes ( 'fields=id%2Cfirst_name%2Clast_name' ), 'Expected URL to contain fields parameter even with empty filter' ); // Empty objects should not create parameters assert ( ! emptyFilterTest . url . includes ( 'filter=' ), 'Expected URL to not contain empty filter parameter' ); console . log ( '\u2705 Empty filter objects handled correctly\\n' ); }; // Run the example hriseEmployeeFilters ();","title":"Filters"},{"location":"human-in-the-loop/","text":"Human In The Loop # Example showing how to do human-in-the-loop workflows with StackOne using the split functionality. This allows for more granular control over tool execution and validation. Run this with: bun run examples/human-in-the-loop.ts import { assert } from 'node:console' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import type { JsonDict } from '../src/types' ; import { ACCOUNT_IDS } from './constants' ; interface ToolCall { toolName : string ; args : Record < string , unknown > ; } const humanInTheLoopExample = async () : Promise < void > => { // Create a toolset const toolset = new StackOneToolSet (); const hrisAccountId = ACCOUNT_IDS . HRIS ; // Get the create employee tool const createEmployeeTool = toolset . getTool ( 'hris_create_employee' , { 'x-account-id' : hrisAccountId , }); if ( ! createEmployeeTool ) { throw new Error ( 'Create employee tool not found' ); } // Get the AI SDK version of the tool without the execute function const tool = createEmployeeTool . toAISDK ({ executable : false , }); // Use the metadata for AI planning/generation const { toolCalls } = await generateText ({ model : openai ( 'gpt-5' ), tools : tool , prompt : 'Create a new employee in Workday, params: Full name: John Doe, personal email: john.doe@example.com, department: Engineering, start date: 2025-01-01, hire date: 2025-01-01' , maxSteps : 1 , }); // Human validation and modification step const toolCall = toolCalls [ 0 ] as ToolCall ; const shouldExecute = await simulateHumanValidation ( toolCall ); // Map of tool names to execution functions const executions : Record < string , ( args : Record < string , unknown > ) => Promise < JsonDict >> = { hris_create_employee : ( args ) => createEmployeeTool . execute ( args as JsonDict ), }; // Execute the tool if approved if ( shouldExecute && toolCall . toolName in executions ) { // You would call the tool here // const result = await executions[toolCall.toolName](toolCall.args); } else { console . log ( 'Tool execution was not approved or tool not found' ); } }; // Simulate human validation (in a real app, this would be your UI component) const simulateHumanValidation = async ( toolCall : ToolCall ) : Promise < boolean > => { // This is where you'd implement your UI for human validation assert ( toolCall . toolName === 'hris_create_employee' , 'Tool name is not hris_create_employee' ); assert ( toolCall . args . name === 'John Doe' , 'Name is not John Doe' ); assert ( toolCall . args . personal_email === 'john.doe@example.com' , 'Email is not john.doe@example.com' ); assert ( toolCall . args . department === 'Engineering' , 'Department is not Engineering' ); assert ( toolCall . args . start_date === '2025-01-01' , 'Start date is not 2025-01-01' ); assert ( toolCall . args . hire_date === '2025-01-01' , 'Hire date is not 2025-01-01' ); // In a real application, you might show a UI that allows the user to: // 1. Review the parameters // 2. Edit parameter values if needed // 3. Approve or reject the execution // For this example, we'll just approve automatically return true ; }; humanInTheLoopExample ();","title":"Human In The Loop"},{"location":"human-in-the-loop/#human-in-the-loop","text":"Example showing how to do human-in-the-loop workflows with StackOne using the split functionality. This allows for more granular control over tool execution and validation. Run this with: bun run examples/human-in-the-loop.ts import { assert } from 'node:console' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import type { JsonDict } from '../src/types' ; import { ACCOUNT_IDS } from './constants' ; interface ToolCall { toolName : string ; args : Record < string , unknown > ; } const humanInTheLoopExample = async () : Promise < void > => { // Create a toolset const toolset = new StackOneToolSet (); const hrisAccountId = ACCOUNT_IDS . HRIS ; // Get the create employee tool const createEmployeeTool = toolset . getTool ( 'hris_create_employee' , { 'x-account-id' : hrisAccountId , }); if ( ! createEmployeeTool ) { throw new Error ( 'Create employee tool not found' ); } // Get the AI SDK version of the tool without the execute function const tool = createEmployeeTool . toAISDK ({ executable : false , }); // Use the metadata for AI planning/generation const { toolCalls } = await generateText ({ model : openai ( 'gpt-5' ), tools : tool , prompt : 'Create a new employee in Workday, params: Full name: John Doe, personal email: john.doe@example.com, department: Engineering, start date: 2025-01-01, hire date: 2025-01-01' , maxSteps : 1 , }); // Human validation and modification step const toolCall = toolCalls [ 0 ] as ToolCall ; const shouldExecute = await simulateHumanValidation ( toolCall ); // Map of tool names to execution functions const executions : Record < string , ( args : Record < string , unknown > ) => Promise < JsonDict >> = { hris_create_employee : ( args ) => createEmployeeTool . execute ( args as JsonDict ), }; // Execute the tool if approved if ( shouldExecute && toolCall . toolName in executions ) { // You would call the tool here // const result = await executions[toolCall.toolName](toolCall.args); } else { console . log ( 'Tool execution was not approved or tool not found' ); } }; // Simulate human validation (in a real app, this would be your UI component) const simulateHumanValidation = async ( toolCall : ToolCall ) : Promise < boolean > => { // This is where you'd implement your UI for human validation assert ( toolCall . toolName === 'hris_create_employee' , 'Tool name is not hris_create_employee' ); assert ( toolCall . args . name === 'John Doe' , 'Name is not John Doe' ); assert ( toolCall . args . personal_email === 'john.doe@example.com' , 'Email is not john.doe@example.com' ); assert ( toolCall . args . department === 'Engineering' , 'Department is not Engineering' ); assert ( toolCall . args . start_date === '2025-01-01' , 'Start date is not 2025-01-01' ); assert ( toolCall . args . hire_date === '2025-01-01' , 'Hire date is not 2025-01-01' ); // In a real application, you might show a UI that allows the user to: // 1. Review the parameters // 2. Edit parameter values if needed // 3. Approve or reject the execution // For this example, we'll just approve automatically return true ; }; humanInTheLoopExample ();","title":"Human In The Loop"},{"location":"meta-tools/","text":"Meta Tools # This example demonstrates how to use meta tools for dynamic tool discovery and execution. Meta tools allow AI agents to search for relevant tools based on natural language queries and execute them dynamically without hardcoding tool names. @beta Meta tools are in beta and may change in future versions import process from 'node:process' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; Example 1: Using meta tools with AI SDK for dynamic tool discovery const metaToolsWithAISDK = async () : Promise < void > => { console . log ( '\ud83d\udd0d Example 1: Dynamic tool discovery with AI SDK\\n' ); // Initialize StackOne toolset with all available tools const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get all available tools for the account const allTools = toolset . getStackOneTools ( '*' , accountId ); // Get meta tools for dynamic discovery and execution const metaTools = await allTools . metaTools (); const aiSdkMetaTools = metaTools . toAISDK (); // Use meta tools to dynamically find and execute relevant tools const { text , toolCalls } = await generateText ({ model : openai ( 'gpt-4o-mini' ), tools : aiSdkMetaTools , prompt : `I need to create a time off request for an employee. First, find the right tool for this task, then use it to create a time off request for employee ID \"emp_123\" from January 15, 2024 to January 19, 2024.` , maxSteps : 3 , // Allow multiple tool calls }); console . log ( 'AI Response:' , text ); console . log ( '\\nTool calls made:' , toolCalls ? . map (( call ) => call . toolName ). join ( ', ' )); }; Example 2: Using meta tools with OpenAI for HR assistant const metaToolsWithOpenAI = async () : Promise < void > => { console . log ( '\\n\ud83e\udd16 Example 2: HR Assistant with OpenAI\\n' ); const { OpenAI } = await import ( 'openai' ); const openaiClient = new OpenAI ({ apiKey : process.env.OPENAI_API_KEY , }); // Initialize StackOne toolset const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get all HRIS tools const hrisTools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Get meta tools const metaTools = await hrisTools . metaTools (); const openAIMetaTools = metaTools . toOpenAI (); // Create an HR assistant that can discover and use tools dynamically const response = await openaiClient . chat . completions . create ({ model : 'gpt-4o-mini' , messages : [ { role : 'system' , content : `You are an HR assistant with access to various HR tools. Use the meta_search_tools to find appropriate tools for user requests, then use meta_execute_tool to execute them.` , }, { role : 'user' , content : 'Can you help me find tools for managing employee records and then list current employees?' , }, ], tools : openAIMetaTools , tool_choice : 'auto' , }); console . log ( 'Assistant response:' , response . choices [ 0 ]. message . content ); // Handle tool calls if any if ( response . choices [ 0 ]. message . tool_calls ) { console . log ( '\\nTool calls:' ); for ( const toolCall of response . choices [ 0 ]. message . tool_calls ) { console . log ( `- ${ toolCall . function . name } : ${ toolCall . function . arguments } ` ); } } }; Example 3: Direct usage of meta tools without AI const directMetaToolUsage = async () : Promise < void > => { console . log ( '\\n\ud83d\udee0\ufe0f Example 3: Direct meta tool usage\\n' ); // Initialize toolset const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get all available tools const allTools = toolset . getStackOneTools ( '*' , accountId ); console . log ( `Total available tools: ${ allTools . length } ` ); // Get meta tools const metaTools = await allTools . metaTools (); // Step 1: Search for relevant tools const filterTool = metaTools . getTool ( 'meta_search_tools' ); if ( ! filterTool ) throw new Error ( 'meta_search_tools not found' ); const searchResult = await filterTool . execute ({ query : 'employee management create update list' , limit : 5 , minScore : 0.3 , }); console . log ( 'Found relevant tools:' ); const foundTools = searchResult . tools as Array < { name : string ; description : string ; score : number ; } > ; for ( const tool of foundTools ) { console . log ( `- ${ tool . name } (score: ${ tool . score . toFixed ( 2 ) } ): ${ tool . description } ` ); } // Step 2: Execute one of the found tools if ( foundTools . length > 0 ) { const executeTool = metaTools . getTool ( 'meta_execute_tool' ); if ( ! executeTool ) throw new Error ( 'meta_execute_tool not found' ); const firstTool = foundTools [ 0 ]; console . log ( `\\nExecuting ${ firstTool . name } ...` ); try { // Prepare parameters based on the tool's schema let params : Record < string , unknown > = {}; if ( firstTool . name === 'hris_list_employees' ) { params = { limit : 5 }; } else if ( firstTool . name === 'hris_create_employee' ) { params = { name : 'John Doe' , email : 'john.doe@example.com' , title : 'Software Engineer' , }; } const result = await executeTool . execute ({ toolName : firstTool.name , params : params , }); console . log ( 'Execution result:' , JSON . stringify ( result , null , 2 )); } catch ( error ) { console . error ( 'Execution failed:' , error ); } } }; Example 4: Building a dynamic tool router const dynamicToolRouter = async () : Promise < void > => { console . log ( '\\n\ud83d\udd04 Example 4: Dynamic tool router\\n' ); const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get tools from multiple categories const hrisTools = toolset . getStackOneTools ( 'hris_*' , accountId ); const atsTools = toolset . getStackOneTools ( 'ats_*' , accountId ); // Combine tools const combinedTools = new ( await import ( '../src' )). Tools ([ ... hrisTools . toArray (), ... atsTools . toArray (), ]); // Get meta tools for the combined set const metaTools = await combinedTools . metaTools (); // Create a router function that finds and executes tools based on intent const routeAndExecute = async ( intent : string , params : Record < string , unknown > = {}) => { const filterTool = metaTools . getTool ( 'meta_search_tools' ); const executeTool = metaTools . getTool ( 'meta_execute_tool' ); if ( ! filterTool || ! executeTool ) throw new Error ( 'Meta tools not found' ); // Find relevant tools const searchResult = await filterTool . execute ({ query : intent , limit : 1 , minScore : 0.5 , }); const tools = searchResult . tools as Array < { name : string ; score : number } > ; if ( tools . length === 0 ) { return { error : 'No relevant tools found for the given intent' }; } const selectedTool = tools [ 0 ]; console . log ( `Routing to: ${ selectedTool . name } (score: ${ selectedTool . score . toFixed ( 2 ) } )` ); // Execute the selected tool return await executeTool . execute ({ toolName : selectedTool.name , params : params , }); }; // Test the router with different intents const intents = [ { intent : 'I want to see all employees' , params : { limit : 10 } }, { intent : 'Create a new job candidate' , params : { name : 'Jane Smith' , email : 'jane@example.com' }, }, { intent : 'Find recruitment candidates' , params : { status : 'active' } }, ]; for ( const { intent , params } of intents ) { console . log ( `\\nIntent: \" ${ intent } \"` ); const result = await routeAndExecute ( intent , params ); console . log ( 'Result:' , JSON . stringify ( result , null , 2 )); } }; // Main execution const main = async () => { try { // Run examples based on environment setup if ( process . env . OPENAI_API_KEY ) { await metaToolsWithAISDK (); await metaToolsWithOpenAI (); } else { console . log ( '\u26a0\ufe0f OPENAI_API_KEY not found, skipping AI examples\\n' ); } // These examples work without AI await directMetaToolUsage (); await dynamicToolRouter (); } catch ( error ) { console . error ( 'Error running examples:' , error ); } }; // Run if this file is executed directly if ( import . meta . main ) { main (); } export { metaToolsWithAISDK , metaToolsWithOpenAI , directMetaToolUsage , dynamicToolRouter };","title":"Meta Tools"},{"location":"meta-tools/#meta-tools","text":"This example demonstrates how to use meta tools for dynamic tool discovery and execution. Meta tools allow AI agents to search for relevant tools based on natural language queries and execute them dynamically without hardcoding tool names. @beta Meta tools are in beta and may change in future versions import process from 'node:process' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; Example 1: Using meta tools with AI SDK for dynamic tool discovery const metaToolsWithAISDK = async () : Promise < void > => { console . log ( '\ud83d\udd0d Example 1: Dynamic tool discovery with AI SDK\\n' ); // Initialize StackOne toolset with all available tools const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get all available tools for the account const allTools = toolset . getStackOneTools ( '*' , accountId ); // Get meta tools for dynamic discovery and execution const metaTools = await allTools . metaTools (); const aiSdkMetaTools = metaTools . toAISDK (); // Use meta tools to dynamically find and execute relevant tools const { text , toolCalls } = await generateText ({ model : openai ( 'gpt-4o-mini' ), tools : aiSdkMetaTools , prompt : `I need to create a time off request for an employee. First, find the right tool for this task, then use it to create a time off request for employee ID \"emp_123\" from January 15, 2024 to January 19, 2024.` , maxSteps : 3 , // Allow multiple tool calls }); console . log ( 'AI Response:' , text ); console . log ( '\\nTool calls made:' , toolCalls ? . map (( call ) => call . toolName ). join ( ', ' )); }; Example 2: Using meta tools with OpenAI for HR assistant const metaToolsWithOpenAI = async () : Promise < void > => { console . log ( '\\n\ud83e\udd16 Example 2: HR Assistant with OpenAI\\n' ); const { OpenAI } = await import ( 'openai' ); const openaiClient = new OpenAI ({ apiKey : process.env.OPENAI_API_KEY , }); // Initialize StackOne toolset const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get all HRIS tools const hrisTools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Get meta tools const metaTools = await hrisTools . metaTools (); const openAIMetaTools = metaTools . toOpenAI (); // Create an HR assistant that can discover and use tools dynamically const response = await openaiClient . chat . completions . create ({ model : 'gpt-4o-mini' , messages : [ { role : 'system' , content : `You are an HR assistant with access to various HR tools. Use the meta_search_tools to find appropriate tools for user requests, then use meta_execute_tool to execute them.` , }, { role : 'user' , content : 'Can you help me find tools for managing employee records and then list current employees?' , }, ], tools : openAIMetaTools , tool_choice : 'auto' , }); console . log ( 'Assistant response:' , response . choices [ 0 ]. message . content ); // Handle tool calls if any if ( response . choices [ 0 ]. message . tool_calls ) { console . log ( '\\nTool calls:' ); for ( const toolCall of response . choices [ 0 ]. message . tool_calls ) { console . log ( `- ${ toolCall . function . name } : ${ toolCall . function . arguments } ` ); } } }; Example 3: Direct usage of meta tools without AI const directMetaToolUsage = async () : Promise < void > => { console . log ( '\\n\ud83d\udee0\ufe0f Example 3: Direct meta tool usage\\n' ); // Initialize toolset const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get all available tools const allTools = toolset . getStackOneTools ( '*' , accountId ); console . log ( `Total available tools: ${ allTools . length } ` ); // Get meta tools const metaTools = await allTools . metaTools (); // Step 1: Search for relevant tools const filterTool = metaTools . getTool ( 'meta_search_tools' ); if ( ! filterTool ) throw new Error ( 'meta_search_tools not found' ); const searchResult = await filterTool . execute ({ query : 'employee management create update list' , limit : 5 , minScore : 0.3 , }); console . log ( 'Found relevant tools:' ); const foundTools = searchResult . tools as Array < { name : string ; description : string ; score : number ; } > ; for ( const tool of foundTools ) { console . log ( `- ${ tool . name } (score: ${ tool . score . toFixed ( 2 ) } ): ${ tool . description } ` ); } // Step 2: Execute one of the found tools if ( foundTools . length > 0 ) { const executeTool = metaTools . getTool ( 'meta_execute_tool' ); if ( ! executeTool ) throw new Error ( 'meta_execute_tool not found' ); const firstTool = foundTools [ 0 ]; console . log ( `\\nExecuting ${ firstTool . name } ...` ); try { // Prepare parameters based on the tool's schema let params : Record < string , unknown > = {}; if ( firstTool . name === 'hris_list_employees' ) { params = { limit : 5 }; } else if ( firstTool . name === 'hris_create_employee' ) { params = { name : 'John Doe' , email : 'john.doe@example.com' , title : 'Software Engineer' , }; } const result = await executeTool . execute ({ toolName : firstTool.name , params : params , }); console . log ( 'Execution result:' , JSON . stringify ( result , null , 2 )); } catch ( error ) { console . error ( 'Execution failed:' , error ); } } }; Example 4: Building a dynamic tool router const dynamicToolRouter = async () : Promise < void > => { console . log ( '\\n\ud83d\udd04 Example 4: Dynamic tool router\\n' ); const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get tools from multiple categories const hrisTools = toolset . getStackOneTools ( 'hris_*' , accountId ); const atsTools = toolset . getStackOneTools ( 'ats_*' , accountId ); // Combine tools const combinedTools = new ( await import ( '../src' )). Tools ([ ... hrisTools . toArray (), ... atsTools . toArray (), ]); // Get meta tools for the combined set const metaTools = await combinedTools . metaTools (); // Create a router function that finds and executes tools based on intent const routeAndExecute = async ( intent : string , params : Record < string , unknown > = {}) => { const filterTool = metaTools . getTool ( 'meta_search_tools' ); const executeTool = metaTools . getTool ( 'meta_execute_tool' ); if ( ! filterTool || ! executeTool ) throw new Error ( 'Meta tools not found' ); // Find relevant tools const searchResult = await filterTool . execute ({ query : intent , limit : 1 , minScore : 0.5 , }); const tools = searchResult . tools as Array < { name : string ; score : number } > ; if ( tools . length === 0 ) { return { error : 'No relevant tools found for the given intent' }; } const selectedTool = tools [ 0 ]; console . log ( `Routing to: ${ selectedTool . name } (score: ${ selectedTool . score . toFixed ( 2 ) } )` ); // Execute the selected tool return await executeTool . execute ({ toolName : selectedTool.name , params : params , }); }; // Test the router with different intents const intents = [ { intent : 'I want to see all employees' , params : { limit : 10 } }, { intent : 'Create a new job candidate' , params : { name : 'Jane Smith' , email : 'jane@example.com' }, }, { intent : 'Find recruitment candidates' , params : { status : 'active' } }, ]; for ( const { intent , params } of intents ) { console . log ( `\\nIntent: \" ${ intent } \"` ); const result = await routeAndExecute ( intent , params ); console . log ( 'Result:' , JSON . stringify ( result , null , 2 )); } }; // Main execution const main = async () => { try { // Run examples based on environment setup if ( process . env . OPENAI_API_KEY ) { await metaToolsWithAISDK (); await metaToolsWithOpenAI (); } else { console . log ( '\u26a0\ufe0f OPENAI_API_KEY not found, skipping AI examples\\n' ); } // These examples work without AI await directMetaToolUsage (); await dynamicToolRouter (); } catch ( error ) { console . error ( 'Error running examples:' , error ); } }; // Run if this file is executed directly if ( import . meta . main ) { main (); } export { metaToolsWithAISDK , metaToolsWithOpenAI , directMetaToolUsage , dynamicToolRouter };","title":"Meta Tools"},{"location":"openai-integration/","text":"Openai Integration # This example shows how to use StackOne tools with OpenAI. import assert from 'node:assert' ; import OpenAI from 'openai' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; const openaiIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get the correct tool const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); const openAITools = tools . toOpenAI (); // Initialize OpenAI client const openai = new OpenAI (); // Create a chat completion with tool calls const response = await openai . chat . completions . create ({ model : 'gpt-5' , messages : [ { role : 'system' , content : 'You are a helpful assistant that can access HRIS information.' , }, { role : 'user' , content : 'What is the employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA phone number?' , }, ], tools : openAITools , }); // Verify the response contains tool calls assert ( response . choices . length > 0 , 'Expected at least one choice in the response' ); const choice = response . choices [ 0 ]; assert ( choice . message . tool_calls !== undefined , 'Expected tool_calls to be defined' ); assert ( choice . message . tool_calls . length > 0 , 'Expected at least one tool call' ); const toolCall = choice . message . tool_calls [ 0 ]; assert ( toolCall . function . name === 'hris_get_employee' , 'Expected tool call to be hris_get_employee' ); // Parse the arguments to verify they contain the expected fields const args = JSON . parse ( toolCall . function . arguments ); assert ( args . id === 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , 'Expected id to match the query' ); assert ( args . fields !== undefined , 'Expected fields to be defined' ); }; // Run the example openaiIntegration ();","title":"OpenAI"},{"location":"openai-integration/#openai-integration","text":"This example shows how to use StackOne tools with OpenAI. import assert from 'node:assert' ; import OpenAI from 'openai' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; const openaiIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = ACCOUNT_IDS . HRIS ; // Get the correct tool const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); const openAITools = tools . toOpenAI (); // Initialize OpenAI client const openai = new OpenAI (); // Create a chat completion with tool calls const response = await openai . chat . completions . create ({ model : 'gpt-5' , messages : [ { role : 'system' , content : 'You are a helpful assistant that can access HRIS information.' , }, { role : 'user' , content : 'What is the employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA phone number?' , }, ], tools : openAITools , }); // Verify the response contains tool calls assert ( response . choices . length > 0 , 'Expected at least one choice in the response' ); const choice = response . choices [ 0 ]; assert ( choice . message . tool_calls !== undefined , 'Expected tool_calls to be defined' ); assert ( choice . message . tool_calls . length > 0 , 'Expected at least one tool call' ); const toolCall = choice . message . tool_calls [ 0 ]; assert ( toolCall . function . name === 'hris_get_employee' , 'Expected tool call to be hris_get_employee' ); // Parse the arguments to verify they contain the expected fields const args = JSON . parse ( toolCall . function . arguments ); assert ( args . id === 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , 'Expected id to match the query' ); assert ( args . fields !== undefined , 'Expected fields to be defined' ); }; // Run the example openaiIntegration ();","title":"Openai Integration"},{"location":"openapi-toolset/","text":"Openapi Toolset # Basic OpenAPI Example This example demonstrates how to: 1. Load OpenAPI specifications from a file 2. Load OpenAPI specifications from a URL 3. Get and execute tools from the specifications import assert from 'node:assert' ; import { OpenAPIToolSet } from '../src/toolsets/openapi' ; import { joinPaths } from '../src/utils/file' ; Type for dry run result type DryRunResult = { url : string ; method : string ; headers? : Record < string , string > ; body? : string ; }; Example of loading OpenAPI specifications from a file async function fromFileExample () : Promise < void > { // Create an OpenAPIToolSet from a local file const toolset = new OpenAPIToolSet ({ filePath : joinPaths ( process . cwd (), 'src' , 'toolsets' , 'tests' , 'fixtures' , 'petstore.json' ), }); // Get all tools const tools = toolset . getTools ( '*Pet*' ); assert ( tools . length > 0 , 'Expected to find tools in the specification' ); // Get a specific tool const getPetTool = tools . getTool ( 'getPetById' ); assert ( getPetTool !== undefined , 'Expected to find getPetById tool' ); // Execute the tool with dry run to see what would be sent const result = ( await getPetTool . execute ({ petId : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . url . includes ( '/pet/123' ), 'Expected URL to contain pet ID' ); assert ( result . method === 'GET' , 'Expected GET method' ); } Example of loading OpenAPI specifications from a URL async function fromUrlExample () : Promise < void > { try { // Create an OpenAPIToolSet from a URL const toolset = await OpenAPIToolSet . fromUrl ({ url : 'https://api.eu1.stackone.com/oas/hris.json' , }); // Get tools matching a pattern const hrisTools = toolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Expected to find a bunch of tools' ); // Get a specific tool const getEmployeeTool = hrisTools . getTool ( 'hris_get_employee' ); assert ( getEmployeeTool !== undefined , 'Expected to find hris_get_employee tool' ); assert ( typeof getEmployeeTool . parameters . properties . id === 'object' && getEmployeeTool . parameters . properties . id !== null && getEmployeeTool . parameters . properties . id . type === 'string' , 'Expected to find string parameter for id' ); // Execute the tool with dry run to see what would be sent const result = ( await getEmployeeTool . execute ({ id : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . method === 'GET' , 'Expected GET method' ); assert ( result . url . includes ( '/employees/123' ), 'Expected URL to contain employee ID' ); assert ( result . body === undefined , 'Expected body to be undefined' ); } catch ( error ) { throw new Error ( `Failed to load from URL: ${ error instanceof Error ? error.message : String ( error ) } ` ); } } Run the examples async function main () : Promise < void > { try { // Run the file example await fromFileExample (); // Run the URL example await fromUrlExample (); } catch ( error ) { console . error ( error ); process . exit ( 1 ); } } main ();","title":"Getting Started"},{"location":"openapi-toolset/#openapi-toolset","text":"Basic OpenAPI Example This example demonstrates how to: 1. Load OpenAPI specifications from a file 2. Load OpenAPI specifications from a URL 3. Get and execute tools from the specifications import assert from 'node:assert' ; import { OpenAPIToolSet } from '../src/toolsets/openapi' ; import { joinPaths } from '../src/utils/file' ; Type for dry run result type DryRunResult = { url : string ; method : string ; headers? : Record < string , string > ; body? : string ; }; Example of loading OpenAPI specifications from a file async function fromFileExample () : Promise < void > { // Create an OpenAPIToolSet from a local file const toolset = new OpenAPIToolSet ({ filePath : joinPaths ( process . cwd (), 'src' , 'toolsets' , 'tests' , 'fixtures' , 'petstore.json' ), }); // Get all tools const tools = toolset . getTools ( '*Pet*' ); assert ( tools . length > 0 , 'Expected to find tools in the specification' ); // Get a specific tool const getPetTool = tools . getTool ( 'getPetById' ); assert ( getPetTool !== undefined , 'Expected to find getPetById tool' ); // Execute the tool with dry run to see what would be sent const result = ( await getPetTool . execute ({ petId : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . url . includes ( '/pet/123' ), 'Expected URL to contain pet ID' ); assert ( result . method === 'GET' , 'Expected GET method' ); } Example of loading OpenAPI specifications from a URL async function fromUrlExample () : Promise < void > { try { // Create an OpenAPIToolSet from a URL const toolset = await OpenAPIToolSet . fromUrl ({ url : 'https://api.eu1.stackone.com/oas/hris.json' , }); // Get tools matching a pattern const hrisTools = toolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Expected to find a bunch of tools' ); // Get a specific tool const getEmployeeTool = hrisTools . getTool ( 'hris_get_employee' ); assert ( getEmployeeTool !== undefined , 'Expected to find hris_get_employee tool' ); assert ( typeof getEmployeeTool . parameters . properties . id === 'object' && getEmployeeTool . parameters . properties . id !== null && getEmployeeTool . parameters . properties . id . type === 'string' , 'Expected to find string parameter for id' ); // Execute the tool with dry run to see what would be sent const result = ( await getEmployeeTool . execute ({ id : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . method === 'GET' , 'Expected GET method' ); assert ( result . url . includes ( '/employees/123' ), 'Expected URL to contain employee ID' ); assert ( result . body === undefined , 'Expected body to be undefined' ); } catch ( error ) { throw new Error ( `Failed to load from URL: ${ error instanceof Error ? error.message : String ( error ) } ` ); } } Run the examples async function main () : Promise < void > { try { // Run the file example await fromFileExample (); // Run the URL example await fromUrlExample (); } catch ( error ) { console . error ( error ); process . exit ( 1 ); } } main ();","title":"Openapi Toolset"},{"location":"planning/","text":"Planning # While building agents you may find that your workflow is too complex for a general purpose agent. StackOne AI SDK provides access to a state of the art planning agent which allows you to create, cache, and execute complex workflows on verticals supported by StackOne . For example, onboard a new hire from your ATS to your HRIS. import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; export const planningModule = async () : Promise < void > => { const toolset = new StackOneToolSet (); const onboardWorkflow = await toolset . plan ({ key : 'custom_onboarding' , input : 'Onboard the last new hire from Teamtailor to Workday' , model : 'stackone-planner-latest' , tools : [ 'hris_*' , 'ats_*' ], accountIds : [ ACCOUNT_IDS . ATS , ACCOUNT_IDS . HRIS ], cache : true , // saves the plan to $HOME/.stackone/plans }); await onboardWorkflow . execute (); or use as part of a larger agent (using AI SDK by Vercel) await generateText ({ model : openai ( 'gpt-5' ), prompt : 'You are a workplace agent, onboard the latest hires to our systems' , tools : onboardWorkflow.toAISDK (), maxSteps : 3 , }); }; console . log ( 'Planning module is in closed beta and only available to design partners.' ); console . log ( 'Apply for the waitlist [here](https://www.stackone.com/demo).' );","title":"Planning"},{"location":"planning/#planning","text":"While building agents you may find that your workflow is too complex for a general purpose agent. StackOne AI SDK provides access to a state of the art planning agent which allows you to create, cache, and execute complex workflows on verticals supported by StackOne . For example, onboard a new hire from your ATS to your HRIS. import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import { ACCOUNT_IDS } from './constants' ; export const planningModule = async () : Promise < void > => { const toolset = new StackOneToolSet (); const onboardWorkflow = await toolset . plan ({ key : 'custom_onboarding' , input : 'Onboard the last new hire from Teamtailor to Workday' , model : 'stackone-planner-latest' , tools : [ 'hris_*' , 'ats_*' ], accountIds : [ ACCOUNT_IDS . ATS , ACCOUNT_IDS . HRIS ], cache : true , // saves the plan to $HOME/.stackone/plans }); await onboardWorkflow . execute (); or use as part of a larger agent (using AI SDK by Vercel) await generateText ({ model : openai ( 'gpt-5' ), prompt : 'You are a workplace agent, onboard the latest hires to our systems' , tools : onboardWorkflow.toAISDK (), maxSteps : 3 , }); }; console . log ( 'Planning module is in closed beta and only available to design partners.' ); console . log ( 'Apply for the waitlist [here](https://www.stackone.com/demo).' );","title":"Planning"}]}