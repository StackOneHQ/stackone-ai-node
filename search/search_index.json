{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"StackOne AI SDK # Installation # # Using npm npm install @stackone/ai # Using yarn yarn add @stackone/ai # Using bun bun add @stackone/ai Authentication # Set the STACKONE_API_KEY environment variable: export STACKONE_API_KEY = <your-api-key> or load from a .env file: // Load environment variables from .env file import * as dotenv from 'dotenv' ; dotenv . config (); Account IDs # StackOne uses account IDs to identify different integrations. See the example in the README for more details. This example will hardcode the account ID: const accountId = '45072196112816593343' ; Quickstart # import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const quickstart = async () : Promise < void > => { const toolset = new StackOneToolSet (); // Get all HRIS-related tools using the StackOneTool method (adds accountId to the request) const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Verify we have tools assert ( tools . length > 0 , 'Expected to find HRIS tools' ); // Use a specific tool const employeeTool = tools . getTool ( 'hris_list_employees' ); assert ( employeeTool !== undefined , 'Expected to find hris_list_employees tool' ); // Execute the tool and verify the response const employees = await employeeTool . execute (); assert ( Array . isArray ( employees ), 'Expected employees to be an array' ); assert ( employees . length > 0 , 'Expected to find at least one employee' ); }; // Run the example quickstart (); Next Steps # Check out some more examples: OpenAI Integration AI SDK Integration Error Handling File Uploads Custom Base URL Account ID Usage","title":"Home"},{"location":"#stackone-ai-sdk","text":"","title":"StackOne AI SDK"},{"location":"#installation","text":"# Using npm npm install @stackone/ai # Using yarn yarn add @stackone/ai # Using bun bun add @stackone/ai","title":"Installation"},{"location":"#authentication","text":"Set the STACKONE_API_KEY environment variable: export STACKONE_API_KEY = <your-api-key> or load from a .env file: // Load environment variables from .env file import * as dotenv from 'dotenv' ; dotenv . config ();","title":"Authentication"},{"location":"#account-ids","text":"StackOne uses account IDs to identify different integrations. See the example in the README for more details. This example will hardcode the account ID: const accountId = '45072196112816593343' ;","title":"Account IDs"},{"location":"#quickstart","text":"import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const quickstart = async () : Promise < void > => { const toolset = new StackOneToolSet (); // Get all HRIS-related tools using the StackOneTool method (adds accountId to the request) const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Verify we have tools assert ( tools . length > 0 , 'Expected to find HRIS tools' ); // Use a specific tool const employeeTool = tools . getTool ( 'hris_list_employees' ); assert ( employeeTool !== undefined , 'Expected to find hris_list_employees tool' ); // Execute the tool and verify the response const employees = await employeeTool . execute (); assert ( Array . isArray ( employees ), 'Expected employees to be an array' ); assert ( employees . length > 0 , 'Expected to find at least one employee' ); }; // Run the example quickstart ();","title":"Quickstart"},{"location":"#next-steps","text":"Check out some more examples: OpenAI Integration AI SDK Integration Error Handling File Uploads Custom Base URL Account ID Usage","title":"Next Steps"},{"location":"account-id-usage/","text":"Account Id Usage # Example demonstrating different ways to set the account ID when using StackOne tools. This example shows: 1. Setting account ID when initializing the toolset 2. Setting account ID when getting tools 3. Using setAccountId method directly on a tool Usage: bun run examples/account-id-usage.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const accountIdUsage = async () : Promise < void > => { /* * Set account ID on toolset initialization */ const toolset = new StackOneToolSet ({ accountId : 'initial-account-id' }); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getStackOneTool ( 'hris_list_employees' ); assert ( employeeTool . getAccountId () === 'initial-account-id' , 'Account ID should match what was set' ); /* * Setting account ID when getting tools (overrides toolset account ID) */ const toolsWithOverride = toolset . getStackOneTools ( 'hris_*' , 'override-account-id' ); const employeeToolWithOverride = toolsWithOverride . getStackOneTool ( 'hris_list_employees' ); assert ( employeeToolWithOverride ? . getAccountId () === 'override-account-id' , 'Account ID should match what was set' ); /* * Set the account ID directly on the tool */ employeeTool . setAccountId ( 'direct-account-id' ); assert ( employeeTool . getAccountId () === 'direct-account-id' , 'Account ID should match what was set' ); }; accountIdUsage ();","title":"Account IDs"},{"location":"account-id-usage/#account-id-usage","text":"Example demonstrating different ways to set the account ID when using StackOne tools. This example shows: 1. Setting account ID when initializing the toolset 2. Setting account ID when getting tools 3. Using setAccountId method directly on a tool Usage: bun run examples/account-id-usage.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const accountIdUsage = async () : Promise < void > => { /* * Set account ID on toolset initialization */ const toolset = new StackOneToolSet ({ accountId : 'initial-account-id' }); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getStackOneTool ( 'hris_list_employees' ); assert ( employeeTool . getAccountId () === 'initial-account-id' , 'Account ID should match what was set' ); /* * Setting account ID when getting tools (overrides toolset account ID) */ const toolsWithOverride = toolset . getStackOneTools ( 'hris_*' , 'override-account-id' ); const employeeToolWithOverride = toolsWithOverride . getStackOneTool ( 'hris_list_employees' ); assert ( employeeToolWithOverride ? . getAccountId () === 'override-account-id' , 'Account ID should match what was set' ); /* * Set the account ID directly on the tool */ employeeTool . setAccountId ( 'direct-account-id' ); assert ( employeeTool . getAccountId () === 'direct-account-id' , 'Account ID should match what was set' ); }; accountIdUsage ();","title":"Account Id Usage"},{"location":"ai-sdk-integration/","text":"Ai Sdk Integration # This example shows how to use StackOne tools with the AI SDK. import assert from 'node:assert' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; const aiSdkIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = '45072196112816593343' ; // Get HRIS tools const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); // Convert to AI SDK tools const aiSdkTools = tools . toAISDK (); // Use max steps to automatically call the tool if it's needed const { text } = await generateText ({ model : openai ( 'gpt-4o-mini' ), tools : aiSdkTools , prompt : 'Get all details about employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , maxSteps : 3 , }); assert ( text . includes ( 'Isacc Newton' ), 'Expected employee name to be included in the response' ); }; aiSdkIntegration ();","title":"AI SDK"},{"location":"ai-sdk-integration/#ai-sdk-integration","text":"This example shows how to use StackOne tools with the AI SDK. import assert from 'node:assert' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; const aiSdkIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = '45072196112816593343' ; // Get HRIS tools const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); // Convert to AI SDK tools const aiSdkTools = tools . toAISDK (); // Use max steps to automatically call the tool if it's needed const { text } = await generateText ({ model : openai ( 'gpt-4o-mini' ), tools : aiSdkTools , prompt : 'Get all details about employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , maxSteps : 3 , }); assert ( text . includes ( 'Isacc Newton' ), 'Expected employee name to be included in the response' ); }; aiSdkIntegration ();","title":"Ai Sdk Integration"},{"location":"custom-base-url/","text":"Custom Base Url # Example demonstrating how to use a custom base URL with StackOne tools. This is useful for: 1. Testing against development APIs 2. Working with self-hosted StackOne instances Usage: bun run examples/custom-base-url.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const customBaseUrl = async () : Promise < void > => { Default base URL const defaultToolset = new StackOneToolSet (); const hrisTools = defaultToolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Should have at least one HRIS tool' ); const defaultTool = hrisTools . getTool ( 'hris_get_employee' ); if ( ! defaultTool ) { throw new Error ( 'Tool not found' ); } Custom base URL const devToolset = new StackOneToolSet ({ baseUrl : 'https://api.example-dev.com' , }); const devHrisTools = devToolset . getTools ( 'hris_*' ); assert ( devHrisTools . length > 0 , 'Should have at least one HRIS tool' ); const devTool = devHrisTools . getTool ( 'hris_get_employee' ); if ( ! devTool ) { throw new Error ( 'Tool not found' ); } Note this uses the same tools but substitutes the base URL if ( defaultTool && devTool ) { assert ( defaultTool . name === devTool . name , 'Tool names should be the same' ); assert ( defaultTool . executeConfig . url . includes ( 'https://api.stackone.com' ), 'Default tool should use the default base URL' ); assert ( devTool . executeConfig . url . includes ( 'https://api.example-dev.com' ), 'Custom tool should use the custom base URL' ); } }; customBaseUrl ();","title":"Custom Base URL"},{"location":"custom-base-url/#custom-base-url","text":"Example demonstrating how to use a custom base URL with StackOne tools. This is useful for: 1. Testing against development APIs 2. Working with self-hosted StackOne instances Usage: bun run examples/custom-base-url.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const customBaseUrl = async () : Promise < void > => { Default base URL const defaultToolset = new StackOneToolSet (); const hrisTools = defaultToolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Should have at least one HRIS tool' ); const defaultTool = hrisTools . getTool ( 'hris_get_employee' ); if ( ! defaultTool ) { throw new Error ( 'Tool not found' ); } Custom base URL const devToolset = new StackOneToolSet ({ baseUrl : 'https://api.example-dev.com' , }); const devHrisTools = devToolset . getTools ( 'hris_*' ); assert ( devHrisTools . length > 0 , 'Should have at least one HRIS tool' ); const devTool = devHrisTools . getTool ( 'hris_get_employee' ); if ( ! devTool ) { throw new Error ( 'Tool not found' ); } Note this uses the same tools but substitutes the base URL if ( defaultTool && devTool ) { assert ( defaultTool . name === devTool . name , 'Tool names should be the same' ); assert ( defaultTool . executeConfig . url . includes ( 'https://api.stackone.com' ), 'Default tool should use the default base URL' ); assert ( devTool . executeConfig . url . includes ( 'https://api.example-dev.com' ), 'Custom tool should use the custom base URL' ); } }; customBaseUrl ();","title":"Custom Base Url"},{"location":"error-handling/","text":"Error Handling # Error Handling # This example shows how to handle errors when using the StackOne SDK. import assert from 'node:assert' ; import { StackOneAPIError , StackOneError , StackOneToolSet , ToolSetConfigError } from '../src' ; const errorHandling = async () : Promise < void > => { // Example 1: Handle initialization errors const testInitializationErrors = async () : Promise < void > => { // Temporarily save the API key const originalKey = process . env . STACKONE_API_KEY ; // Delete the API key to force an error process . env . STACKONE_API_KEY = undefined ; try { // This will throw a ToolsetConfigError const _toolset = new StackOneToolSet ({ strict : true , }); assert ( false , 'Expected ToolSetConfigError was not thrown' ); } catch ( error ) { assert ( error instanceof ToolSetConfigError , 'Expected error to be ToolSetConfigError' ); } finally { // Restore the API key process . env . STACKONE_API_KEY = originalKey ; } }; // Example 2: Handle API errors const testApiErrors = async () : Promise < void > => { const toolset = new StackOneToolSet (); const accountId = 'invalid-account-id' ; // Invalid account ID to force an error try { const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); const employeeTool = tools . getTool ( 'hris_list_employees' ); if ( employeeTool ) { // This will throw a StackOneAPIError due to the invalid account ID await employeeTool . execute (); assert ( false , 'Expected StackOneAPIError was not thrown' ); } } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError , 'Expected error to be StackOneAPIError or StackOneError' ); if ( error instanceof StackOneAPIError ) { assert ( error . statusCode !== undefined , 'Expected statusCode to be defined' ); assert ( error . responseBody !== undefined , 'Expected responseBody to be defined' ); } } }; // Example 3: Handle invalid tool name const testInvalidToolName = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const nonExistentTool = tools . getTool ( 'non_existent_tool' ); assert ( nonExistentTool === undefined , 'Expected non-existent tool to be undefined' ); }; // Example 4: Handle invalid arguments const testInvalidArguments = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getTool ( 'hris_get_employee' ); if ( employeeTool ) { try { // This will throw an error due to missing required arguments await employeeTool . execute (); assert ( false , 'Expected error was not thrown for missing arguments' ); } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError || error instanceof Error , 'Expected error to be a known error type' ); } } }; // Run all tests await testInitializationErrors (); await testApiErrors (); await testInvalidToolName (); await testInvalidArguments (); }; // Run the example errorHandling ();","title":"Error Handling"},{"location":"error-handling/#error-handling","text":"","title":"Error Handling"},{"location":"error-handling/#error-handling_1","text":"This example shows how to handle errors when using the StackOne SDK. import assert from 'node:assert' ; import { StackOneAPIError , StackOneError , StackOneToolSet , ToolSetConfigError } from '../src' ; const errorHandling = async () : Promise < void > => { // Example 1: Handle initialization errors const testInitializationErrors = async () : Promise < void > => { // Temporarily save the API key const originalKey = process . env . STACKONE_API_KEY ; // Delete the API key to force an error process . env . STACKONE_API_KEY = undefined ; try { // This will throw a ToolsetConfigError const _toolset = new StackOneToolSet ({ strict : true , }); assert ( false , 'Expected ToolSetConfigError was not thrown' ); } catch ( error ) { assert ( error instanceof ToolSetConfigError , 'Expected error to be ToolSetConfigError' ); } finally { // Restore the API key process . env . STACKONE_API_KEY = originalKey ; } }; // Example 2: Handle API errors const testApiErrors = async () : Promise < void > => { const toolset = new StackOneToolSet (); const accountId = 'invalid-account-id' ; // Invalid account ID to force an error try { const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); const employeeTool = tools . getTool ( 'hris_list_employees' ); if ( employeeTool ) { // This will throw a StackOneAPIError due to the invalid account ID await employeeTool . execute (); assert ( false , 'Expected StackOneAPIError was not thrown' ); } } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError , 'Expected error to be StackOneAPIError or StackOneError' ); if ( error instanceof StackOneAPIError ) { assert ( error . statusCode !== undefined , 'Expected statusCode to be defined' ); assert ( error . responseBody !== undefined , 'Expected responseBody to be defined' ); } } }; // Example 3: Handle invalid tool name const testInvalidToolName = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const nonExistentTool = tools . getTool ( 'non_existent_tool' ); assert ( nonExistentTool === undefined , 'Expected non-existent tool to be undefined' ); }; // Example 4: Handle invalid arguments const testInvalidArguments = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getTool ( 'hris_get_employee' ); if ( employeeTool ) { try { // This will throw an error due to missing required arguments await employeeTool . execute (); assert ( false , 'Expected error was not thrown for missing arguments' ); } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError || error instanceof Error , 'Expected error to be a known error type' ); } } }; // Run all tests await testInitializationErrors (); await testApiErrors (); await testInvalidToolName (); await testInvalidArguments (); }; // Run the example errorHandling ();","title":"Error Handling"},{"location":"file-uploads/","text":"File Uploads # Example showing how to upload files using the StackOne SDK. This example demonstrates how to upload files using the simplified file_path parameter, which is the only parameter needed for file uploads. The SDK automatically derives the necessary file parameters (content, name, file_format) from the file_path. Run this example with: bun run examples/file-uploads.ts import assert from 'node:assert' ; import * as fs from 'node:fs' ; import * as path from 'node:path' ; import { StackOneToolSet } from '../src' ; const accountId = '45072196112816593343' ; const fileUploads = async () : Promise < void > => { // Create a sample file for testing const sampleFilePath = path . join ( __dirname , 'sample-file.txt' ); fs . writeFileSync ( sampleFilePath , 'This is a sample file for testing file uploads.' ); try { // Initialize the StackOne toolset const toolset = new StackOneToolSet (); // Get tools for documents const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Get the upload file tool const uploadTool = tools . getTool ( 'hris_upload_employee_document' ); // Check if upload tool exists assert ( uploadTool !== undefined , 'Upload document tool not found' ); /* * Upload a file using the file_path parameter * The SDK will automatically derive content, name, and file_format from the file_path */ // Use dry run to check parameter mapping const dryRunResult = await uploadTool . execute ( { file_path : sampleFilePath , id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true } ); assert ( ( dryRunResult . mappedParams as Record < string , { value : string } > ). file_format . value === 'txt' , 'File format was not mapped correctly' ); } finally { // Clean up the sample file if ( fs . existsSync ( sampleFilePath )) { fs . unlinkSync ( sampleFilePath ); } } }; fileUploads ();","title":"File Uploads"},{"location":"file-uploads/#file-uploads","text":"Example showing how to upload files using the StackOne SDK. This example demonstrates how to upload files using the simplified file_path parameter, which is the only parameter needed for file uploads. The SDK automatically derives the necessary file parameters (content, name, file_format) from the file_path. Run this example with: bun run examples/file-uploads.ts import assert from 'node:assert' ; import * as fs from 'node:fs' ; import * as path from 'node:path' ; import { StackOneToolSet } from '../src' ; const accountId = '45072196112816593343' ; const fileUploads = async () : Promise < void > => { // Create a sample file for testing const sampleFilePath = path . join ( __dirname , 'sample-file.txt' ); fs . writeFileSync ( sampleFilePath , 'This is a sample file for testing file uploads.' ); try { // Initialize the StackOne toolset const toolset = new StackOneToolSet (); // Get tools for documents const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Get the upload file tool const uploadTool = tools . getTool ( 'hris_upload_employee_document' ); // Check if upload tool exists assert ( uploadTool !== undefined , 'Upload document tool not found' ); /* * Upload a file using the file_path parameter * The SDK will automatically derive content, name, and file_format from the file_path */ // Use dry run to check parameter mapping const dryRunResult = await uploadTool . execute ( { file_path : sampleFilePath , id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true } ); assert ( ( dryRunResult . mappedParams as Record < string , { value : string } > ). file_format . value === 'txt' , 'File format was not mapped correctly' ); } finally { // Clean up the sample file if ( fs . existsSync ( sampleFilePath )) { fs . unlinkSync ( sampleFilePath ); } } }; fileUploads ();","title":"File Uploads"},{"location":"human-in-the-loop/","text":"Human In The Loop # Example showing how to do human-in-the-loop workflows with StackOne using the split functionality. This allows for more granular control over tool execution and validation. Run this with: bun run examples/human-in-the-loop.ts import { assert } from 'node:console' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import type { JsonDict } from '../src/types' ; interface ToolCall { toolName : string ; args : Record < string , unknown > ; } const humanInTheLoopExample = async () : Promise < void > => { // Create a toolset const toolset = new StackOneToolSet (); const hrisAccountId = 'workday_account_id' ; // Get the create employee tool const createEmployeeTool = toolset . getTool ( 'hris_create_employee' , { 'x-account-id' : hrisAccountId , }); if ( ! createEmployeeTool ) { throw new Error ( 'Create employee tool not found' ); } // Get the AI SDK version of the tool without the execute function const tool = createEmployeeTool . toAISDK ({ executable : false , }); // Use the metadata for AI planning/generation const { toolCalls } = await generateText ({ model : openai ( 'gpt-4o' ), tools : tool , prompt : 'Create a new employee in Workday, params: Full name: John Doe, personal email: john.doe@example.com, department: Engineering, start date: 2025-01-01, hire date: 2025-01-01' , maxSteps : 1 , }); // Human validation and modification step const toolCall = toolCalls [ 0 ] as ToolCall ; const shouldExecute = await simulateHumanValidation ( toolCall ); // Map of tool names to execution functions const executions : Record < string , ( args : Record < string , unknown > ) => Promise < JsonDict >> = { hris_create_employee : ( args ) => createEmployeeTool . execute ( args as JsonDict ), }; // Execute the tool if approved if ( shouldExecute && toolCall . toolName in executions ) { // You would call the tool here // const result = await executions[toolCall.toolName](toolCall.args); } else { console . log ( 'Tool execution was not approved or tool not found' ); } }; // Simulate human validation (in a real app, this would be your UI component) const simulateHumanValidation = async ( toolCall : ToolCall ) : Promise < boolean > => { // This is where you'd implement your UI for human validation assert ( toolCall . toolName === 'hris_create_employee' , 'Tool name is not hris_create_employee' ); assert ( toolCall . args . name === 'John Doe' , 'Name is not John Doe' ); assert ( toolCall . args . personal_email === 'john.doe@example.com' , 'Email is not john.doe@example.com' ); assert ( toolCall . args . department === 'Engineering' , 'Department is not Engineering' ); assert ( toolCall . args . start_date === '2025-01-01' , 'Start date is not 2025-01-01' ); assert ( toolCall . args . hire_date === '2025-01-01' , 'Hire date is not 2025-01-01' ); // In a real application, you might show a UI that allows the user to: // 1. Review the parameters // 2. Edit parameter values if needed // 3. Approve or reject the execution // For this example, we'll just approve automatically return true ; }; humanInTheLoopExample ();","title":"Human In The Loop"},{"location":"human-in-the-loop/#human-in-the-loop","text":"Example showing how to do human-in-the-loop workflows with StackOne using the split functionality. This allows for more granular control over tool execution and validation. Run this with: bun run examples/human-in-the-loop.ts import { assert } from 'node:console' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import type { JsonDict } from '../src/types' ; interface ToolCall { toolName : string ; args : Record < string , unknown > ; } const humanInTheLoopExample = async () : Promise < void > => { // Create a toolset const toolset = new StackOneToolSet (); const hrisAccountId = 'workday_account_id' ; // Get the create employee tool const createEmployeeTool = toolset . getTool ( 'hris_create_employee' , { 'x-account-id' : hrisAccountId , }); if ( ! createEmployeeTool ) { throw new Error ( 'Create employee tool not found' ); } // Get the AI SDK version of the tool without the execute function const tool = createEmployeeTool . toAISDK ({ executable : false , }); // Use the metadata for AI planning/generation const { toolCalls } = await generateText ({ model : openai ( 'gpt-4o' ), tools : tool , prompt : 'Create a new employee in Workday, params: Full name: John Doe, personal email: john.doe@example.com, department: Engineering, start date: 2025-01-01, hire date: 2025-01-01' , maxSteps : 1 , }); // Human validation and modification step const toolCall = toolCalls [ 0 ] as ToolCall ; const shouldExecute = await simulateHumanValidation ( toolCall ); // Map of tool names to execution functions const executions : Record < string , ( args : Record < string , unknown > ) => Promise < JsonDict >> = { hris_create_employee : ( args ) => createEmployeeTool . execute ( args as JsonDict ), }; // Execute the tool if approved if ( shouldExecute && toolCall . toolName in executions ) { // You would call the tool here // const result = await executions[toolCall.toolName](toolCall.args); } else { console . log ( 'Tool execution was not approved or tool not found' ); } }; // Simulate human validation (in a real app, this would be your UI component) const simulateHumanValidation = async ( toolCall : ToolCall ) : Promise < boolean > => { // This is where you'd implement your UI for human validation assert ( toolCall . toolName === 'hris_create_employee' , 'Tool name is not hris_create_employee' ); assert ( toolCall . args . name === 'John Doe' , 'Name is not John Doe' ); assert ( toolCall . args . personal_email === 'john.doe@example.com' , 'Email is not john.doe@example.com' ); assert ( toolCall . args . department === 'Engineering' , 'Department is not Engineering' ); assert ( toolCall . args . start_date === '2025-01-01' , 'Start date is not 2025-01-01' ); assert ( toolCall . args . hire_date === '2025-01-01' , 'Hire date is not 2025-01-01' ); // In a real application, you might show a UI that allows the user to: // 1. Review the parameters // 2. Edit parameter values if needed // 3. Approve or reject the execution // For this example, we'll just approve automatically return true ; }; humanInTheLoopExample ();","title":"Human In The Loop"},{"location":"openai-integration/","text":"Openai Integration # This example shows how to use StackOne tools with OpenAI. import assert from 'node:assert' ; import OpenAI from 'openai' ; import { StackOneToolSet } from '../src' ; const openaiIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = '45072196112816593343' ; // Get the correct tool const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); const openAITools = tools . toOpenAI (); // Initialize OpenAI client const openai = new OpenAI (); // Create a chat completion with tool calls const response = await openai . chat . completions . create ({ model : 'gpt-4o-mini' , messages : [ { role : 'system' , content : 'You are a helpful assistant that can access HRIS information.' , }, { role : 'user' , content : 'What is the employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA phone number?' , }, ], tools : openAITools , }); // Verify the response contains tool calls assert ( response . choices . length > 0 , 'Expected at least one choice in the response' ); const choice = response . choices [ 0 ]; assert ( choice . message . tool_calls !== undefined , 'Expected tool_calls to be defined' ); assert ( choice . message . tool_calls . length > 0 , 'Expected at least one tool call' ); const toolCall = choice . message . tool_calls [ 0 ]; assert ( toolCall . function . name === 'hris_get_employee' , 'Expected tool call to be hris_get_employee' ); // Parse the arguments to verify they contain the expected fields const args = JSON . parse ( toolCall . function . arguments ); assert ( args . id === 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , 'Expected id to match the query' ); assert ( args . fields !== undefined , 'Expected fields to be defined' ); }; // Run the example openaiIntegration ();","title":"OpenAI"},{"location":"openai-integration/#openai-integration","text":"This example shows how to use StackOne tools with OpenAI. import assert from 'node:assert' ; import OpenAI from 'openai' ; import { StackOneToolSet } from '../src' ; const openaiIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = '45072196112816593343' ; // Get the correct tool const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); const openAITools = tools . toOpenAI (); // Initialize OpenAI client const openai = new OpenAI (); // Create a chat completion with tool calls const response = await openai . chat . completions . create ({ model : 'gpt-4o-mini' , messages : [ { role : 'system' , content : 'You are a helpful assistant that can access HRIS information.' , }, { role : 'user' , content : 'What is the employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA phone number?' , }, ], tools : openAITools , }); // Verify the response contains tool calls assert ( response . choices . length > 0 , 'Expected at least one choice in the response' ); const choice = response . choices [ 0 ]; assert ( choice . message . tool_calls !== undefined , 'Expected tool_calls to be defined' ); assert ( choice . message . tool_calls . length > 0 , 'Expected at least one tool call' ); const toolCall = choice . message . tool_calls [ 0 ]; assert ( toolCall . function . name === 'hris_get_employee' , 'Expected tool call to be hris_get_employee' ); // Parse the arguments to verify they contain the expected fields const args = JSON . parse ( toolCall . function . arguments ); assert ( args . id === 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , 'Expected id to match the query' ); assert ( args . fields !== undefined , 'Expected fields to be defined' ); }; // Run the example openaiIntegration ();","title":"Openai Integration"},{"location":"openapi-toolset/","text":"Openapi Toolset # Basic OpenAPI Example This example demonstrates how to: 1. Load OpenAPI specifications from a file 2. Load OpenAPI specifications from a URL 3. Get and execute tools from the specifications import assert from 'node:assert' ; import { OpenAPIToolSet } from '../src/toolsets/openapi' ; import { joinPaths } from '../src/utils/file' ; Type for dry run result type DryRunResult = { url : string ; method : string ; headers? : Record < string , string > ; body? : string ; }; Example of loading OpenAPI specifications from a file async function fromFileExample () : Promise < void > { // Create an OpenAPIToolSet from a local file const toolset = new OpenAPIToolSet ({ filePath : joinPaths ( process . cwd (), 'src' , 'toolsets' , 'tests' , 'fixtures' , 'petstore.json' ), }); // Get all tools const tools = toolset . getTools ( '*Pet*' ); assert ( tools . length > 0 , 'Expected to find tools in the specification' ); // Get a specific tool const getPetTool = tools . getTool ( 'getPetById' ); assert ( getPetTool !== undefined , 'Expected to find getPetById tool' ); // Execute the tool with dry run to see what would be sent const result = ( await getPetTool . execute ({ petId : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . url . includes ( '/pet/123' ), 'Expected URL to contain pet ID' ); assert ( result . method === 'GET' , 'Expected GET method' ); } Example of loading OpenAPI specifications from a URL async function fromUrlExample () : Promise < void > { try { // Create an OpenAPIToolSet from a URL const toolset = await OpenAPIToolSet . fromUrl ({ url : 'https://api.eu1.stackone.com/oas/hris.json' , }); // Get tools matching a pattern const hrisTools = toolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Expected to find a bunch of tools' ); // Get a specific tool const getEmployeeTool = hrisTools . getTool ( 'hris_get_employee' ); assert ( getEmployeeTool !== undefined , 'Expected to find hris_get_employee tool' ); assert ( typeof getEmployeeTool . parameters . properties . id === 'object' && getEmployeeTool . parameters . properties . id !== null && getEmployeeTool . parameters . properties . id . type === 'string' , 'Expected to find string parameter for id' ); // Execute the tool with dry run to see what would be sent const result = ( await getEmployeeTool . execute ({ id : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . method === 'GET' , 'Expected GET method' ); assert ( result . url . includes ( '/employees/123' ), 'Expected URL to contain employee ID' ); assert ( result . body === undefined , 'Expected body to be undefined' ); } catch ( error ) { throw new Error ( `Failed to load from URL: ${ error instanceof Error ? error.message : String ( error ) } ` ); } } Run the examples async function main () : Promise < void > { try { // Run the file example await fromFileExample (); // Run the URL example await fromUrlExample (); } catch ( error ) { console . error ( error ); process . exit ( 1 ); } } main ();","title":"Getting Started"},{"location":"openapi-toolset/#openapi-toolset","text":"Basic OpenAPI Example This example demonstrates how to: 1. Load OpenAPI specifications from a file 2. Load OpenAPI specifications from a URL 3. Get and execute tools from the specifications import assert from 'node:assert' ; import { OpenAPIToolSet } from '../src/toolsets/openapi' ; import { joinPaths } from '../src/utils/file' ; Type for dry run result type DryRunResult = { url : string ; method : string ; headers? : Record < string , string > ; body? : string ; }; Example of loading OpenAPI specifications from a file async function fromFileExample () : Promise < void > { // Create an OpenAPIToolSet from a local file const toolset = new OpenAPIToolSet ({ filePath : joinPaths ( process . cwd (), 'src' , 'toolsets' , 'tests' , 'fixtures' , 'petstore.json' ), }); // Get all tools const tools = toolset . getTools ( '*Pet*' ); assert ( tools . length > 0 , 'Expected to find tools in the specification' ); // Get a specific tool const getPetTool = tools . getTool ( 'getPetById' ); assert ( getPetTool !== undefined , 'Expected to find getPetById tool' ); // Execute the tool with dry run to see what would be sent const result = ( await getPetTool . execute ({ petId : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . url . includes ( '/pet/123' ), 'Expected URL to contain pet ID' ); assert ( result . method === 'GET' , 'Expected GET method' ); } Example of loading OpenAPI specifications from a URL async function fromUrlExample () : Promise < void > { try { // Create an OpenAPIToolSet from a URL const toolset = await OpenAPIToolSet . fromUrl ({ url : 'https://api.eu1.stackone.com/oas/hris.json' , }); // Get tools matching a pattern const hrisTools = toolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Expected to find a bunch of tools' ); // Get a specific tool const getEmployeeTool = hrisTools . getTool ( 'hris_get_employee' ); assert ( getEmployeeTool !== undefined , 'Expected to find hris_get_employee tool' ); assert ( typeof getEmployeeTool . parameters . properties . id === 'object' && getEmployeeTool . parameters . properties . id !== null && getEmployeeTool . parameters . properties . id . type === 'string' , 'Expected to find string parameter for id' ); // Execute the tool with dry run to see what would be sent const result = ( await getEmployeeTool . execute ({ id : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . method === 'GET' , 'Expected GET method' ); assert ( result . url . includes ( '/employees/123' ), 'Expected URL to contain employee ID' ); assert ( result . body === undefined , 'Expected body to be undefined' ); } catch ( error ) { throw new Error ( `Failed to load from URL: ${ error instanceof Error ? error.message : String ( error ) } ` ); } } Run the examples async function main () : Promise < void > { try { // Run the file example await fromFileExample (); // Run the URL example await fromUrlExample (); } catch ( error ) { console . error ( error ); process . exit ( 1 ); } } main ();","title":"Openapi Toolset"},{"location":"openapi-transformations/","text":"Openapi Transformations # OpenAPI with Parameter Transformations Example This example demonstrates how to: 1. Create custom parameter transformers 2. Use them with OpenAPI tools to derive additional parameters 3. Execute tools with minimal input, letting the transformers handle the rest import assert from 'node:assert' ; import fs from 'node:fs' ; import path from 'node:path' ; import { OpenAPIToolSet } from '../src/toolsets/openapi' ; import type { ParameterTransformer } from '../src/types' ; Create a mock OpenAPI specification for testing const createMockOpenAPISpec = () : string => { // Create a simple OpenAPI spec with two operations const spec = { openapi : '3.0.0' , info : { title : 'Parameter Transformation API' , version : '1.0.0' , }, paths : { '/upload' : { post : { operationId : 'upload_file' , description : 'Upload a file' , requestBody : { content : { 'multipart/form-data' : { schema : { type : 'object' , properties : { file_content : { type : 'string' , description : 'Base64-encoded file content' , }, file_name : { type : 'string' , description : 'Name of the file' , }, file_format : { type : 'string' , description : 'Format of the file' , }, }, required : [ 'file_content' , 'file_name' , 'file_format' ], }, }, }, }, responses : { '200' : { description : 'File uploaded successfully' , }, }, }, }, '/users/{user_id}' : { put : { operationId : 'update_user' , description : 'Update user details' , parameters : [ { name : 'user_id' , in : 'path' , required : true , schema : { type : 'string' , }, }, ], requestBody : { content : { 'application/json' : { schema : { type : 'object' , properties : { user_name : { type : 'string' , description : 'User name' , }, user_email : { type : 'string' , description : 'User email' , }, user_role : { type : 'string' , description : 'User role' , }, }, }, }, }, }, responses : { '200' : { description : 'User updated successfully' , }, }, }, }, }, }; // Write the spec to a temporary file const tempFile = path . join ( process . env . TMPDIR || '/tmp' , `parameter-transformation-spec- ${ Date . now () } .json` ); fs . writeFileSync ( tempFile , JSON . stringify ( spec , null , 2 )); return tempFile ; }; Create a file transformer This transformer extracts file_content, file_name, and file_format from file_path const createFileTransformer = () : ParameterTransformer => { return { transforms : { // Extract file content as base64 file_content : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } if ( ! fs . existsSync ( filePath )) { throw new Error ( `File not found: ${ filePath } ` ); } return fs . readFileSync ( filePath ). toString ( 'base64' ); }, // Extract file name file_name : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } return path . basename ( filePath ); }, // Extract file format (extension) file_format : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } const extension = path . extname ( filePath ). slice ( 1 ); return extension || '' ; }, }, }; }; Example of using parameter transformations with OpenAPI async function main () : Promise < void > { const specFilePath = createMockOpenAPISpec (); const fileTransformer = createFileTransformer (); // Create a transformers map for the toolset const transformers = new Map < string , ParameterTransformer > (); transformers . set ( 'file_path' , fileTransformer ); // Create the toolset with transformers const toolset = new OpenAPIToolSet ({ filePath : specFilePath , transformers , }); // Get the tools const tools = toolset . getTools (); const fileUploadTool = tools . getTool ( 'upload_file' ); assert ( fileUploadTool , 'Expected to find upload_file tool' ); const tempFilePath = path . join ( __dirname , 'temp.txt' ); fs . writeFileSync ( tempFilePath , 'Hello, world!' ); try { // Execute with just file_path - other parameters will be transformed const fileUploadResult = await fileUploadTool . execute ( { file_path : tempFilePath }, { dryRun : true } ); const fileParams = fileUploadResult . mappedParams as Record < string , unknown > ; // Assertions to validate the transformations worked assert ( fileParams . file_name === 'temp.txt' , 'Expected file_name to be transformed correctly' ); assert ( fileParams . file_format === 'txt' , 'Expected file_format to be transformed correctly' ); assert ( typeof fileParams . file_content === 'string' && fileParams . file_content . length > 0 , 'Expected file_content to be transformed correctly' ); } finally { try { fs . unlinkSync ( tempFilePath ); fs . unlinkSync ( specFilePath ); console . log ( 'Cleaned up temporary files' ); } catch ( error ) { console . error ( 'Error cleaning up temporary files:' , error ); } } } main ();","title":"Custom Transformations"},{"location":"openapi-transformations/#openapi-transformations","text":"OpenAPI with Parameter Transformations Example This example demonstrates how to: 1. Create custom parameter transformers 2. Use them with OpenAPI tools to derive additional parameters 3. Execute tools with minimal input, letting the transformers handle the rest import assert from 'node:assert' ; import fs from 'node:fs' ; import path from 'node:path' ; import { OpenAPIToolSet } from '../src/toolsets/openapi' ; import type { ParameterTransformer } from '../src/types' ; Create a mock OpenAPI specification for testing const createMockOpenAPISpec = () : string => { // Create a simple OpenAPI spec with two operations const spec = { openapi : '3.0.0' , info : { title : 'Parameter Transformation API' , version : '1.0.0' , }, paths : { '/upload' : { post : { operationId : 'upload_file' , description : 'Upload a file' , requestBody : { content : { 'multipart/form-data' : { schema : { type : 'object' , properties : { file_content : { type : 'string' , description : 'Base64-encoded file content' , }, file_name : { type : 'string' , description : 'Name of the file' , }, file_format : { type : 'string' , description : 'Format of the file' , }, }, required : [ 'file_content' , 'file_name' , 'file_format' ], }, }, }, }, responses : { '200' : { description : 'File uploaded successfully' , }, }, }, }, '/users/{user_id}' : { put : { operationId : 'update_user' , description : 'Update user details' , parameters : [ { name : 'user_id' , in : 'path' , required : true , schema : { type : 'string' , }, }, ], requestBody : { content : { 'application/json' : { schema : { type : 'object' , properties : { user_name : { type : 'string' , description : 'User name' , }, user_email : { type : 'string' , description : 'User email' , }, user_role : { type : 'string' , description : 'User role' , }, }, }, }, }, }, responses : { '200' : { description : 'User updated successfully' , }, }, }, }, }, }; // Write the spec to a temporary file const tempFile = path . join ( process . env . TMPDIR || '/tmp' , `parameter-transformation-spec- ${ Date . now () } .json` ); fs . writeFileSync ( tempFile , JSON . stringify ( spec , null , 2 )); return tempFile ; }; Create a file transformer This transformer extracts file_content, file_name, and file_format from file_path const createFileTransformer = () : ParameterTransformer => { return { transforms : { // Extract file content as base64 file_content : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } if ( ! fs . existsSync ( filePath )) { throw new Error ( `File not found: ${ filePath } ` ); } return fs . readFileSync ( filePath ). toString ( 'base64' ); }, // Extract file name file_name : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } return path . basename ( filePath ); }, // Extract file format (extension) file_format : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } const extension = path . extname ( filePath ). slice ( 1 ); return extension || '' ; }, }, }; }; Example of using parameter transformations with OpenAPI async function main () : Promise < void > { const specFilePath = createMockOpenAPISpec (); const fileTransformer = createFileTransformer (); // Create a transformers map for the toolset const transformers = new Map < string , ParameterTransformer > (); transformers . set ( 'file_path' , fileTransformer ); // Create the toolset with transformers const toolset = new OpenAPIToolSet ({ filePath : specFilePath , transformers , }); // Get the tools const tools = toolset . getTools (); const fileUploadTool = tools . getTool ( 'upload_file' ); assert ( fileUploadTool , 'Expected to find upload_file tool' ); const tempFilePath = path . join ( __dirname , 'temp.txt' ); fs . writeFileSync ( tempFilePath , 'Hello, world!' ); try { // Execute with just file_path - other parameters will be transformed const fileUploadResult = await fileUploadTool . execute ( { file_path : tempFilePath }, { dryRun : true } ); const fileParams = fileUploadResult . mappedParams as Record < string , unknown > ; // Assertions to validate the transformations worked assert ( fileParams . file_name === 'temp.txt' , 'Expected file_name to be transformed correctly' ); assert ( fileParams . file_format === 'txt' , 'Expected file_format to be transformed correctly' ); assert ( typeof fileParams . file_content === 'string' && fileParams . file_content . length > 0 , 'Expected file_content to be transformed correctly' ); } finally { try { fs . unlinkSync ( tempFilePath ); fs . unlinkSync ( specFilePath ); console . log ( 'Cleaned up temporary files' ); } catch ( error ) { console . error ( 'Error cleaning up temporary files:' , error ); } } } main ();","title":"Openapi Transformations"},{"location":"planning/","text":"Planning # While building agents you may find that your workflow is too complex for a general purpose agent. StackOne AI SDK provides access to a state of the art planning agent which allows you to create, cache, and execute complex workflows on verticals supported by StackOne . For example, onboard a new hire from your ATS to your HRIS. import { StackOneToolSet } from '../src' ; const toolset = new StackOneToolSet (); const onboardWorkflow = await toolset . plan ({ key : 'custom_onboarding' , input : 'Onboard the last new hire from Teamtailor to Workday' , model : 'stackone-planner-latest' , tools : [ 'hris_*' , 'ats_*' ], accountIds : [ 'teamtailor_account_id' , 'workday_account_id' ], cache : true , // saves the plan to $HOME/.stackone/plans }); await onboardWorkflow . execute (); or use as part of a larger agent (using AI SDK by Vercel) import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; await generateText ({ model : openai ( 'gpt-4o' ), prompt : 'You are a workplace agent, onboard the latest hires to our systems' , tools : onboardWorkflow.toAISDK (), maxSteps : 3 , }); /* * The planning model is in closed beta and only available to design partners. * Apply for the waitlist [here](https://www.stackone.com/demo). */","title":"Planning"},{"location":"planning/#planning","text":"While building agents you may find that your workflow is too complex for a general purpose agent. StackOne AI SDK provides access to a state of the art planning agent which allows you to create, cache, and execute complex workflows on verticals supported by StackOne . For example, onboard a new hire from your ATS to your HRIS. import { StackOneToolSet } from '../src' ; const toolset = new StackOneToolSet (); const onboardWorkflow = await toolset . plan ({ key : 'custom_onboarding' , input : 'Onboard the last new hire from Teamtailor to Workday' , model : 'stackone-planner-latest' , tools : [ 'hris_*' , 'ats_*' ], accountIds : [ 'teamtailor_account_id' , 'workday_account_id' ], cache : true , // saves the plan to $HOME/.stackone/plans }); await onboardWorkflow . execute (); or use as part of a larger agent (using AI SDK by Vercel) import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; await generateText ({ model : openai ( 'gpt-4o' ), prompt : 'You are a workplace agent, onboard the latest hires to our systems' , tools : onboardWorkflow.toAISDK (), maxSteps : 3 , }); /* * The planning model is in closed beta and only available to design partners. * Apply for the waitlist [here](https://www.stackone.com/demo). */","title":"Planning"}]}