{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"StackOne AI SDK # Installation # # Using npm npm install @stackone/ai # Using yarn yarn add @stackone/ai # Using bun bun add @stackone/ai Authentication # Set the STACKONE_API_KEY environment variable: export STACKONE_API_KEY = <your-api-key> or load from a .env file: // Load environment variables from .env file import * as dotenv from 'dotenv' ; dotenv . config (); Account IDs # StackOne uses account IDs to identify different integrations. See the example in the README for more details. This example will hardcode the account ID: const accountId = '45072196112816593343' ; Quickstart # import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const quickstart = async () : Promise < void > => { const toolset = new StackOneToolSet (); // Get all HRIS-related tools using the StackOneTool method (adds accountId to the request) const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Verify we have tools assert ( tools . length > 0 , 'Expected to find HRIS tools' ); // Use a specific tool const employeeTool = tools . getTool ( 'hris_list_employees' ); assert ( employeeTool !== undefined , 'Expected to find hris_list_employees tool' ); // Execute the tool and verify the response const employees = await employeeTool . execute (); assert ( Array . isArray ( employees ), 'Expected employees to be an array' ); assert ( employees . length > 0 , 'Expected to find at least one employee' ); }; // Run the example quickstart (); Next Steps # Check out some more examples: OpenAI Integration AI SDK Integration Error Handling File Uploads Custom Base URL Account ID Usage","title":"Home"},{"location":"#stackone-ai-sdk","text":"","title":"StackOne AI SDK"},{"location":"#installation","text":"# Using npm npm install @stackone/ai # Using yarn yarn add @stackone/ai # Using bun bun add @stackone/ai","title":"Installation"},{"location":"#authentication","text":"Set the STACKONE_API_KEY environment variable: export STACKONE_API_KEY = <your-api-key> or load from a .env file: // Load environment variables from .env file import * as dotenv from 'dotenv' ; dotenv . config ();","title":"Authentication"},{"location":"#account-ids","text":"StackOne uses account IDs to identify different integrations. See the example in the README for more details. This example will hardcode the account ID: const accountId = '45072196112816593343' ;","title":"Account IDs"},{"location":"#quickstart","text":"import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const quickstart = async () : Promise < void > => { const toolset = new StackOneToolSet (); // Get all HRIS-related tools using the StackOneTool method (adds accountId to the request) const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Verify we have tools assert ( tools . length > 0 , 'Expected to find HRIS tools' ); // Use a specific tool const employeeTool = tools . getTool ( 'hris_list_employees' ); assert ( employeeTool !== undefined , 'Expected to find hris_list_employees tool' ); // Execute the tool and verify the response const employees = await employeeTool . execute (); assert ( Array . isArray ( employees ), 'Expected employees to be an array' ); assert ( employees . length > 0 , 'Expected to find at least one employee' ); }; // Run the example quickstart ();","title":"Quickstart"},{"location":"#next-steps","text":"Check out some more examples: OpenAI Integration AI SDK Integration Error Handling File Uploads Custom Base URL Account ID Usage","title":"Next Steps"},{"location":"account-id-usage/","text":"Account Id Usage # Example demonstrating different ways to set the account ID when using StackOne tools. This example shows: 1. Setting account ID when initializing the toolset 2. Setting account ID when getting tools 3. Using setAccountId method directly on a tool Usage: bun run examples/account-id-usage.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const accountIdUsage = async () : Promise < void > => { /* * Set account ID on toolset initialization */ const toolset = new StackOneToolSet ({ accountId : 'initial-account-id' }); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getStackOneTool ( 'hris_list_employees' ); assert ( employeeTool . getAccountId () === 'initial-account-id' , 'Account ID should match what was set' ); /* * Setting account ID when getting tools (overrides toolset account ID) */ const toolsWithOverride = toolset . getStackOneTools ( 'hris_*' , 'override-account-id' ); const employeeToolWithOverride = toolsWithOverride . getStackOneTool ( 'hris_list_employees' ); assert ( employeeToolWithOverride ? . getAccountId () === 'override-account-id' , 'Account ID should match what was set' ); /* * Set the account ID directly on the tool */ employeeTool . setAccountId ( 'direct-account-id' ); assert ( employeeTool . getAccountId () === 'direct-account-id' , 'Account ID should match what was set' ); }; accountIdUsage ();","title":"Account IDs"},{"location":"account-id-usage/#account-id-usage","text":"Example demonstrating different ways to set the account ID when using StackOne tools. This example shows: 1. Setting account ID when initializing the toolset 2. Setting account ID when getting tools 3. Using setAccountId method directly on a tool Usage: bun run examples/account-id-usage.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const accountIdUsage = async () : Promise < void > => { /* * Set account ID on toolset initialization */ const toolset = new StackOneToolSet ({ accountId : 'initial-account-id' }); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getStackOneTool ( 'hris_list_employees' ); assert ( employeeTool . getAccountId () === 'initial-account-id' , 'Account ID should match what was set' ); /* * Setting account ID when getting tools (overrides toolset account ID) */ const toolsWithOverride = toolset . getStackOneTools ( 'hris_*' , 'override-account-id' ); const employeeToolWithOverride = toolsWithOverride . getStackOneTool ( 'hris_list_employees' ); assert ( employeeToolWithOverride ? . getAccountId () === 'override-account-id' , 'Account ID should match what was set' ); /* * Set the account ID directly on the tool */ employeeTool . setAccountId ( 'direct-account-id' ); assert ( employeeTool . getAccountId () === 'direct-account-id' , 'Account ID should match what was set' ); }; accountIdUsage ();","title":"Account Id Usage"},{"location":"ai-sdk-integration/","text":"Ai Sdk Integration # This example shows how to use StackOne tools with the AI SDK. import assert from 'node:assert' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; const aiSdkIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = '45072196112816593343' ; // Get HRIS tools const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); // Convert to AI SDK tools const aiSdkTools = tools . toAISDK (); // Use max steps to automatically call the tool if it's needed const { text } = await generateText ({ model : openai ( 'gpt-4o-mini' ), tools : aiSdkTools , prompt : 'Get all details about employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , maxSteps : 3 , }); assert ( text . includes ( 'Isacc Newton' ), 'Expected employee name to be included in the response' ); }; aiSdkIntegration ();","title":"AI SDK"},{"location":"ai-sdk-integration/#ai-sdk-integration","text":"This example shows how to use StackOne tools with the AI SDK. import assert from 'node:assert' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; const aiSdkIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = '45072196112816593343' ; // Get HRIS tools const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); // Convert to AI SDK tools const aiSdkTools = tools . toAISDK (); // Use max steps to automatically call the tool if it's needed const { text } = await generateText ({ model : openai ( 'gpt-4o-mini' ), tools : aiSdkTools , prompt : 'Get all details about employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , maxSteps : 3 , }); assert ( text . includes ( 'Isacc Newton' ), 'Expected employee name to be included in the response' ); }; aiSdkIntegration ();","title":"Ai Sdk Integration"},{"location":"custom-base-url/","text":"Custom Base Url # Example demonstrating how to use a custom base URL with StackOne tools. This is useful for: 1. Testing against development APIs 2. Working with self-hosted StackOne instances Usage: bun run examples/custom-base-url.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const customBaseUrl = async () : Promise < void > => { Default base URL const defaultToolset = new StackOneToolSet (); const hrisTools = defaultToolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Should have at least one HRIS tool' ); const defaultTool = hrisTools . getTool ( 'hris_get_employee' ); if ( ! defaultTool ) { throw new Error ( 'Tool not found' ); } Custom base URL const devToolset = new StackOneToolSet ({ baseUrl : 'https://api.example-dev.com' , }); const devHrisTools = devToolset . getTools ( 'hris_*' ); assert ( devHrisTools . length > 0 , 'Should have at least one HRIS tool' ); const devTool = devHrisTools . getTool ( 'hris_get_employee' ); if ( ! devTool ) { throw new Error ( 'Tool not found' ); } Note this uses the same tools but substitutes the base URL if ( defaultTool && devTool ) { assert ( defaultTool . name === devTool . name , 'Tool names should be the same' ); assert ( defaultTool . executeConfig . url . includes ( 'https://api.stackone.com' ), 'Default tool should use the default base URL' ); assert ( devTool . executeConfig . url . includes ( 'https://api.example-dev.com' ), 'Custom tool should use the custom base URL' ); } }; customBaseUrl ();","title":"Custom Base URL"},{"location":"custom-base-url/#custom-base-url","text":"Example demonstrating how to use a custom base URL with StackOne tools. This is useful for: 1. Testing against development APIs 2. Working with self-hosted StackOne instances Usage: bun run examples/custom-base-url.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; const customBaseUrl = async () : Promise < void > => { Default base URL const defaultToolset = new StackOneToolSet (); const hrisTools = defaultToolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Should have at least one HRIS tool' ); const defaultTool = hrisTools . getTool ( 'hris_get_employee' ); if ( ! defaultTool ) { throw new Error ( 'Tool not found' ); } Custom base URL const devToolset = new StackOneToolSet ({ baseUrl : 'https://api.example-dev.com' , }); const devHrisTools = devToolset . getTools ( 'hris_*' ); assert ( devHrisTools . length > 0 , 'Should have at least one HRIS tool' ); const devTool = devHrisTools . getTool ( 'hris_get_employee' ); if ( ! devTool ) { throw new Error ( 'Tool not found' ); } Note this uses the same tools but substitutes the base URL if ( defaultTool && devTool ) { assert ( defaultTool . name === devTool . name , 'Tool names should be the same' ); assert ( defaultTool . executeConfig . url . includes ( 'https://api.stackone.com' ), 'Default tool should use the default base URL' ); assert ( devTool . executeConfig . url . includes ( 'https://api.example-dev.com' ), 'Custom tool should use the custom base URL' ); } }; customBaseUrl ();","title":"Custom Base Url"},{"location":"error-handling/","text":"Error Handling # Error Handling # This example shows how to handle errors when using the StackOne SDK. import assert from 'node:assert' ; import { StackOneAPIError , StackOneError , StackOneToolSet , ToolSetConfigError } from '../src' ; const errorHandling = async () : Promise < void > => { // Example 1: Handle initialization errors const testInitializationErrors = async () : Promise < void > => { // Temporarily save the API key const originalKey = process . env . STACKONE_API_KEY ; // Delete the API key to force an error process . env . STACKONE_API_KEY = undefined ; try { // This will throw a ToolsetConfigError const _toolset = new StackOneToolSet ({ strict : true , }); assert ( false , 'Expected ToolSetConfigError was not thrown' ); } catch ( error ) { assert ( error instanceof ToolSetConfigError , 'Expected error to be ToolSetConfigError' ); } finally { // Restore the API key process . env . STACKONE_API_KEY = originalKey ; } }; // Example 2: Handle API errors const testApiErrors = async () : Promise < void > => { const toolset = new StackOneToolSet (); const accountId = 'invalid-account-id' ; // Invalid account ID to force an error try { const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); const employeeTool = tools . getTool ( 'hris_list_employees' ); if ( employeeTool ) { // This will throw a StackOneAPIError due to the invalid account ID await employeeTool . execute (); assert ( false , 'Expected StackOneAPIError was not thrown' ); } } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError , 'Expected error to be StackOneAPIError or StackOneError' ); if ( error instanceof StackOneAPIError ) { assert ( error . statusCode !== undefined , 'Expected statusCode to be defined' ); assert ( error . responseBody !== undefined , 'Expected responseBody to be defined' ); } } }; // Example 3: Handle invalid tool name const testInvalidToolName = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const nonExistentTool = tools . getTool ( 'non_existent_tool' ); assert ( nonExistentTool === undefined , 'Expected non-existent tool to be undefined' ); }; // Example 4: Handle invalid arguments const testInvalidArguments = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getTool ( 'hris_get_employee' ); if ( employeeTool ) { try { // This will throw an error due to missing required arguments await employeeTool . execute (); assert ( false , 'Expected error was not thrown for missing arguments' ); } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError || error instanceof Error , 'Expected error to be a known error type' ); } } }; // Run all tests await testInitializationErrors (); await testApiErrors (); await testInvalidToolName (); await testInvalidArguments (); }; // Run the example errorHandling ();","title":"Error Handling"},{"location":"error-handling/#error-handling","text":"","title":"Error Handling"},{"location":"error-handling/#error-handling_1","text":"This example shows how to handle errors when using the StackOne SDK. import assert from 'node:assert' ; import { StackOneAPIError , StackOneError , StackOneToolSet , ToolSetConfigError } from '../src' ; const errorHandling = async () : Promise < void > => { // Example 1: Handle initialization errors const testInitializationErrors = async () : Promise < void > => { // Temporarily save the API key const originalKey = process . env . STACKONE_API_KEY ; // Delete the API key to force an error process . env . STACKONE_API_KEY = undefined ; try { // This will throw a ToolsetConfigError const _toolset = new StackOneToolSet ({ strict : true , }); assert ( false , 'Expected ToolSetConfigError was not thrown' ); } catch ( error ) { assert ( error instanceof ToolSetConfigError , 'Expected error to be ToolSetConfigError' ); } finally { // Restore the API key process . env . STACKONE_API_KEY = originalKey ; } }; // Example 2: Handle API errors const testApiErrors = async () : Promise < void > => { const toolset = new StackOneToolSet (); const accountId = 'invalid-account-id' ; // Invalid account ID to force an error try { const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); const employeeTool = tools . getTool ( 'hris_list_employees' ); if ( employeeTool ) { // This will throw a StackOneAPIError due to the invalid account ID await employeeTool . execute (); assert ( false , 'Expected StackOneAPIError was not thrown' ); } } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError , 'Expected error to be StackOneAPIError or StackOneError' ); if ( error instanceof StackOneAPIError ) { assert ( error . statusCode !== undefined , 'Expected statusCode to be defined' ); assert ( error . responseBody !== undefined , 'Expected responseBody to be defined' ); } } }; // Example 3: Handle invalid tool name const testInvalidToolName = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const nonExistentTool = tools . getTool ( 'non_existent_tool' ); assert ( nonExistentTool === undefined , 'Expected non-existent tool to be undefined' ); }; // Example 4: Handle invalid arguments const testInvalidArguments = async () : Promise < void > => { const toolset = new StackOneToolSet (); const tools = toolset . getTools ( 'hris_*' ); const employeeTool = tools . getTool ( 'hris_get_employee' ); if ( employeeTool ) { try { // This will throw an error due to missing required arguments await employeeTool . execute (); assert ( false , 'Expected error was not thrown for missing arguments' ); } catch ( error ) { assert ( error instanceof StackOneAPIError || error instanceof StackOneError || error instanceof Error , 'Expected error to be a known error type' ); } } }; // Run all tests await testInitializationErrors (); await testApiErrors (); await testInvalidToolName (); await testInvalidArguments (); }; // Run the example errorHandling ();","title":"Error Handling"},{"location":"file-uploads/","text":"File Uploads # Example showing how to upload files using the StackOne SDK. This example demonstrates how to upload files using the simplified file_path parameter, which is the only parameter needed for file uploads. The SDK automatically derives the necessary file parameters (content, name, file_format) from the file_path. Run this example with: bun run examples/file-uploads.ts import assert from 'node:assert' ; import * as fs from 'node:fs' ; import * as path from 'node:path' ; import { StackOneToolSet } from '../src' ; const accountId = '45072196112816593343' ; const fileUploads = async () : Promise < void > => { // Create a sample file for testing const sampleFilePath = path . join ( __dirname , 'sample-file.txt' ); fs . writeFileSync ( sampleFilePath , 'This is a sample file for testing file uploads.' ); try { // Initialize the StackOne toolset const toolset = new StackOneToolSet (); // Get tools for documents const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Get the upload file tool const uploadTool = tools . getTool ( 'hris_upload_employee_document' ); // Check if upload tool exists assert ( uploadTool !== undefined , 'Upload document tool not found' ); /* * Upload a file using the file_path parameter * The SDK will automatically derive content, name, and file_format from the file_path */ // Use dry run to check parameter mapping const dryRunResult = await uploadTool . execute ( { file_path : sampleFilePath , id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true } ); assert ( ( dryRunResult . mappedParams as Record < string , { value : string } > ). file_format . value === 'txt' , 'File format was not mapped correctly' ); } finally { // Clean up the sample file if ( fs . existsSync ( sampleFilePath )) { fs . unlinkSync ( sampleFilePath ); } } }; fileUploads ();","title":"File Uploads"},{"location":"file-uploads/#file-uploads","text":"Example showing how to upload files using the StackOne SDK. This example demonstrates how to upload files using the simplified file_path parameter, which is the only parameter needed for file uploads. The SDK automatically derives the necessary file parameters (content, name, file_format) from the file_path. Run this example with: bun run examples/file-uploads.ts import assert from 'node:assert' ; import * as fs from 'node:fs' ; import * as path from 'node:path' ; import { StackOneToolSet } from '../src' ; const accountId = '45072196112816593343' ; const fileUploads = async () : Promise < void > => { // Create a sample file for testing const sampleFilePath = path . join ( __dirname , 'sample-file.txt' ); fs . writeFileSync ( sampleFilePath , 'This is a sample file for testing file uploads.' ); try { // Initialize the StackOne toolset const toolset = new StackOneToolSet (); // Get tools for documents const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); // Get the upload file tool const uploadTool = tools . getTool ( 'hris_upload_employee_document' ); // Check if upload tool exists assert ( uploadTool !== undefined , 'Upload document tool not found' ); /* * Upload a file using the file_path parameter * The SDK will automatically derive content, name, and file_format from the file_path */ // Use dry run to check parameter mapping const dryRunResult = await uploadTool . execute ( { file_path : sampleFilePath , id : 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , category : { value : 'shared' }, }, { dryRun : true } ); assert ( ( dryRunResult . mappedParams as Record < string , { value : string } > ). file_format . value === 'txt' , 'File format was not mapped correctly' ); } finally { // Clean up the sample file if ( fs . existsSync ( sampleFilePath )) { fs . unlinkSync ( sampleFilePath ); } } }; fileUploads ();","title":"File Uploads"},{"location":"filters/","text":"Filters # Filters Example This example demonstrates how to use filters with the HRIS list employees endpoint. It showcases the deep object serialization implementation that properly converts nested filter objects to OpenAPI deepObject style query parameters. Key features demonstrated: 1. Basic filter usage (updated_after, email, employee_number) 2. Proxy parameter usage for provider-specific filters 3. Complex nested filter combinations 4. Proper serialization of filter objects to query parameters Usage: bun run examples/filters.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; type DryRunResult = { url : string }; const hriseEmployeeFilters = async () : Promise < void > => { // Initialize the toolset const toolset = new StackOneToolSet (); const accountId = 'test-account-id' ; // Get the HRIS tools with account ID const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); const employeesTool = tools . getTool ( 'hris_list_employees' ); assert ( employeesTool !== undefined , 'Expected to find hris_list_employees tool' ); console . log ( '\ud83e\uddea Testing HRIS Employee Filters with Deep Object Serialization\\n' ); /* * Example 1: Basic date filter * Demonstrates filtering employees updated after a specific date */ console . log ( '1\ufe0f\u20e3 Basic Date Filter Test' ); const basicDateFilter = ( await employeesTool . execute ( { filter : { updated_after : '2023-01-01T00:00:00.000Z' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { updated_after : '2023-01-01T00:00:00.000Z' } }); console . log ( 'Serialized URL:' , basicDateFilter . url ); // Verify that the filter is properly serialized as deepObject style assert ( basicDateFilter . url . includes ( 'filter%5Bupdated_after%5D=2023-01-01T00%3A00%3A00.000Z' ), 'Expected URL to contain properly serialized date filter' ); console . log ( '\u2705 Date filter serialized correctly\\n' ); /* * Example 2: Email filter * Demonstrates filtering employees by email address */ console . log ( '2\ufe0f\u20e3 Email Filter Test' ); const emailFilter = ( await employeesTool . execute ( { filter : { email : 'john.doe@company.com' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { email : 'john.doe@company.com' } }); console . log ( 'Serialized URL:' , emailFilter . url ); assert ( emailFilter . url . includes ( 'filter%5Bemail%5D=john.doe%40company.com' ), 'Expected URL to contain properly serialized email filter' ); console . log ( '\u2705 Email filter serialized correctly\\n' ); /* * Example 3: Employee number filter * Demonstrates filtering employees by employee number */ console . log ( '3\ufe0f\u20e3 Employee Number Filter Test' ); const employeeNumberFilter = ( await employeesTool . execute ( { filter : { employee_number : 'EMP001' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { employee_number : 'EMP001' } }); console . log ( 'Serialized URL:' , employeeNumberFilter . url ); assert ( employeeNumberFilter . url . includes ( 'filter%5Bemployee_number%5D=EMP001' ), 'Expected URL to contain properly serialized employee number filter' ); console . log ( '\u2705 Employee number filter serialized correctly\\n' ); /* * Example 4: Multiple filters combined * Demonstrates using multiple filter parameters together */ console . log ( '4\ufe0f\u20e3 Multiple Filters Combined Test' ); const multipleFilters = ( await employeesTool . execute ( { filter : { updated_after : '2023-06-01T00:00:00.000Z' , email : 'jane.smith@company.com' , employee_number : 'EMP002' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { updated_after : '2023-06-01T00:00:00.000Z' , email : 'jane.smith@company.com' , employee_number : 'EMP002' , }, }); console . log ( 'Serialized URL:' , ( multipleFilters as { url : string }). url ); // Verify all filters are present in the URL assert ( multipleFilters . url . includes ( 'filter%5Bupdated_after%5D=2023-06-01T00%3A00%3A00.000Z' ), 'Expected URL to contain date filter' ); assert ( multipleFilters . url . includes ( 'filter%5Bemail%5D=jane.smith%40company.com' ), 'Expected URL to contain email filter' ); assert ( multipleFilters . url . includes ( 'filter%5Bemployee_number%5D=EMP002' ), 'Expected URL to contain employee number filter' ); console . log ( '\u2705 Multiple filters serialized correctly\\n' ); /* * Example 5: Proxy parameters for provider-specific filtering * Demonstrates using proxy parameters which also use deepObject serialization */ console . log ( '5\ufe0f\u20e3 Proxy Parameters Test' ); const proxyParameters = ( await employeesTool . execute ( { proxy : { custom_field : 'value123' , provider_filter : { department : 'Engineering' , status : 'active' , }, }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Proxy object:' , { proxy : { custom_field : 'value123' , provider_filter : { department : 'Engineering' , status : 'active' , }, }, }); console . log ( 'Serialized URL:' , proxyParameters . url ); // Verify proxy parameters are properly serialized assert ( proxyParameters . url . includes ( 'proxy%5Bcustom_field%5D=value123' ), 'Expected URL to contain proxy custom_field parameter' ); assert ( proxyParameters . url . includes ( 'proxy%5Bprovider_filter%5D%5Bdepartment%5D=Engineering' ), 'Expected URL to contain nested proxy department parameter' ); assert ( proxyParameters . url . includes ( 'proxy%5Bprovider_filter%5D%5Bstatus%5D=active' ), 'Expected URL to contain nested proxy status parameter' ); console . log ( '\u2705 Proxy parameters with nested objects serialized correctly\\n' ); /* * Example 6: Complex combined scenario * Demonstrates combining filters, proxy parameters, and other query parameters */ console . log ( '6\ufe0f\u20e3 Complex Combined Scenario Test' ); const complexScenario = ( await employeesTool . execute ( { filter : { updated_after : '2023-09-01T00:00:00.000Z' , email : 'admin@company.com' , }, proxy : { include_terminated : 'false' , custom_sorting : { field : 'hire_date' , order : 'desc' , }, }, fields : 'id,first_name,last_name,email,hire_date' , page_size : '50' , }, { dryRun : true } )) as DryRunResult ; console . log ( 'Complex parameters:' , { filter : { updated_after : '2023-09-01T00:00:00.000Z' , email : 'admin@company.com' , }, proxy : { include_terminated : 'false' , custom_sorting : { field : 'hire_date' , order : 'desc' , }, }, fields : 'id,first_name,last_name,email,hire_date' , page_size : '50' , }); console . log ( 'Serialized URL:' , complexScenario . url ); // Verify complex scenario serialization assert ( complexScenario . url . includes ( 'filter%5Bupdated_after%5D=2023-09-01T00%3A00%3A00.000Z' ), 'Expected URL to contain complex date filter' ); assert ( complexScenario . url . includes ( 'filter%5Bemail%5D=admin%40company.com' ), 'Expected URL to contain complex email filter' ); assert ( complexScenario . url . includes ( 'proxy%5Binclude_terminated%5D=false' ), 'Expected URL to contain proxy boolean parameter' ); assert ( complexScenario . url . includes ( 'proxy%5Bcustom_sorting%5D%5Bfield%5D=hire_date' ), 'Expected URL to contain nested proxy field parameter' ); assert ( complexScenario . url . includes ( 'proxy%5Bcustom_sorting%5D%5Border%5D=desc' ), 'Expected URL to contain nested proxy order parameter' ); assert ( complexScenario . url . includes ( 'fields=id%2Cfirst_name%2Clast_name%2Cemail%2Chire_date' ), 'Expected URL to contain fields parameter' ); assert ( complexScenario . url . includes ( 'page_size=50' ), 'Expected URL to contain page_size parameter' ); console . log ( '\u2705 Complex combined scenario serialized correctly\\n' ); /* * Example 7: Edge case - Empty filter objects * Demonstrates handling of empty filter objects */ console . log ( '7\ufe0f\u20e3 Edge Case - Empty Filter Objects Test' ); const emptyFilterTest = ( await employeesTool . execute ( { filter : {}, fields : 'id,first_name,last_name' , }, { dryRun : true } )) as DryRunResult ; console . log ( 'Empty filter object:' , { filter : {}, fields : 'id,first_name,last_name' }); console . log ( 'Serialized URL:' , emptyFilterTest . url ); // Verify that empty filter objects don't create problematic parameters assert ( emptyFilterTest . url . includes ( 'fields=id%2Cfirst_name%2Clast_name' ), 'Expected URL to contain fields parameter even with empty filter' ); // Empty objects should not create parameters assert ( ! emptyFilterTest . url . includes ( 'filter=' ), 'Expected URL to not contain empty filter parameter' ); console . log ( '\u2705 Empty filter objects handled correctly\\n' ); }; // Run the example hriseEmployeeFilters ();","title":"Filters"},{"location":"filters/#filters","text":"Filters Example This example demonstrates how to use filters with the HRIS list employees endpoint. It showcases the deep object serialization implementation that properly converts nested filter objects to OpenAPI deepObject style query parameters. Key features demonstrated: 1. Basic filter usage (updated_after, email, employee_number) 2. Proxy parameter usage for provider-specific filters 3. Complex nested filter combinations 4. Proper serialization of filter objects to query parameters Usage: bun run examples/filters.ts import assert from 'node:assert' ; import { StackOneToolSet } from '../src' ; type DryRunResult = { url : string }; const hriseEmployeeFilters = async () : Promise < void > => { // Initialize the toolset const toolset = new StackOneToolSet (); const accountId = 'test-account-id' ; // Get the HRIS tools with account ID const tools = toolset . getStackOneTools ( 'hris_*' , accountId ); const employeesTool = tools . getTool ( 'hris_list_employees' ); assert ( employeesTool !== undefined , 'Expected to find hris_list_employees tool' ); console . log ( '\ud83e\uddea Testing HRIS Employee Filters with Deep Object Serialization\\n' ); /* * Example 1: Basic date filter * Demonstrates filtering employees updated after a specific date */ console . log ( '1\ufe0f\u20e3 Basic Date Filter Test' ); const basicDateFilter = ( await employeesTool . execute ( { filter : { updated_after : '2023-01-01T00:00:00.000Z' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { updated_after : '2023-01-01T00:00:00.000Z' } }); console . log ( 'Serialized URL:' , basicDateFilter . url ); // Verify that the filter is properly serialized as deepObject style assert ( basicDateFilter . url . includes ( 'filter%5Bupdated_after%5D=2023-01-01T00%3A00%3A00.000Z' ), 'Expected URL to contain properly serialized date filter' ); console . log ( '\u2705 Date filter serialized correctly\\n' ); /* * Example 2: Email filter * Demonstrates filtering employees by email address */ console . log ( '2\ufe0f\u20e3 Email Filter Test' ); const emailFilter = ( await employeesTool . execute ( { filter : { email : 'john.doe@company.com' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { email : 'john.doe@company.com' } }); console . log ( 'Serialized URL:' , emailFilter . url ); assert ( emailFilter . url . includes ( 'filter%5Bemail%5D=john.doe%40company.com' ), 'Expected URL to contain properly serialized email filter' ); console . log ( '\u2705 Email filter serialized correctly\\n' ); /* * Example 3: Employee number filter * Demonstrates filtering employees by employee number */ console . log ( '3\ufe0f\u20e3 Employee Number Filter Test' ); const employeeNumberFilter = ( await employeesTool . execute ( { filter : { employee_number : 'EMP001' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { employee_number : 'EMP001' } }); console . log ( 'Serialized URL:' , employeeNumberFilter . url ); assert ( employeeNumberFilter . url . includes ( 'filter%5Bemployee_number%5D=EMP001' ), 'Expected URL to contain properly serialized employee number filter' ); console . log ( '\u2705 Employee number filter serialized correctly\\n' ); /* * Example 4: Multiple filters combined * Demonstrates using multiple filter parameters together */ console . log ( '4\ufe0f\u20e3 Multiple Filters Combined Test' ); const multipleFilters = ( await employeesTool . execute ( { filter : { updated_after : '2023-06-01T00:00:00.000Z' , email : 'jane.smith@company.com' , employee_number : 'EMP002' , }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Filter object:' , { filter : { updated_after : '2023-06-01T00:00:00.000Z' , email : 'jane.smith@company.com' , employee_number : 'EMP002' , }, }); console . log ( 'Serialized URL:' , ( multipleFilters as { url : string }). url ); // Verify all filters are present in the URL assert ( multipleFilters . url . includes ( 'filter%5Bupdated_after%5D=2023-06-01T00%3A00%3A00.000Z' ), 'Expected URL to contain date filter' ); assert ( multipleFilters . url . includes ( 'filter%5Bemail%5D=jane.smith%40company.com' ), 'Expected URL to contain email filter' ); assert ( multipleFilters . url . includes ( 'filter%5Bemployee_number%5D=EMP002' ), 'Expected URL to contain employee number filter' ); console . log ( '\u2705 Multiple filters serialized correctly\\n' ); /* * Example 5: Proxy parameters for provider-specific filtering * Demonstrates using proxy parameters which also use deepObject serialization */ console . log ( '5\ufe0f\u20e3 Proxy Parameters Test' ); const proxyParameters = ( await employeesTool . execute ( { proxy : { custom_field : 'value123' , provider_filter : { department : 'Engineering' , status : 'active' , }, }, }, { dryRun : true } )) as DryRunResult ; console . log ( 'Proxy object:' , { proxy : { custom_field : 'value123' , provider_filter : { department : 'Engineering' , status : 'active' , }, }, }); console . log ( 'Serialized URL:' , proxyParameters . url ); // Verify proxy parameters are properly serialized assert ( proxyParameters . url . includes ( 'proxy%5Bcustom_field%5D=value123' ), 'Expected URL to contain proxy custom_field parameter' ); assert ( proxyParameters . url . includes ( 'proxy%5Bprovider_filter%5D%5Bdepartment%5D=Engineering' ), 'Expected URL to contain nested proxy department parameter' ); assert ( proxyParameters . url . includes ( 'proxy%5Bprovider_filter%5D%5Bstatus%5D=active' ), 'Expected URL to contain nested proxy status parameter' ); console . log ( '\u2705 Proxy parameters with nested objects serialized correctly\\n' ); /* * Example 6: Complex combined scenario * Demonstrates combining filters, proxy parameters, and other query parameters */ console . log ( '6\ufe0f\u20e3 Complex Combined Scenario Test' ); const complexScenario = ( await employeesTool . execute ( { filter : { updated_after : '2023-09-01T00:00:00.000Z' , email : 'admin@company.com' , }, proxy : { include_terminated : 'false' , custom_sorting : { field : 'hire_date' , order : 'desc' , }, }, fields : 'id,first_name,last_name,email,hire_date' , page_size : '50' , }, { dryRun : true } )) as DryRunResult ; console . log ( 'Complex parameters:' , { filter : { updated_after : '2023-09-01T00:00:00.000Z' , email : 'admin@company.com' , }, proxy : { include_terminated : 'false' , custom_sorting : { field : 'hire_date' , order : 'desc' , }, }, fields : 'id,first_name,last_name,email,hire_date' , page_size : '50' , }); console . log ( 'Serialized URL:' , complexScenario . url ); // Verify complex scenario serialization assert ( complexScenario . url . includes ( 'filter%5Bupdated_after%5D=2023-09-01T00%3A00%3A00.000Z' ), 'Expected URL to contain complex date filter' ); assert ( complexScenario . url . includes ( 'filter%5Bemail%5D=admin%40company.com' ), 'Expected URL to contain complex email filter' ); assert ( complexScenario . url . includes ( 'proxy%5Binclude_terminated%5D=false' ), 'Expected URL to contain proxy boolean parameter' ); assert ( complexScenario . url . includes ( 'proxy%5Bcustom_sorting%5D%5Bfield%5D=hire_date' ), 'Expected URL to contain nested proxy field parameter' ); assert ( complexScenario . url . includes ( 'proxy%5Bcustom_sorting%5D%5Border%5D=desc' ), 'Expected URL to contain nested proxy order parameter' ); assert ( complexScenario . url . includes ( 'fields=id%2Cfirst_name%2Clast_name%2Cemail%2Chire_date' ), 'Expected URL to contain fields parameter' ); assert ( complexScenario . url . includes ( 'page_size=50' ), 'Expected URL to contain page_size parameter' ); console . log ( '\u2705 Complex combined scenario serialized correctly\\n' ); /* * Example 7: Edge case - Empty filter objects * Demonstrates handling of empty filter objects */ console . log ( '7\ufe0f\u20e3 Edge Case - Empty Filter Objects Test' ); const emptyFilterTest = ( await employeesTool . execute ( { filter : {}, fields : 'id,first_name,last_name' , }, { dryRun : true } )) as DryRunResult ; console . log ( 'Empty filter object:' , { filter : {}, fields : 'id,first_name,last_name' }); console . log ( 'Serialized URL:' , emptyFilterTest . url ); // Verify that empty filter objects don't create problematic parameters assert ( emptyFilterTest . url . includes ( 'fields=id%2Cfirst_name%2Clast_name' ), 'Expected URL to contain fields parameter even with empty filter' ); // Empty objects should not create parameters assert ( ! emptyFilterTest . url . includes ( 'filter=' ), 'Expected URL to not contain empty filter parameter' ); console . log ( '\u2705 Empty filter objects handled correctly\\n' ); }; // Run the example hriseEmployeeFilters ();","title":"Filters"},{"location":"human-in-the-loop/","text":"Human In The Loop # Example showing how to do human-in-the-loop workflows with StackOne using the split functionality. This allows for more granular control over tool execution and validation. Run this with: bun run examples/human-in-the-loop.ts import { assert } from 'node:console' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import type { JsonDict } from '../src/types' ; interface ToolCall { toolName : string ; args : Record < string , unknown > ; } const humanInTheLoopExample = async () : Promise < void > => { // Create a toolset const toolset = new StackOneToolSet (); const hrisAccountId = 'workday_account_id' ; // Get the create employee tool const createEmployeeTool = toolset . getTool ( 'hris_create_employee' , { 'x-account-id' : hrisAccountId , }); if ( ! createEmployeeTool ) { throw new Error ( 'Create employee tool not found' ); } // Get the AI SDK version of the tool without the execute function const tool = createEmployeeTool . toAISDK ({ executable : false , }); // Use the metadata for AI planning/generation const { toolCalls } = await generateText ({ model : openai ( 'gpt-4o' ), tools : tool , prompt : 'Create a new employee in Workday, params: Full name: John Doe, personal email: john.doe@example.com, department: Engineering, start date: 2025-01-01, hire date: 2025-01-01' , maxSteps : 1 , }); // Human validation and modification step const toolCall = toolCalls [ 0 ] as ToolCall ; const shouldExecute = await simulateHumanValidation ( toolCall ); // Map of tool names to execution functions const executions : Record < string , ( args : Record < string , unknown > ) => Promise < JsonDict >> = { hris_create_employee : ( args ) => createEmployeeTool . execute ( args as JsonDict ), }; // Execute the tool if approved if ( shouldExecute && toolCall . toolName in executions ) { // You would call the tool here // const result = await executions[toolCall.toolName](toolCall.args); } else { console . log ( 'Tool execution was not approved or tool not found' ); } }; // Simulate human validation (in a real app, this would be your UI component) const simulateHumanValidation = async ( toolCall : ToolCall ) : Promise < boolean > => { // This is where you'd implement your UI for human validation assert ( toolCall . toolName === 'hris_create_employee' , 'Tool name is not hris_create_employee' ); assert ( toolCall . args . name === 'John Doe' , 'Name is not John Doe' ); assert ( toolCall . args . personal_email === 'john.doe@example.com' , 'Email is not john.doe@example.com' ); assert ( toolCall . args . department === 'Engineering' , 'Department is not Engineering' ); assert ( toolCall . args . start_date === '2025-01-01' , 'Start date is not 2025-01-01' ); assert ( toolCall . args . hire_date === '2025-01-01' , 'Hire date is not 2025-01-01' ); // In a real application, you might show a UI that allows the user to: // 1. Review the parameters // 2. Edit parameter values if needed // 3. Approve or reject the execution // For this example, we'll just approve automatically return true ; }; humanInTheLoopExample ();","title":"Human In The Loop"},{"location":"human-in-the-loop/#human-in-the-loop","text":"Example showing how to do human-in-the-loop workflows with StackOne using the split functionality. This allows for more granular control over tool execution and validation. Run this with: bun run examples/human-in-the-loop.ts import { assert } from 'node:console' ; import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; import { StackOneToolSet } from '../src' ; import type { JsonDict } from '../src/types' ; interface ToolCall { toolName : string ; args : Record < string , unknown > ; } const humanInTheLoopExample = async () : Promise < void > => { // Create a toolset const toolset = new StackOneToolSet (); const hrisAccountId = 'workday_account_id' ; // Get the create employee tool const createEmployeeTool = toolset . getTool ( 'hris_create_employee' , { 'x-account-id' : hrisAccountId , }); if ( ! createEmployeeTool ) { throw new Error ( 'Create employee tool not found' ); } // Get the AI SDK version of the tool without the execute function const tool = createEmployeeTool . toAISDK ({ executable : false , }); // Use the metadata for AI planning/generation const { toolCalls } = await generateText ({ model : openai ( 'gpt-4o' ), tools : tool , prompt : 'Create a new employee in Workday, params: Full name: John Doe, personal email: john.doe@example.com, department: Engineering, start date: 2025-01-01, hire date: 2025-01-01' , maxSteps : 1 , }); // Human validation and modification step const toolCall = toolCalls [ 0 ] as ToolCall ; const shouldExecute = await simulateHumanValidation ( toolCall ); // Map of tool names to execution functions const executions : Record < string , ( args : Record < string , unknown > ) => Promise < JsonDict >> = { hris_create_employee : ( args ) => createEmployeeTool . execute ( args as JsonDict ), }; // Execute the tool if approved if ( shouldExecute && toolCall . toolName in executions ) { // You would call the tool here // const result = await executions[toolCall.toolName](toolCall.args); } else { console . log ( 'Tool execution was not approved or tool not found' ); } }; // Simulate human validation (in a real app, this would be your UI component) const simulateHumanValidation = async ( toolCall : ToolCall ) : Promise < boolean > => { // This is where you'd implement your UI for human validation assert ( toolCall . toolName === 'hris_create_employee' , 'Tool name is not hris_create_employee' ); assert ( toolCall . args . name === 'John Doe' , 'Name is not John Doe' ); assert ( toolCall . args . personal_email === 'john.doe@example.com' , 'Email is not john.doe@example.com' ); assert ( toolCall . args . department === 'Engineering' , 'Department is not Engineering' ); assert ( toolCall . args . start_date === '2025-01-01' , 'Start date is not 2025-01-01' ); assert ( toolCall . args . hire_date === '2025-01-01' , 'Hire date is not 2025-01-01' ); // In a real application, you might show a UI that allows the user to: // 1. Review the parameters // 2. Edit parameter values if needed // 3. Approve or reject the execution // For this example, we'll just approve automatically return true ; }; humanInTheLoopExample ();","title":"Human In The Loop"},{"location":"openai-integration/","text":"Openai Integration # This example shows how to use StackOne tools with OpenAI. import assert from 'node:assert' ; import OpenAI from 'openai' ; import { StackOneToolSet } from '../src' ; const openaiIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = '45072196112816593343' ; // Get the correct tool const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); const openAITools = tools . toOpenAI (); // Initialize OpenAI client const openai = new OpenAI (); // Create a chat completion with tool calls const response = await openai . chat . completions . create ({ model : 'gpt-4o-mini' , messages : [ { role : 'system' , content : 'You are a helpful assistant that can access HRIS information.' , }, { role : 'user' , content : 'What is the employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA phone number?' , }, ], tools : openAITools , }); // Verify the response contains tool calls assert ( response . choices . length > 0 , 'Expected at least one choice in the response' ); const choice = response . choices [ 0 ]; assert ( choice . message . tool_calls !== undefined , 'Expected tool_calls to be defined' ); assert ( choice . message . tool_calls . length > 0 , 'Expected at least one tool call' ); const toolCall = choice . message . tool_calls [ 0 ]; assert ( toolCall . function . name === 'hris_get_employee' , 'Expected tool call to be hris_get_employee' ); // Parse the arguments to verify they contain the expected fields const args = JSON . parse ( toolCall . function . arguments ); assert ( args . id === 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , 'Expected id to match the query' ); assert ( args . fields !== undefined , 'Expected fields to be defined' ); }; // Run the example openaiIntegration ();","title":"OpenAI"},{"location":"openai-integration/#openai-integration","text":"This example shows how to use StackOne tools with OpenAI. import assert from 'node:assert' ; import OpenAI from 'openai' ; import { StackOneToolSet } from '../src' ; const openaiIntegration = async () : Promise < void > => { // Initialize StackOne const toolset = new StackOneToolSet (); const accountId = '45072196112816593343' ; // Get the correct tool const tools = toolset . getStackOneTools ( 'hris_get_*' , accountId ); const openAITools = tools . toOpenAI (); // Initialize OpenAI client const openai = new OpenAI (); // Create a chat completion with tool calls const response = await openai . chat . completions . create ({ model : 'gpt-4o-mini' , messages : [ { role : 'system' , content : 'You are a helpful assistant that can access HRIS information.' , }, { role : 'user' , content : 'What is the employee with id: c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA phone number?' , }, ], tools : openAITools , }); // Verify the response contains tool calls assert ( response . choices . length > 0 , 'Expected at least one choice in the response' ); const choice = response . choices [ 0 ]; assert ( choice . message . tool_calls !== undefined , 'Expected tool_calls to be defined' ); assert ( choice . message . tool_calls . length > 0 , 'Expected at least one tool call' ); const toolCall = choice . message . tool_calls [ 0 ]; assert ( toolCall . function . name === 'hris_get_employee' , 'Expected tool call to be hris_get_employee' ); // Parse the arguments to verify they contain the expected fields const args = JSON . parse ( toolCall . function . arguments ); assert ( args . id === 'c28xIQaWQ6MzM5MzczMDA2NzMzMzkwNzIwNA' , 'Expected id to match the query' ); assert ( args . fields !== undefined , 'Expected fields to be defined' ); }; // Run the example openaiIntegration ();","title":"Openai Integration"},{"location":"openapi-toolset/","text":"Openapi Toolset # Basic OpenAPI Example This example demonstrates how to: 1. Load OpenAPI specifications from a file 2. Load OpenAPI specifications from a URL 3. Get and execute tools from the specifications import assert from 'node:assert' ; import { OpenAPIToolSet } from '../src/toolsets/openapi' ; import { joinPaths } from '../src/utils/file' ; Type for dry run result type DryRunResult = { url : string ; method : string ; headers? : Record < string , string > ; body? : string ; }; Example of loading OpenAPI specifications from a file async function fromFileExample () : Promise < void > { // Create an OpenAPIToolSet from a local file const toolset = new OpenAPIToolSet ({ filePath : joinPaths ( process . cwd (), 'src' , 'toolsets' , 'tests' , 'fixtures' , 'petstore.json' ), }); // Get all tools const tools = toolset . getTools ( '*Pet*' ); assert ( tools . length > 0 , 'Expected to find tools in the specification' ); // Get a specific tool const getPetTool = tools . getTool ( 'getPetById' ); assert ( getPetTool !== undefined , 'Expected to find getPetById tool' ); // Execute the tool with dry run to see what would be sent const result = ( await getPetTool . execute ({ petId : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . url . includes ( '/pet/123' ), 'Expected URL to contain pet ID' ); assert ( result . method === 'GET' , 'Expected GET method' ); } Example of loading OpenAPI specifications from a URL async function fromUrlExample () : Promise < void > { try { // Create an OpenAPIToolSet from a URL const toolset = await OpenAPIToolSet . fromUrl ({ url : 'https://api.eu1.stackone.com/oas/hris.json' , }); // Get tools matching a pattern const hrisTools = toolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Expected to find a bunch of tools' ); // Get a specific tool const getEmployeeTool = hrisTools . getTool ( 'hris_get_employee' ); assert ( getEmployeeTool !== undefined , 'Expected to find hris_get_employee tool' ); assert ( typeof getEmployeeTool . parameters . properties . id === 'object' && getEmployeeTool . parameters . properties . id !== null && getEmployeeTool . parameters . properties . id . type === 'string' , 'Expected to find string parameter for id' ); // Execute the tool with dry run to see what would be sent const result = ( await getEmployeeTool . execute ({ id : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . method === 'GET' , 'Expected GET method' ); assert ( result . url . includes ( '/employees/123' ), 'Expected URL to contain employee ID' ); assert ( result . body === undefined , 'Expected body to be undefined' ); } catch ( error ) { throw new Error ( `Failed to load from URL: ${ error instanceof Error ? error.message : String ( error ) } ` ); } } Run the examples async function main () : Promise < void > { try { // Run the file example await fromFileExample (); // Run the URL example await fromUrlExample (); } catch ( error ) { console . error ( error ); process . exit ( 1 ); } } main ();","title":"Getting Started"},{"location":"openapi-toolset/#openapi-toolset","text":"Basic OpenAPI Example This example demonstrates how to: 1. Load OpenAPI specifications from a file 2. Load OpenAPI specifications from a URL 3. Get and execute tools from the specifications import assert from 'node:assert' ; import { OpenAPIToolSet } from '../src/toolsets/openapi' ; import { joinPaths } from '../src/utils/file' ; Type for dry run result type DryRunResult = { url : string ; method : string ; headers? : Record < string , string > ; body? : string ; }; Example of loading OpenAPI specifications from a file async function fromFileExample () : Promise < void > { // Create an OpenAPIToolSet from a local file const toolset = new OpenAPIToolSet ({ filePath : joinPaths ( process . cwd (), 'src' , 'toolsets' , 'tests' , 'fixtures' , 'petstore.json' ), }); // Get all tools const tools = toolset . getTools ( '*Pet*' ); assert ( tools . length > 0 , 'Expected to find tools in the specification' ); // Get a specific tool const getPetTool = tools . getTool ( 'getPetById' ); assert ( getPetTool !== undefined , 'Expected to find getPetById tool' ); // Execute the tool with dry run to see what would be sent const result = ( await getPetTool . execute ({ petId : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . url . includes ( '/pet/123' ), 'Expected URL to contain pet ID' ); assert ( result . method === 'GET' , 'Expected GET method' ); } Example of loading OpenAPI specifications from a URL async function fromUrlExample () : Promise < void > { try { // Create an OpenAPIToolSet from a URL const toolset = await OpenAPIToolSet . fromUrl ({ url : 'https://api.eu1.stackone.com/oas/hris.json' , }); // Get tools matching a pattern const hrisTools = toolset . getTools ( 'hris_*' ); assert ( hrisTools . length > 0 , 'Expected to find a bunch of tools' ); // Get a specific tool const getEmployeeTool = hrisTools . getTool ( 'hris_get_employee' ); assert ( getEmployeeTool !== undefined , 'Expected to find hris_get_employee tool' ); assert ( typeof getEmployeeTool . parameters . properties . id === 'object' && getEmployeeTool . parameters . properties . id !== null && getEmployeeTool . parameters . properties . id . type === 'string' , 'Expected to find string parameter for id' ); // Execute the tool with dry run to see what would be sent const result = ( await getEmployeeTool . execute ({ id : 123 }, { dryRun : true })) as DryRunResult ; assert ( result !== undefined , 'Expected to get a result from dry run' ); assert ( result . method === 'GET' , 'Expected GET method' ); assert ( result . url . includes ( '/employees/123' ), 'Expected URL to contain employee ID' ); assert ( result . body === undefined , 'Expected body to be undefined' ); } catch ( error ) { throw new Error ( `Failed to load from URL: ${ error instanceof Error ? error.message : String ( error ) } ` ); } } Run the examples async function main () : Promise < void > { try { // Run the file example await fromFileExample (); // Run the URL example await fromUrlExample (); } catch ( error ) { console . error ( error ); process . exit ( 1 ); } } main ();","title":"Openapi Toolset"},{"location":"openapi-transformations/","text":"Openapi Transformations # OpenAPI with Parameter Transformations Example This example demonstrates how to: 1. Create custom parameter transformers 2. Use them with OpenAPI tools to derive additional parameters 3. Execute tools with minimal input, letting the transformers handle the rest import assert from 'node:assert' ; import fs from 'node:fs' ; import path from 'node:path' ; import { OpenAPIToolSet } from '../src/toolsets/openapi' ; import type { ParameterTransformer } from '../src/types' ; Create a mock OpenAPI specification for testing const createMockOpenAPISpec = () : string => { // Create a simple OpenAPI spec with two operations const spec = { openapi : '3.0.0' , info : { title : 'Parameter Transformation API' , version : '1.0.0' , }, paths : { '/upload' : { post : { operationId : 'upload_file' , description : 'Upload a file' , requestBody : { content : { 'multipart/form-data' : { schema : { type : 'object' , properties : { file_content : { type : 'string' , description : 'Base64-encoded file content' , }, file_name : { type : 'string' , description : 'Name of the file' , }, file_format : { type : 'string' , description : 'Format of the file' , }, }, required : [ 'file_content' , 'file_name' , 'file_format' ], }, }, }, }, responses : { '200' : { description : 'File uploaded successfully' , }, }, }, }, '/users/{user_id}' : { put : { operationId : 'update_user' , description : 'Update user details' , parameters : [ { name : 'user_id' , in : 'path' , required : true , schema : { type : 'string' , }, }, ], requestBody : { content : { 'application/json' : { schema : { type : 'object' , properties : { user_name : { type : 'string' , description : 'User name' , }, user_email : { type : 'string' , description : 'User email' , }, user_role : { type : 'string' , description : 'User role' , }, }, }, }, }, }, responses : { '200' : { description : 'User updated successfully' , }, }, }, }, }, }; // Write the spec to a temporary file const tempFile = path . join ( process . env . TMPDIR || '/tmp' , `parameter-transformation-spec- ${ Date . now () } .json` ); fs . writeFileSync ( tempFile , JSON . stringify ( spec , null , 2 )); return tempFile ; }; Create a file transformer This transformer extracts file_content, file_name, and file_format from file_path const createFileTransformer = () : ParameterTransformer => { return { transforms : { // Extract file content as base64 file_content : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } if ( ! fs . existsSync ( filePath )) { throw new Error ( `File not found: ${ filePath } ` ); } return fs . readFileSync ( filePath ). toString ( 'base64' ); }, // Extract file name file_name : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } return path . basename ( filePath ); }, // Extract file format (extension) file_format : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } const extension = path . extname ( filePath ). slice ( 1 ); return extension || '' ; }, }, }; }; Example of using parameter transformations with OpenAPI async function main () : Promise < void > { const specFilePath = createMockOpenAPISpec (); const fileTransformer = createFileTransformer (); // Create a transformers map for the toolset const transformers = new Map < string , ParameterTransformer > (); transformers . set ( 'file_path' , fileTransformer ); // Create the toolset with transformers const toolset = new OpenAPIToolSet ({ filePath : specFilePath , transformers , }); // Get the tools const tools = toolset . getTools (); const fileUploadTool = tools . getTool ( 'upload_file' ); assert ( fileUploadTool , 'Expected to find upload_file tool' ); const tempFilePath = path . join ( __dirname , 'temp.txt' ); fs . writeFileSync ( tempFilePath , 'Hello, world!' ); try { // Execute with just file_path - other parameters will be transformed const fileUploadResult = await fileUploadTool . execute ( { file_path : tempFilePath }, { dryRun : true } ); const fileParams = fileUploadResult . mappedParams as Record < string , unknown > ; // Assertions to validate the transformations worked assert ( fileParams . file_name === 'temp.txt' , 'Expected file_name to be transformed correctly' ); assert ( fileParams . file_format === 'txt' , 'Expected file_format to be transformed correctly' ); assert ( typeof fileParams . file_content === 'string' && fileParams . file_content . length > 0 , 'Expected file_content to be transformed correctly' ); } finally { try { fs . unlinkSync ( tempFilePath ); fs . unlinkSync ( specFilePath ); console . log ( 'Cleaned up temporary files' ); } catch ( error ) { console . error ( 'Error cleaning up temporary files:' , error ); } } } main ();","title":"Custom Transformations"},{"location":"openapi-transformations/#openapi-transformations","text":"OpenAPI with Parameter Transformations Example This example demonstrates how to: 1. Create custom parameter transformers 2. Use them with OpenAPI tools to derive additional parameters 3. Execute tools with minimal input, letting the transformers handle the rest import assert from 'node:assert' ; import fs from 'node:fs' ; import path from 'node:path' ; import { OpenAPIToolSet } from '../src/toolsets/openapi' ; import type { ParameterTransformer } from '../src/types' ; Create a mock OpenAPI specification for testing const createMockOpenAPISpec = () : string => { // Create a simple OpenAPI spec with two operations const spec = { openapi : '3.0.0' , info : { title : 'Parameter Transformation API' , version : '1.0.0' , }, paths : { '/upload' : { post : { operationId : 'upload_file' , description : 'Upload a file' , requestBody : { content : { 'multipart/form-data' : { schema : { type : 'object' , properties : { file_content : { type : 'string' , description : 'Base64-encoded file content' , }, file_name : { type : 'string' , description : 'Name of the file' , }, file_format : { type : 'string' , description : 'Format of the file' , }, }, required : [ 'file_content' , 'file_name' , 'file_format' ], }, }, }, }, responses : { '200' : { description : 'File uploaded successfully' , }, }, }, }, '/users/{user_id}' : { put : { operationId : 'update_user' , description : 'Update user details' , parameters : [ { name : 'user_id' , in : 'path' , required : true , schema : { type : 'string' , }, }, ], requestBody : { content : { 'application/json' : { schema : { type : 'object' , properties : { user_name : { type : 'string' , description : 'User name' , }, user_email : { type : 'string' , description : 'User email' , }, user_role : { type : 'string' , description : 'User role' , }, }, }, }, }, }, responses : { '200' : { description : 'User updated successfully' , }, }, }, }, }, }; // Write the spec to a temporary file const tempFile = path . join ( process . env . TMPDIR || '/tmp' , `parameter-transformation-spec- ${ Date . now () } .json` ); fs . writeFileSync ( tempFile , JSON . stringify ( spec , null , 2 )); return tempFile ; }; Create a file transformer This transformer extracts file_content, file_name, and file_format from file_path const createFileTransformer = () : ParameterTransformer => { return { transforms : { // Extract file content as base64 file_content : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } if ( ! fs . existsSync ( filePath )) { throw new Error ( `File not found: ${ filePath } ` ); } return fs . readFileSync ( filePath ). toString ( 'base64' ); }, // Extract file name file_name : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } return path . basename ( filePath ); }, // Extract file format (extension) file_format : ( filePath : unknown ) : string => { if ( typeof filePath !== 'string' ) { throw new Error ( 'file_path must be a string' ); } const extension = path . extname ( filePath ). slice ( 1 ); return extension || '' ; }, }, }; }; Example of using parameter transformations with OpenAPI async function main () : Promise < void > { const specFilePath = createMockOpenAPISpec (); const fileTransformer = createFileTransformer (); // Create a transformers map for the toolset const transformers = new Map < string , ParameterTransformer > (); transformers . set ( 'file_path' , fileTransformer ); // Create the toolset with transformers const toolset = new OpenAPIToolSet ({ filePath : specFilePath , transformers , }); // Get the tools const tools = toolset . getTools (); const fileUploadTool = tools . getTool ( 'upload_file' ); assert ( fileUploadTool , 'Expected to find upload_file tool' ); const tempFilePath = path . join ( __dirname , 'temp.txt' ); fs . writeFileSync ( tempFilePath , 'Hello, world!' ); try { // Execute with just file_path - other parameters will be transformed const fileUploadResult = await fileUploadTool . execute ( { file_path : tempFilePath }, { dryRun : true } ); const fileParams = fileUploadResult . mappedParams as Record < string , unknown > ; // Assertions to validate the transformations worked assert ( fileParams . file_name === 'temp.txt' , 'Expected file_name to be transformed correctly' ); assert ( fileParams . file_format === 'txt' , 'Expected file_format to be transformed correctly' ); assert ( typeof fileParams . file_content === 'string' && fileParams . file_content . length > 0 , 'Expected file_content to be transformed correctly' ); } finally { try { fs . unlinkSync ( tempFilePath ); fs . unlinkSync ( specFilePath ); console . log ( 'Cleaned up temporary files' ); } catch ( error ) { console . error ( 'Error cleaning up temporary files:' , error ); } } } main ();","title":"Openapi Transformations"},{"location":"planning/","text":"Planning # While building agents you may find that your workflow is too complex for a general purpose agent. StackOne AI SDK provides access to a state of the art planning agent which allows you to create, cache, and execute complex workflows on verticals supported by StackOne . For example, onboard a new hire from your ATS to your HRIS. import { StackOneToolSet } from '../src' ; const toolset = new StackOneToolSet (); const onboardWorkflow = await toolset . plan ({ key : 'custom_onboarding' , input : 'Onboard the last new hire from Teamtailor to Workday' , model : 'stackone-planner-latest' , tools : [ 'hris_*' , 'ats_*' ], accountIds : [ 'teamtailor_account_id' , 'workday_account_id' ], cache : true , // saves the plan to $HOME/.stackone/plans }); await onboardWorkflow . execute (); or use as part of a larger agent (using AI SDK by Vercel) import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; await generateText ({ model : openai ( 'gpt-4o' ), prompt : 'You are a workplace agent, onboard the latest hires to our systems' , tools : onboardWorkflow.toAISDK (), maxSteps : 3 , }); /* * The planning model is in closed beta and only available to design partners. * Apply for the waitlist [here](https://www.stackone.com/demo). */","title":"Planning"},{"location":"planning/#planning","text":"While building agents you may find that your workflow is too complex for a general purpose agent. StackOne AI SDK provides access to a state of the art planning agent which allows you to create, cache, and execute complex workflows on verticals supported by StackOne . For example, onboard a new hire from your ATS to your HRIS. import { StackOneToolSet } from '../src' ; const toolset = new StackOneToolSet (); const onboardWorkflow = await toolset . plan ({ key : 'custom_onboarding' , input : 'Onboard the last new hire from Teamtailor to Workday' , model : 'stackone-planner-latest' , tools : [ 'hris_*' , 'ats_*' ], accountIds : [ 'teamtailor_account_id' , 'workday_account_id' ], cache : true , // saves the plan to $HOME/.stackone/plans }); await onboardWorkflow . execute (); or use as part of a larger agent (using AI SDK by Vercel) import { openai } from '@ai-sdk/openai' ; import { generateText } from 'ai' ; await generateText ({ model : openai ( 'gpt-4o' ), prompt : 'You are a workplace agent, onboard the latest hires to our systems' , tools : onboardWorkflow.toAISDK (), maxSteps : 3 , }); /* * The planning model is in closed beta and only available to design partners. * Apply for the waitlist [here](https://www.stackone.com/demo). */","title":"Planning"}]}